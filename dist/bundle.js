/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/*! no exports provided */
/*! ModuleConcatenation bailout: Module uses injected variables (PIXI) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(PIXI) {/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pixi_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi-layers */ \"pixi-layers\");\n/* harmony import */ var pixi_layers__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_layers__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pixi-sound */ \"pixi-sound\");\n/* harmony import */ var pixi_sound__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pixi_sound__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resources */ \"./src/resources.ts\");\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scene */ \"./src/scene.ts\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n(function () {\n    return __awaiter(this, void 0, void 0, function* () {\n        PIXI.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;\n        PIXI.sound.volumeAll = 0.5;\n        const app = new PIXI.Application({\n            width: 1200,\n            height: 700,\n            resolution: 1,\n            antialias: false,\n        });\n        const stage = new PIXI.display.Stage();\n        app.stage = stage;\n        app.renderer.backgroundColor = _ui__WEBPACK_IMPORTED_MODULE_5__[\"Colors\"].background;\n        const resources = new _resources__WEBPACK_IMPORTED_MODULE_3__[\"Resources\"](app.loader);\n        yield resources.load();\n        document.getElementById(\"container\").appendChild(app.view);\n        const controller = new _scene__WEBPACK_IMPORTED_MODULE_4__[\"SceneController\"](resources, app, stage);\n        controller.keyBind();\n    });\n})();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pixi.js */ \"pixi.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC50cz82ODUyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCBcInBpeGkuanNcIjtcbmltcG9ydCBcInBpeGktbGF5ZXJzXCI7XG5pbXBvcnQgXCJwaXhpLXNvdW5kXCI7XG5pbXBvcnQgeyBSZXNvdXJjZXMgfSBmcm9tIFwiLi9yZXNvdXJjZXNcIjtcbmltcG9ydCB7IFNjZW5lQ29udHJvbGxlciB9IGZyb20gXCIuL3NjZW5lXCI7XG5pbXBvcnQgeyBDb2xvcnMgfSBmcm9tIFwiLi91aVwiO1xuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBQSVhJLnNldHRpbmdzLkZBSUxfSUZfTUFKT1JfUEVSRk9STUFOQ0VfQ0FWRUFUID0gZmFsc2U7XG4gICAgICAgIFBJWEkuc291bmQudm9sdW1lQWxsID0gMC41O1xuICAgICAgICBjb25zdCBhcHAgPSBuZXcgUElYSS5BcHBsaWNhdGlvbih7XG4gICAgICAgICAgICB3aWR0aDogMTIwMCxcbiAgICAgICAgICAgIGhlaWdodDogNzAwLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdGFnZSA9IG5ldyBQSVhJLmRpc3BsYXkuU3RhZ2UoKTtcbiAgICAgICAgYXBwLnN0YWdlID0gc3RhZ2U7XG4gICAgICAgIGFwcC5yZW5kZXJlci5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvcnMuYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gbmV3IFJlc291cmNlcyhhcHAubG9hZGVyKTtcbiAgICAgICAgeWllbGQgcmVzb3VyY2VzLmxvYWQoKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb250YWluZXJcIikuYXBwZW5kQ2hpbGQoYXBwLnZpZXcpO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IFNjZW5lQ29udHJvbGxlcihyZXNvdXJjZXMsIGFwcCwgc3RhZ2UpO1xuICAgICAgICBjb250cm9sbGVyLmtleUJpbmQoKTtcbiAgICB9KTtcbn0pKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app.ts\n");

/***/ }),

/***/ "./src/curves.ts":
/*!***********************!*\
  !*** ./src/curves.ts ***!
  \***********************/
/*! exports provided: LinearCurve, BezierCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinearCurve\", function() { return LinearCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BezierCurve\", function() { return BezierCurve; });\nfunction factorial(n) {\n    let result = 1;\n    for (let k = 2; k <= n; k++) {\n        result = result * k;\n    }\n    return result;\n}\nclass LinearCurve {\n    static line() {\n        return t => t;\n    }\n}\nclass BezierCurve {\n    static basis(i, n, t) {\n        return (factorial(n) / (factorial(i) * factorial(n - i))) * Math.pow(t, i) * Math.pow(1 - t, n - i);\n    }\n    static line(...controlPoints) {\n        const n = controlPoints.length - 1;\n        return (t) => {\n            if (t > 1) {\n                t = 1;\n            }\n            let point = 0;\n            for (let i = 0; i < controlPoints.length; i++) {\n                let b = BezierCurve.basis(i, n, t);\n                point += controlPoints[i] * b;\n            }\n            return point;\n        };\n    }\n    static matrix(...controlPoints) {\n        const n = controlPoints.length - 1;\n        const D = controlPoints[0].length;\n        return (t) => {\n            if (t > 1) {\n                t = 1;\n            }\n            let point = [];\n            for (let d = 0; d < D; d++) {\n                point[d] = 0;\n            }\n            for (let i = 0; i < controlPoints.length; i++) {\n                let b = BezierCurve.basis(i, n, t);\n                for (let d = 0; d < D; d++) {\n                    point[d] += controlPoints[i][d] * b;\n                }\n            }\n            return point;\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY3VydmVzLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2N1cnZlcy50cz9iODE3Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGZhY3RvcmlhbChuKSB7XG4gICAgbGV0IHJlc3VsdCA9IDE7XG4gICAgZm9yIChsZXQgayA9IDI7IGsgPD0gbjsgaysrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIGs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY2xhc3MgTGluZWFyQ3VydmUge1xuICAgIHN0YXRpYyBsaW5lKCkge1xuICAgICAgICByZXR1cm4gdCA9PiB0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCZXppZXJDdXJ2ZSB7XG4gICAgc3RhdGljIGJhc2lzKGksIG4sIHQpIHtcbiAgICAgICAgcmV0dXJuIChmYWN0b3JpYWwobikgLyAoZmFjdG9yaWFsKGkpICogZmFjdG9yaWFsKG4gLSBpKSkpICogTWF0aC5wb3codCwgaSkgKiBNYXRoLnBvdygxIC0gdCwgbiAtIGkpO1xuICAgIH1cbiAgICBzdGF0aWMgbGluZSguLi5jb250cm9sUG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IG4gPSBjb250cm9sUG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiAodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcG9pbnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250cm9sUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGIgPSBCZXppZXJDdXJ2ZS5iYXNpcyhpLCBuLCB0KTtcbiAgICAgICAgICAgICAgICBwb2ludCArPSBjb250cm9sUG9pbnRzW2ldICogYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIG1hdHJpeCguLi5jb250cm9sUG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IG4gPSBjb250cm9sUG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IEQgPSBjb250cm9sUG9pbnRzWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuICh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwb2ludCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBEOyBkKyspIHtcbiAgICAgICAgICAgICAgICBwb2ludFtkXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRyb2xQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYiA9IEJlemllckN1cnZlLmJhc2lzKGksIG4sIHQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgRDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50W2RdICs9IGNvbnRyb2xQb2ludHNbaV1bZF0gKiBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/curves.ts\n");

/***/ }),

/***/ "./src/drop.ts":
/*!*********************!*\
  !*** ./src/drop.ts ***!
  \*********************/
/*! exports provided: Coins, HealthFlask, HealthBigFlask, weapons, monsterWeapons, weaponConfigs, Weapon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Coins\", function() { return Coins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HealthFlask\", function() { return HealthFlask; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HealthBigFlask\", function() { return HealthBigFlask; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"weapons\", function() { return weapons; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"monsterWeapons\", function() { return monsterWeapons; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"weaponConfigs\", function() { return weaponConfigs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Weapon\", function() { return Weapon; });\n/* harmony import */ var _curves__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves */ \"./src/curves.ts\");\n\nclass Coins {\n    constructor(rng, resources) {\n        this.spriteName = \"coin\";\n        this.resources = resources;\n        this.coins = rng.nextRange(1, 30);\n    }\n    pickedUp(hero) {\n        hero.addCoins(this.coins);\n        return true;\n    }\n    ;\n    sprite() {\n        return this.resources.animated(this.spriteName);\n    }\n}\nclass HealthFlask {\n    constructor(resources) {\n        this.spriteName = \"flask_red.png\";\n        this.resources = resources;\n        this.health = 2;\n    }\n    info() {\n        return {\n            name: \"Health flask\",\n            health: this.health\n        };\n    }\n    pickedUp(hero) {\n        return hero.inventory.add(this);\n    }\n    ;\n    same(item) {\n        return item instanceof HealthFlask;\n    }\n    ;\n    use(cell, hero) {\n        hero.heal(this.health);\n        cell.decrease();\n    }\n    ;\n    sprite() {\n        return this.resources.sprite(this.spriteName);\n    }\n}\nclass HealthBigFlask {\n    constructor(resources) {\n        this.spriteName = \"flask_big_red.png\";\n        this.resources = resources;\n        this.health = 5;\n    }\n    info() {\n        return {\n            name: \"Big health flask\",\n            health: this.health\n        };\n    }\n    pickedUp(hero) {\n        return hero.inventory.add(this);\n    }\n    ;\n    sprite() {\n        return this.resources.sprite(this.spriteName);\n    }\n    same(item) {\n        return item instanceof HealthBigFlask;\n    }\n    ;\n    use(cell, hero) {\n        hero.heal(this.health);\n        cell.decrease();\n    }\n    ;\n}\nconst weapons = {\n    knife: { name: \"weapon_knife\", speed: 1.4, distance: 1, damage: 2, level: 1, price: 12 },\n    rusty_sword: { name: \"weapon_rusty_sword\", speed: 1.0, distance: 1, damage: 4, level: 1, price: 15 },\n    regular_sword: { name: \"weapon_regular_sword\", speed: 1.0, distance: 1, damage: 5, level: 3, price: 20 },\n    red_gem_sword: { name: \"weapon_red_gem_sword\", speed: 1.0, distance: 1, damage: 6, level: 3, price: 30 },\n    hammer: { name: \"weapon_hammer\", speed: 0.7, distance: 1, damage: 7, level: 5, price: 38 },\n    big_hammer: { name: \"weapon_big_hammer\", speed: 0.5, distance: 2, damage: 10, level: 5, price: 40 },\n    baton_with_spikes: { name: \"weapon_baton_with_spikes\", speed: 0.6, distance: 1, damage: 7, level: 5, price: 42 },\n    mace: { name: \"weapon_mace\", speed: 0.6, distance: 1, damage: 7, level: 5, price: 45 },\n    katana: { name: \"weapon_katana\", speed: 1.5, distance: 1, damage: 8, level: 7, price: 100 },\n    saw_sword: { name: \"weapon_saw_sword\", speed: 1.5, distance: 1, damage: 9, level: 7, price: 110 },\n    anime_sword: { name: \"weapon_anime_sword\", speed: 0.7, distance: 1, damage: 12, level: 7, price: 130 },\n    axe: { name: \"weapon_axe\", speed: 0.8, distance: 1, damage: 12, level: 7, price: 115 },\n    machete: { name: \"weapon_machete\", speed: 1.0, distance: 1, damage: 11, level: 9, price: 150 },\n    cleaver: { name: \"weapon_cleaver\", speed: 1.0, distance: 1, damage: 12, level: 9, price: 160 },\n    duel_sword: { name: \"weapon_duel_sword\", speed: 1.5, distance: 1, damage: 13, level: 9, price: 170 },\n    knight_sword: { name: \"weapon_knight_sword\", speed: 1.5, distance: 1, damage: 14, level: 9, price: 180 },\n    golden_sword: { name: \"weapon_golden_sword\", speed: 1.5, distance: 1, damage: 15, level: 11, price: 220 },\n    lavish_sword: { name: \"weapon_lavish_sword\", speed: 1.5, distance: 1, damage: 16, level: 11, price: 240 },\n};\nconst monsterWeapons = {\n    knife: { name: \"weapon_knife\", speed: 0.7, distance: 1, damage: 0.5, level: 1, price: 0 },\n    baton_with_spikes: { name: \"weapon_baton_with_spikes\", speed: 0.3, distance: 1, damage: 3, level: 5, price: 0 },\n    anime_sword: { name: \"weapon_anime_sword\", speed: 0.4, distance: 1, damage: 4, level: 10, price: 0 },\n    big_hammer: { name: \"weapon_big_hammer\", speed: 0.3, distance: 2, damage: 5, level: 15, price: 0 },\n    mace: { name: \"weapon_mace\", speed: 0.6, distance: 1, damage: 6, level: 20, price: 0 },\n    cleaver: { name: \"weapon_cleaver\", speed: 0.5, distance: 1, damage: 7, level: 25, price: 0 },\n};\nconst weaponConfigs = Object.getOwnPropertyNames(weapons).map(w => weapons[w]);\nclass Weapon {\n    constructor(resources, config) {\n        this.curve = _curves__WEBPACK_IMPORTED_MODULE_0__[\"BezierCurve\"].line(0, -0.5, -1, 0, 1, 2, 0);\n        this.resources = resources;\n        this.name = config.name;\n        this.speed = config.speed;\n        this.distance = config.distance;\n        this.damage = config.damage;\n        this.price = config.price;\n    }\n    get spriteName() {\n        return this.name + \".png\";\n    }\n    info() {\n        return {\n            name: this.name.replace(/weapon_/, ''),\n            speed: this.speed,\n            distance: this.distance,\n            damage: this.damage,\n            price: this.price\n        };\n    }\n    sprite() {\n        return this.resources.sprite(this.spriteName);\n    }\n    pickedUp(hero) {\n        return hero.inventory.add(this);\n    }\n    same(_item) {\n        return false;\n    }\n    use(cell, hero) {\n        const prev = hero.inventory.equipment.weapon.item.get();\n        hero.inventory.equipment.weapon.clear();\n        hero.inventory.equipment.weapon.set(this);\n        cell.clear();\n        if (prev) {\n            cell.set(prev);\n        }\n    }\n    static create(resources, rng, level) {\n        const available = weaponConfigs.filter(c => c.level <= level);\n        if (available.length > 0) {\n            const config = rng.choice(available);\n            return new Weapon(resources, config);\n        }\n        else {\n            return null;\n        }\n    }\n    static select(resources, rng, weapons) {\n        if (weapons.length > 0) {\n            const config = rng.choice(weapons);\n            return new Weapon(resources, config);\n        }\n        else {\n            return null;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZHJvcC50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9kcm9wLnRzPzRkZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmV6aWVyQ3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXNcIjtcbmV4cG9ydCBjbGFzcyBDb2lucyB7XG4gICAgY29uc3RydWN0b3Iocm5nLCByZXNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5zcHJpdGVOYW1lID0gXCJjb2luXCI7XG4gICAgICAgIHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuICAgICAgICB0aGlzLmNvaW5zID0gcm5nLm5leHRSYW5nZSgxLCAzMCk7XG4gICAgfVxuICAgIHBpY2tlZFVwKGhlcm8pIHtcbiAgICAgICAgaGVyby5hZGRDb2lucyh0aGlzLmNvaW5zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIDtcbiAgICBzcHJpdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc291cmNlcy5hbmltYXRlZCh0aGlzLnNwcml0ZU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBIZWFsdGhGbGFzayB7XG4gICAgY29uc3RydWN0b3IocmVzb3VyY2VzKSB7XG4gICAgICAgIHRoaXMuc3ByaXRlTmFtZSA9IFwiZmxhc2tfcmVkLnBuZ1wiO1xuICAgICAgICB0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcbiAgICAgICAgdGhpcy5oZWFsdGggPSAyO1xuICAgIH1cbiAgICBpbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogXCJIZWFsdGggZmxhc2tcIixcbiAgICAgICAgICAgIGhlYWx0aDogdGhpcy5oZWFsdGhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGlja2VkVXAoaGVybykge1xuICAgICAgICByZXR1cm4gaGVyby5pbnZlbnRvcnkuYWRkKHRoaXMpO1xuICAgIH1cbiAgICA7XG4gICAgc2FtZShpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtIGluc3RhbmNlb2YgSGVhbHRoRmxhc2s7XG4gICAgfVxuICAgIDtcbiAgICB1c2UoY2VsbCwgaGVybykge1xuICAgICAgICBoZXJvLmhlYWwodGhpcy5oZWFsdGgpO1xuICAgICAgICBjZWxsLmRlY3JlYXNlKCk7XG4gICAgfVxuICAgIDtcbiAgICBzcHJpdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc291cmNlcy5zcHJpdGUodGhpcy5zcHJpdGVOYW1lKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSGVhbHRoQmlnRmxhc2sge1xuICAgIGNvbnN0cnVjdG9yKHJlc291cmNlcykge1xuICAgICAgICB0aGlzLnNwcml0ZU5hbWUgPSBcImZsYXNrX2JpZ19yZWQucG5nXCI7XG4gICAgICAgIHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuICAgICAgICB0aGlzLmhlYWx0aCA9IDU7XG4gICAgfVxuICAgIGluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBcIkJpZyBoZWFsdGggZmxhc2tcIixcbiAgICAgICAgICAgIGhlYWx0aDogdGhpcy5oZWFsdGhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGlja2VkVXAoaGVybykge1xuICAgICAgICByZXR1cm4gaGVyby5pbnZlbnRvcnkuYWRkKHRoaXMpO1xuICAgIH1cbiAgICA7XG4gICAgc3ByaXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXMuc3ByaXRlKHRoaXMuc3ByaXRlTmFtZSk7XG4gICAgfVxuICAgIHNhbWUoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhlYWx0aEJpZ0ZsYXNrO1xuICAgIH1cbiAgICA7XG4gICAgdXNlKGNlbGwsIGhlcm8pIHtcbiAgICAgICAgaGVyby5oZWFsKHRoaXMuaGVhbHRoKTtcbiAgICAgICAgY2VsbC5kZWNyZWFzZSgpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnQgY29uc3Qgd2VhcG9ucyA9IHtcbiAgICBrbmlmZTogeyBuYW1lOiBcIndlYXBvbl9rbmlmZVwiLCBzcGVlZDogMS40LCBkaXN0YW5jZTogMSwgZGFtYWdlOiAyLCBsZXZlbDogMSwgcHJpY2U6IDEyIH0sXG4gICAgcnVzdHlfc3dvcmQ6IHsgbmFtZTogXCJ3ZWFwb25fcnVzdHlfc3dvcmRcIiwgc3BlZWQ6IDEuMCwgZGlzdGFuY2U6IDEsIGRhbWFnZTogNCwgbGV2ZWw6IDEsIHByaWNlOiAxNSB9LFxuICAgIHJlZ3VsYXJfc3dvcmQ6IHsgbmFtZTogXCJ3ZWFwb25fcmVndWxhcl9zd29yZFwiLCBzcGVlZDogMS4wLCBkaXN0YW5jZTogMSwgZGFtYWdlOiA1LCBsZXZlbDogMywgcHJpY2U6IDIwIH0sXG4gICAgcmVkX2dlbV9zd29yZDogeyBuYW1lOiBcIndlYXBvbl9yZWRfZ2VtX3N3b3JkXCIsIHNwZWVkOiAxLjAsIGRpc3RhbmNlOiAxLCBkYW1hZ2U6IDYsIGxldmVsOiAzLCBwcmljZTogMzAgfSxcbiAgICBoYW1tZXI6IHsgbmFtZTogXCJ3ZWFwb25faGFtbWVyXCIsIHNwZWVkOiAwLjcsIGRpc3RhbmNlOiAxLCBkYW1hZ2U6IDcsIGxldmVsOiA1LCBwcmljZTogMzggfSxcbiAgICBiaWdfaGFtbWVyOiB7IG5hbWU6IFwid2VhcG9uX2JpZ19oYW1tZXJcIiwgc3BlZWQ6IDAuNSwgZGlzdGFuY2U6IDIsIGRhbWFnZTogMTAsIGxldmVsOiA1LCBwcmljZTogNDAgfSxcbiAgICBiYXRvbl93aXRoX3NwaWtlczogeyBuYW1lOiBcIndlYXBvbl9iYXRvbl93aXRoX3NwaWtlc1wiLCBzcGVlZDogMC42LCBkaXN0YW5jZTogMSwgZGFtYWdlOiA3LCBsZXZlbDogNSwgcHJpY2U6IDQyIH0sXG4gICAgbWFjZTogeyBuYW1lOiBcIndlYXBvbl9tYWNlXCIsIHNwZWVkOiAwLjYsIGRpc3RhbmNlOiAxLCBkYW1hZ2U6IDcsIGxldmVsOiA1LCBwcmljZTogNDUgfSxcbiAgICBrYXRhbmE6IHsgbmFtZTogXCJ3ZWFwb25fa2F0YW5hXCIsIHNwZWVkOiAxLjUsIGRpc3RhbmNlOiAxLCBkYW1hZ2U6IDgsIGxldmVsOiA3LCBwcmljZTogMTAwIH0sXG4gICAgc2F3X3N3b3JkOiB7IG5hbWU6IFwid2VhcG9uX3Nhd19zd29yZFwiLCBzcGVlZDogMS41LCBkaXN0YW5jZTogMSwgZGFtYWdlOiA5LCBsZXZlbDogNywgcHJpY2U6IDExMCB9LFxuICAgIGFuaW1lX3N3b3JkOiB7IG5hbWU6IFwid2VhcG9uX2FuaW1lX3N3b3JkXCIsIHNwZWVkOiAwLjcsIGRpc3RhbmNlOiAxLCBkYW1hZ2U6IDEyLCBsZXZlbDogNywgcHJpY2U6IDEzMCB9LFxuICAgIGF4ZTogeyBuYW1lOiBcIndlYXBvbl9heGVcIiwgc3BlZWQ6IDAuOCwgZGlzdGFuY2U6IDEsIGRhbWFnZTogMTIsIGxldmVsOiA3LCBwcmljZTogMTE1IH0sXG4gICAgbWFjaGV0ZTogeyBuYW1lOiBcIndlYXBvbl9tYWNoZXRlXCIsIHNwZWVkOiAxLjAsIGRpc3RhbmNlOiAxLCBkYW1hZ2U6IDExLCBsZXZlbDogOSwgcHJpY2U6IDE1MCB9LFxuICAgIGNsZWF2ZXI6IHsgbmFtZTogXCJ3ZWFwb25fY2xlYXZlclwiLCBzcGVlZDogMS4wLCBkaXN0YW5jZTogMSwgZGFtYWdlOiAxMiwgbGV2ZWw6IDksIHByaWNlOiAxNjAgfSxcbiAgICBkdWVsX3N3b3JkOiB7IG5hbWU6IFwid2VhcG9uX2R1ZWxfc3dvcmRcIiwgc3BlZWQ6IDEuNSwgZGlzdGFuY2U6IDEsIGRhbWFnZTogMTMsIGxldmVsOiA5LCBwcmljZTogMTcwIH0sXG4gICAga25pZ2h0X3N3b3JkOiB7IG5hbWU6IFwid2VhcG9uX2tuaWdodF9zd29yZFwiLCBzcGVlZDogMS41LCBkaXN0YW5jZTogMSwgZGFtYWdlOiAxNCwgbGV2ZWw6IDksIHByaWNlOiAxODAgfSxcbiAgICBnb2xkZW5fc3dvcmQ6IHsgbmFtZTogXCJ3ZWFwb25fZ29sZGVuX3N3b3JkXCIsIHNwZWVkOiAxLjUsIGRpc3RhbmNlOiAxLCBkYW1hZ2U6IDE1LCBsZXZlbDogMTEsIHByaWNlOiAyMjAgfSxcbiAgICBsYXZpc2hfc3dvcmQ6IHsgbmFtZTogXCJ3ZWFwb25fbGF2aXNoX3N3b3JkXCIsIHNwZWVkOiAxLjUsIGRpc3RhbmNlOiAxLCBkYW1hZ2U6IDE2LCBsZXZlbDogMTEsIHByaWNlOiAyNDAgfSxcbn07XG5leHBvcnQgY29uc3QgbW9uc3RlcldlYXBvbnMgPSB7XG4gICAga25pZmU6IHsgbmFtZTogXCJ3ZWFwb25fa25pZmVcIiwgc3BlZWQ6IDAuNywgZGlzdGFuY2U6IDEsIGRhbWFnZTogMC41LCBsZXZlbDogMSwgcHJpY2U6IDAgfSxcbiAgICBiYXRvbl93aXRoX3NwaWtlczogeyBuYW1lOiBcIndlYXBvbl9iYXRvbl93aXRoX3NwaWtlc1wiLCBzcGVlZDogMC4zLCBkaXN0YW5jZTogMSwgZGFtYWdlOiAzLCBsZXZlbDogNSwgcHJpY2U6IDAgfSxcbiAgICBhbmltZV9zd29yZDogeyBuYW1lOiBcIndlYXBvbl9hbmltZV9zd29yZFwiLCBzcGVlZDogMC40LCBkaXN0YW5jZTogMSwgZGFtYWdlOiA0LCBsZXZlbDogMTAsIHByaWNlOiAwIH0sXG4gICAgYmlnX2hhbW1lcjogeyBuYW1lOiBcIndlYXBvbl9iaWdfaGFtbWVyXCIsIHNwZWVkOiAwLjMsIGRpc3RhbmNlOiAyLCBkYW1hZ2U6IDUsIGxldmVsOiAxNSwgcHJpY2U6IDAgfSxcbiAgICBtYWNlOiB7IG5hbWU6IFwid2VhcG9uX21hY2VcIiwgc3BlZWQ6IDAuNiwgZGlzdGFuY2U6IDEsIGRhbWFnZTogNiwgbGV2ZWw6IDIwLCBwcmljZTogMCB9LFxuICAgIGNsZWF2ZXI6IHsgbmFtZTogXCJ3ZWFwb25fY2xlYXZlclwiLCBzcGVlZDogMC41LCBkaXN0YW5jZTogMSwgZGFtYWdlOiA3LCBsZXZlbDogMjUsIHByaWNlOiAwIH0sXG59O1xuZXhwb3J0IGNvbnN0IHdlYXBvbkNvbmZpZ3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3ZWFwb25zKS5tYXAodyA9PiB3ZWFwb25zW3ddKTtcbmV4cG9ydCBjbGFzcyBXZWFwb24ge1xuICAgIGNvbnN0cnVjdG9yKHJlc291cmNlcywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY3VydmUgPSBCZXppZXJDdXJ2ZS5saW5lKDAsIC0wLjUsIC0xLCAwLCAxLCAyLCAwKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG4gICAgICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICB0aGlzLnNwZWVkID0gY29uZmlnLnNwZWVkO1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gY29uZmlnLmRpc3RhbmNlO1xuICAgICAgICB0aGlzLmRhbWFnZSA9IGNvbmZpZy5kYW1hZ2U7XG4gICAgICAgIHRoaXMucHJpY2UgPSBjb25maWcucHJpY2U7XG4gICAgfVxuICAgIGdldCBzcHJpdGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCIucG5nXCI7XG4gICAgfVxuICAgIGluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUucmVwbGFjZSgvd2VhcG9uXy8sICcnKSxcbiAgICAgICAgICAgIHNwZWVkOiB0aGlzLnNwZWVkLFxuICAgICAgICAgICAgZGlzdGFuY2U6IHRoaXMuZGlzdGFuY2UsXG4gICAgICAgICAgICBkYW1hZ2U6IHRoaXMuZGFtYWdlLFxuICAgICAgICAgICAgcHJpY2U6IHRoaXMucHJpY2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3ByaXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXMuc3ByaXRlKHRoaXMuc3ByaXRlTmFtZSk7XG4gICAgfVxuICAgIHBpY2tlZFVwKGhlcm8pIHtcbiAgICAgICAgcmV0dXJuIGhlcm8uaW52ZW50b3J5LmFkZCh0aGlzKTtcbiAgICB9XG4gICAgc2FtZShfaXRlbSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVzZShjZWxsLCBoZXJvKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBoZXJvLmludmVudG9yeS5lcXVpcG1lbnQud2VhcG9uLml0ZW0uZ2V0KCk7XG4gICAgICAgIGhlcm8uaW52ZW50b3J5LmVxdWlwbWVudC53ZWFwb24uY2xlYXIoKTtcbiAgICAgICAgaGVyby5pbnZlbnRvcnkuZXF1aXBtZW50LndlYXBvbi5zZXQodGhpcyk7XG4gICAgICAgIGNlbGwuY2xlYXIoKTtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGNlbGwuc2V0KHByZXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocmVzb3VyY2VzLCBybmcsIGxldmVsKSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHdlYXBvbkNvbmZpZ3MuZmlsdGVyKGMgPT4gYy5sZXZlbCA8PSBsZXZlbCk7XG4gICAgICAgIGlmIChhdmFpbGFibGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gcm5nLmNob2ljZShhdmFpbGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWFwb24ocmVzb3VyY2VzLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHNlbGVjdChyZXNvdXJjZXMsIHJuZywgd2VhcG9ucykge1xuICAgICAgICBpZiAod2VhcG9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBybmcuY2hvaWNlKHdlYXBvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWFwb24ocmVzb3VyY2VzLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/drop.ts\n");

/***/ }),

/***/ "./src/inventory.modal.ts":
/*!********************************!*\
  !*** ./src/inventory.modal.ts ***!
  \********************************/
/*! exports provided: InventoryModalScene */
/*! ModuleConcatenation bailout: Module uses injected variables (PIXI) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(PIXI) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InventoryModalScene\", function() { return InventoryModalScene; });\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\n/* harmony import */ var _inventory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inventory */ \"./src/inventory.ts\");\n\n\nclass InventoryModalScene {\n    constructor(controller, hero, npc) {\n        this.container = null;\n        this.background = null;\n        this.selectable = null;\n        this.inventoryView = null;\n        this.controller = controller;\n        this.hero = hero;\n        this.npc = npc;\n    }\n    init() {\n        this.background = new PIXI.Graphics();\n        this.selectable = new _ui__WEBPACK_IMPORTED_MODULE_0__[\"SelectableGrid\"](this.controller.joystick);\n        let controller;\n        if (this.npc) {\n            controller = new _inventory__WEBPACK_IMPORTED_MODULE_1__[\"SellingInventoryActionsController\"](this.hero, this.npc);\n        }\n        else {\n            controller = new _inventory__WEBPACK_IMPORTED_MODULE_1__[\"DefaultInventoryActionsController\"](this.hero.inventory);\n        }\n        this.inventoryView = new _inventory__WEBPACK_IMPORTED_MODULE_1__[\"InventoryView\"](this.hero.inventory, controller, this.selectable, 0);\n        this.inventoryView.position.set(_ui__WEBPACK_IMPORTED_MODULE_0__[\"Sizes\"].uiMargin, _ui__WEBPACK_IMPORTED_MODULE_0__[\"Sizes\"].uiMargin);\n        this.inventoryView.calculateBounds();\n        this.inventoryView.zIndex = 1;\n        const width = this.inventoryView.width + (_ui__WEBPACK_IMPORTED_MODULE_0__[\"Sizes\"].uiMargin << 1);\n        const height = this.inventoryView.height + (_ui__WEBPACK_IMPORTED_MODULE_0__[\"Sizes\"].uiMargin << 1);\n        this.background\n            .beginFill(0x000000)\n            .drawRect(0, 0, width, height)\n            .endFill();\n        this.background.zIndex = 0;\n        this.container = new PIXI.Container();\n        this.container.addChild(this.background, this.inventoryView);\n        this.container.sortChildren();\n        this.container.position.set((this.controller.app.screen.width >> 1) - (width >> 1), (this.controller.app.screen.height >> 1) - (height >> 1));\n        this.controller.stage.addChild(this.container);\n        this.controller.app.ticker.add(this.handleInput, this);\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.controller.app.ticker.remove(this.handleInput, this);\n        (_a = this.container) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.container = null;\n        (_b = this.background) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.background = null;\n        (_c = this.inventoryView) === null || _c === void 0 ? void 0 : _c.destroy();\n        this.inventoryView = null;\n        this.selectable = null;\n    }\n    handleInput() {\n        var _a;\n        const joystick = this.controller.joystick;\n        if (joystick.inventory.once()) {\n            this.controller.closeModal();\n            return;\n        }\n        (_a = this.selectable) === null || _a === void 0 ? void 0 : _a.handleInput();\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! pixi.js */ \"pixi.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW52ZW50b3J5Lm1vZGFsLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ludmVudG9yeS5tb2RhbC50cz84YWZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlbGVjdGFibGVHcmlkLCBTaXplcyB9IGZyb20gXCIuL3VpXCI7XG5pbXBvcnQgeyBEZWZhdWx0SW52ZW50b3J5QWN0aW9uc0NvbnRyb2xsZXIsIEludmVudG9yeVZpZXcsIFNlbGxpbmdJbnZlbnRvcnlBY3Rpb25zQ29udHJvbGxlciB9IGZyb20gXCIuL2ludmVudG9yeVwiO1xuZXhwb3J0IGNsYXNzIEludmVudG9yeU1vZGFsU2NlbmUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIsIGhlcm8sIG5wYykge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW52ZW50b3J5VmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuaGVybyA9IGhlcm87XG4gICAgICAgIHRoaXMubnBjID0gbnBjO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSBuZXcgU2VsZWN0YWJsZUdyaWQodGhpcy5jb250cm9sbGVyLmpveXN0aWNrKTtcbiAgICAgICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgICAgIGlmICh0aGlzLm5wYykge1xuICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBTZWxsaW5nSW52ZW50b3J5QWN0aW9uc0NvbnRyb2xsZXIodGhpcy5oZXJvLCB0aGlzLm5wYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyID0gbmV3IERlZmF1bHRJbnZlbnRvcnlBY3Rpb25zQ29udHJvbGxlcih0aGlzLmhlcm8uaW52ZW50b3J5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludmVudG9yeVZpZXcgPSBuZXcgSW52ZW50b3J5Vmlldyh0aGlzLmhlcm8uaW52ZW50b3J5LCBjb250cm9sbGVyLCB0aGlzLnNlbGVjdGFibGUsIDApO1xuICAgICAgICB0aGlzLmludmVudG9yeVZpZXcucG9zaXRpb24uc2V0KFNpemVzLnVpTWFyZ2luLCBTaXplcy51aU1hcmdpbik7XG4gICAgICAgIHRoaXMuaW52ZW50b3J5Vmlldy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5pbnZlbnRvcnlWaWV3LnpJbmRleCA9IDE7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5pbnZlbnRvcnlWaWV3LndpZHRoICsgKFNpemVzLnVpTWFyZ2luIDw8IDEpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmludmVudG9yeVZpZXcuaGVpZ2h0ICsgKFNpemVzLnVpTWFyZ2luIDw8IDEpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRcbiAgICAgICAgICAgIC5iZWdpbkZpbGwoMHgwMDAwMDApXG4gICAgICAgICAgICAuZHJhd1JlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgICAgIC5lbmRGaWxsKCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC56SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmJhY2tncm91bmQsIHRoaXMuaW52ZW50b3J5Vmlldyk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnNvcnRDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5wb3NpdGlvbi5zZXQoKHRoaXMuY29udHJvbGxlci5hcHAuc2NyZWVuLndpZHRoID4+IDEpIC0gKHdpZHRoID4+IDEpLCAodGhpcy5jb250cm9sbGVyLmFwcC5zY3JlZW4uaGVpZ2h0ID4+IDEpIC0gKGhlaWdodCA+PiAxKSk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hcHAudGlja2VyLmFkZCh0aGlzLmhhbmRsZUlucHV0LCB0aGlzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hcHAudGlja2VyLnJlbW92ZSh0aGlzLmhhbmRsZUlucHV0LCB0aGlzKTtcbiAgICAgICAgKF9hID0gdGhpcy5jb250YWluZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgKF9iID0gdGhpcy5iYWNrZ3JvdW5kKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBudWxsO1xuICAgICAgICAoX2MgPSB0aGlzLmludmVudG9yeVZpZXcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW52ZW50b3J5VmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IG51bGw7XG4gICAgfVxuICAgIGhhbmRsZUlucHV0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGpveXN0aWNrID0gdGhpcy5jb250cm9sbGVyLmpveXN0aWNrO1xuICAgICAgICBpZiAoam95c3RpY2suaW52ZW50b3J5Lm9uY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmNsb3NlTW9kYWwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLnNlbGVjdGFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVJbnB1dCgpO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/inventory.modal.ts\n");

/***/ }),

/***/ "./src/inventory.ts":
/*!**************************!*\
  !*** ./src/inventory.ts ***!
  \**************************/
/*! exports provided: Inventory, EquipmentInventory, BeltInventory, BackpackInventory, InventoryCell, BaseInventoryActionsController, DefaultInventoryActionsController, SellingInventoryActionsController, InventoryView, EquipmentInventoryView, BeltInventoryView, BackpackInventoryView, InventoryCellView, InventoryCellCardView, InventoryCellActionsView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Inventory\", function() { return Inventory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EquipmentInventory\", function() { return EquipmentInventory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BeltInventory\", function() { return BeltInventory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BackpackInventory\", function() { return BackpackInventory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InventoryCell\", function() { return InventoryCell; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseInventoryActionsController\", function() { return BaseInventoryActionsController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultInventoryActionsController\", function() { return DefaultInventoryActionsController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SellingInventoryActionsController\", function() { return SellingInventoryActionsController; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InventoryView\", function() { return InventoryView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EquipmentInventoryView\", function() { return EquipmentInventoryView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BeltInventoryView\", function() { return BeltInventoryView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BackpackInventoryView\", function() { return BackpackInventoryView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InventoryCellView\", function() { return InventoryCellView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InventoryCellCardView\", function() { return InventoryCellCardView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InventoryCellActionsView\", function() { return InventoryCellActionsView; });\n/* harmony import */ var _drop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drop */ \"./src/drop.ts\");\n/* harmony import */ var _observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observable */ \"./src/observable.ts\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nconst CELL_SIZE = 32;\nconst BUTTON_WIDTH = 170;\nconst BUTTON_HEIGHT = 32;\nclass Inventory {\n    constructor(hero) {\n        this._drop = new _observable__WEBPACK_IMPORTED_MODULE_1__[\"EventPublisher\"]();\n        this.equipment = new EquipmentInventory(hero, this._drop);\n        this.belt = new BeltInventory(hero, this._drop);\n        this.backpack = new BackpackInventory(hero, this._drop);\n    }\n    get drop() {\n        return this._drop;\n    }\n    stack(item) {\n        return this.belt.stack(item) || this.backpack.stack(item);\n    }\n    set(item) {\n        return this.belt.set(item) || this.backpack.set(item);\n    }\n    add(item) {\n        return this.stack(item) || this.set(item);\n    }\n}\nclass EquipmentInventory {\n    constructor(hero, drop) {\n        this.weapon = new InventoryCell(hero, 1, (item) => item instanceof _drop__WEBPACK_IMPORTED_MODULE_0__[\"Weapon\"], drop, this);\n    }\n}\nclass BeltInventory {\n    constructor(hero, drop) {\n        this.length = 10;\n        this.cells = [];\n        for (let i = 0; i < 10; i++) {\n            this.cells[i] = new InventoryCell(hero, 3, () => true, drop, this);\n        }\n    }\n    cell(index) {\n        return this.cells[index];\n    }\n    stack(item) {\n        for (let i = 0; i < this.cells.length; i++) {\n            if (this.cells[i].stack(item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    set(item) {\n        for (let i = 0; i < this.cells.length; i++) {\n            if (this.cells[i].set(item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    add(item) {\n        return this.stack(item) || this.set(item);\n    }\n}\nclass BackpackInventory {\n    constructor(hero, drop) {\n        this.width = 10;\n        this.height = 5;\n        this.cells = [];\n        for (let y = 0; y < this.height; y++) {\n            this.cells.push([]);\n            for (let x = 0; x < this.width; x++) {\n                this.cells[y][x] = new InventoryCell(hero, 3, () => true, drop, this);\n            }\n        }\n    }\n    cell(x, y) {\n        return this.cells[y][x];\n    }\n    stack(item) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                if (this.cells[y][x].stack(item)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    set(item) {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                if (this.cells[y][x].set(item)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    add(item) {\n        return this.stack(item) || this.set(item);\n    }\n}\nclass InventoryCell {\n    constructor(hero, maxInStack, predicate, drop, parent) {\n        this._item = new _observable__WEBPACK_IMPORTED_MODULE_1__[\"ObservableVar\"](null);\n        this._count = new _observable__WEBPACK_IMPORTED_MODULE_1__[\"ObservableVar\"](0);\n        this._hero = hero;\n        this._maxInStack = maxInStack;\n        this._predicate = predicate;\n        this._drop = drop;\n        this.parent = parent;\n    }\n    get item() {\n        return this._item;\n    }\n    get count() {\n        return this._count;\n    }\n    supports(item) {\n        return this._predicate(item);\n    }\n    stack(item) {\n        var _a;\n        if (((_a = this._item.get()) === null || _a === void 0 ? void 0 : _a.same(item)) && this._count.get() < this._maxInStack) {\n            this._count.update(c => c + 1);\n            return true;\n        }\n        return false;\n    }\n    ;\n    clear() {\n        if (this._item.get()) {\n            this._item.set(null);\n            this._count.set(0);\n        }\n    }\n    set(item) {\n        if (!this._item.get() && this._predicate(item)) {\n            this._item.set(item);\n            this._count.set(1);\n            return true;\n        }\n        return false;\n    }\n    ;\n    decrease() {\n        this._count.update(c => Math.max(0, c - 1));\n        if (this._count.get() <= 0) {\n            this._item.set(null);\n            this._count.set(0);\n        }\n    }\n    get isEmpty() {\n        return this._item.get() == null;\n    }\n    use() {\n        const item = this._item.get();\n        if (item) {\n            item.use(this, this._hero);\n            return true;\n        }\n        return false;\n    }\n    ;\n    equip() {\n        const item = this._item.get();\n        const weapon = this._hero.inventory.equipment.weapon;\n        if (item && weapon.supports(item)) {\n            const prev = weapon.item.get();\n            weapon.clear();\n            weapon.set(item);\n            this.clear();\n            if (prev) {\n                this.set(prev);\n            }\n        }\n    }\n    toBelt() {\n        const item = this._item.get();\n        while (item && !this.isEmpty) {\n            if (this._hero.inventory.belt.add(item)) {\n                this.decrease();\n            }\n            else {\n                break;\n            }\n        }\n    }\n    toBackpack() {\n        const item = this._item.get();\n        while (item && !this.isEmpty) {\n            if (this._hero.inventory.backpack.add(item)) {\n                this.decrease();\n            }\n            else {\n                break;\n            }\n        }\n    }\n    drop() {\n        const drop = this._item.get();\n        const count = this._count.get();\n        if (drop) {\n            this._item.set(null);\n            this._count.set(0);\n            this._drop.send([drop, count]);\n        }\n    }\n}\nclass BaseInventoryActionsController {\n    constructor(inventory) {\n        this.inventory = inventory;\n    }\n    handle(view, item) {\n        view.removeButtons();\n        if (item) {\n            this.basicButtons(view, item);\n            this.additionalButtons(view, item);\n        }\n    }\n    basicButtons(view, item) {\n        const cell = view.cell;\n        if (cell.parent instanceof BeltInventory || cell.parent instanceof BackpackInventory) {\n            if (this.inventory.equipment.weapon.supports(item)) {\n                view.addButton(\"Equip\", () => cell.equip());\n            }\n            else {\n                view.addButton(\"Use item\", () => cell.use());\n            }\n        }\n        if (!(cell.parent instanceof BeltInventory))\n            view.addButton(\"To belt\", () => cell.toBelt());\n        if (!(cell.parent instanceof BackpackInventory))\n            view.addButton(\"To backpack\", () => cell.toBackpack());\n        view.addButton(\"Drop\", () => cell.drop());\n    }\n}\nclass DefaultInventoryActionsController extends BaseInventoryActionsController {\n    constructor(inventory) {\n        super(inventory);\n    }\n    additionalButtons(_view, _item) {\n    }\n}\nclass SellingInventoryActionsController extends BaseInventoryActionsController {\n    constructor(hero, npc) {\n        super(hero.inventory);\n        this.hero = hero;\n        this.npc = npc;\n    }\n    additionalButtons(view, item) {\n        const price = item.info().price;\n        if (price) {\n            view.addButton('Sell', () => {\n                view.cell.decrease();\n                this.hero.addCoins(price);\n            });\n        }\n    }\n}\nclass InventoryView extends pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Container\"] {\n    constructor(inventory, controller, selectable, selectableOffset) {\n        super();\n        this.selectable = selectable;\n        this.selectableOffset = selectableOffset;\n        const layout = new _ui__WEBPACK_IMPORTED_MODULE_2__[\"Layout\"]();\n        this.equipment = new EquipmentInventoryView(inventory.equipment);\n        this.equipment.position.set(layout.x, layout.y);\n        this.equipment.calculateBounds();\n        layout.offset(0, this.equipment.height);\n        layout.offset(0, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin);\n        selectable.set(selectableOffset, 0, this.equipment.weapon, () => this.show(inventory.equipment.weapon));\n        selectable.merge(selectableOffset, 0, 10, 1);\n        this.belt = new BeltInventoryView(inventory.belt);\n        this.belt.position.set(layout.x, layout.y);\n        this.belt.calculateBounds();\n        layout.offset(0, this.belt.height);\n        layout.offset(0, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin);\n        for (let i = 0; i < this.belt.length; i++) {\n            const cell = inventory.belt.cell(i);\n            this.selectable.set(selectableOffset + i, 1, this.belt.cell(i), () => this.show(cell));\n        }\n        this.backpack = new BackpackInventoryView(inventory.backpack);\n        this.backpack.position.set(layout.x, layout.y);\n        this.backpack.calculateBounds();\n        layout.offset(0, this.backpack.height);\n        layout.offset(0, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin);\n        for (let x = 0; x < inventory.backpack.width; x++) {\n            for (let y = 0; y < inventory.backpack.height; y++) {\n                const cell = inventory.backpack.cell(x, y);\n                this.selectable.set(selectableOffset + x, y + 2, this.backpack.cell(x, y), () => this.show(cell));\n            }\n        }\n        this.actions = new InventoryCellActionsView(this.selectable, this.selectableOffset, controller);\n        this.actions.position.set(layout.x, layout.y);\n        layout.offset(0, BUTTON_HEIGHT);\n        layout.offset(0, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin);\n        layout.offset(0, BUTTON_HEIGHT);\n        const totalHeight = layout.y;\n        layout.reset();\n        layout.offset(this.backpack.width, 0);\n        layout.offset(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin, 0);\n        this.card = new InventoryCellCardView({\n            width: 400,\n            height: totalHeight\n        });\n        this.card.position.set(layout.x, layout.y);\n        this.card.calculateBounds();\n        this.addChild(this.equipment, this.belt, this.backpack, this.card, this.actions);\n    }\n    destroy() {\n        super.destroy();\n        this.equipment.destroy();\n        this.belt.destroy();\n        this.backpack.destroy();\n        this.card.destroy();\n    }\n    show(cell) {\n        this.card.publisher = cell.item;\n        this.actions.cell = cell;\n    }\n}\nclass EquipmentInventoryView extends pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Container\"] {\n    constructor(equipment) {\n        super();\n        this.equipment = equipment;\n        const background = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Graphics\"]()\n            .beginFill(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Colors\"].uiBackground, 0.3)\n            .drawRect(0, 0, CELL_SIZE + (_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder << 1), CELL_SIZE + (_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder << 1))\n            .endFill();\n        super.addChild(background);\n        this.weapon = new InventoryCellView({\n            item: this.equipment.weapon.item,\n            count: new _observable__WEBPACK_IMPORTED_MODULE_1__[\"ObservableVar\"](null)\n        });\n        this.weapon.position.set(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder);\n        super.addChild(this.weapon);\n    }\n}\nclass BeltInventoryView extends pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Container\"] {\n    constructor(inventory) {\n        super();\n        this.inventory = inventory;\n        const background = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Graphics\"]()\n            .beginFill(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Colors\"].uiBackground, 0.3)\n            .drawRect(0, 0, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder + (CELL_SIZE + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder) * inventory.length, CELL_SIZE + (_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder << 1))\n            .endFill();\n        super.addChild(background);\n        this.cells = [];\n        for (let i = 0; i < inventory.length; i++) {\n            const cell = inventory.cell(i);\n            const view = new InventoryCellView({\n                item: cell.item,\n                count: cell.count,\n            });\n            view.position.set(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder + (CELL_SIZE + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder) * i, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder);\n            this.cells.push(view);\n            super.addChild(view);\n        }\n    }\n    get length() {\n        return this.inventory.length;\n    }\n    cell(index) {\n        return this.cells[index];\n    }\n}\nclass BackpackInventoryView extends pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Container\"] {\n    constructor(inventory) {\n        super();\n        const background = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Graphics\"]()\n            .beginFill(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Colors\"].uiBackground, 0.3)\n            .drawRect(0, 0, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder + (CELL_SIZE + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder) * inventory.width, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder + (CELL_SIZE + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder) * inventory.height)\n            .endFill();\n        super.addChild(background);\n        this.cells = [];\n        for (let y = 0; y < inventory.height; y++) {\n            this.cells.push([]);\n            for (let x = 0; x < inventory.width; x++) {\n                const cell = inventory.cell(x, y);\n                const view = new InventoryCellView({\n                    item: cell.item,\n                    count: cell.count,\n                });\n                view.position.set(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder + (CELL_SIZE + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder) * x, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder + (CELL_SIZE + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder) * y);\n                this.cells[y][x] = view;\n                super.addChild(view);\n            }\n        }\n    }\n    cell(x, y) {\n        return this.cells[y][x];\n    }\n}\nclass InventoryCellView extends pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Container\"] {\n    constructor(options) {\n        super();\n        this.sprite = null;\n        this._selected = false;\n        this._item = options.item;\n        this._count = options.count;\n        this._alpha = options.alpha || 0.3;\n        this.background = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Graphics\"]();\n        this.selected = false;\n        this.counter = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"BitmapText\"](\"0\", { font: { name: \"alagard\", size: 16 } });\n        this.counter.anchor = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Point\"](1, 0);\n        this.counter.position.set(CELL_SIZE - _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder, 0);\n        super.addChild(this.background, this.counter);\n        this._item.subscribe(this.updateItem, this);\n        this._count.subscribe(this.updateCounter, this);\n    }\n    destroy() {\n        super.destroy();\n        this._item.unsubscribe(this.updateItem, this);\n        this._count.unsubscribe(this.updateCounter, this);\n    }\n    get selected() {\n        return this._selected;\n    }\n    set selected(selected) {\n        this._selected = selected;\n        this.background\n            .clear()\n            .beginFill(selected ? _ui__WEBPACK_IMPORTED_MODULE_2__[\"Colors\"].uiSelected : _ui__WEBPACK_IMPORTED_MODULE_2__[\"Colors\"].uiNotSelected, this._alpha)\n            .drawRect(0, 0, CELL_SIZE, CELL_SIZE)\n            .endFill();\n    }\n    updateCounter(counter) {\n        if (counter === null || counter === 0) {\n            this.counter.text = \"\";\n        }\n        else {\n            this.counter.text = counter.toString();\n        }\n    }\n    updateItem(item) {\n        var _a;\n        (_a = this.sprite) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.sprite = null;\n        if (item) {\n            this.sprite = item.sprite();\n            const max = CELL_SIZE - (_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder << 1);\n            const scale = max / Math.max(this.sprite.width, this.sprite.height);\n            this.sprite.scale.set(scale, scale);\n            this.sprite.anchor.set(0.5, 0);\n            this.sprite.position.set(CELL_SIZE >> 1, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiBorder);\n            super.addChild(this.sprite);\n        }\n    }\n}\nclass InventoryCellCardView extends pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Container\"] {\n    constructor(options) {\n        super();\n        this._sprite = null;\n        this._publisher = null;\n        this._width = options.width || 400;\n        this._height = options.height || 400;\n        this._sprite_size = 128 + (_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin << 1);\n        const background = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Graphics\"]()\n            .beginFill(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Colors\"].uiBackground, 0.3)\n            .drawRect(0, 0, this._width, this._height)\n            .endFill()\n            .beginFill(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Colors\"].uiNotSelected, 0.3)\n            .drawRect(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin + 32 + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin, this._sprite_size, this._sprite_size)\n            .endFill();\n        this._title = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"BitmapText\"](\"\", { font: { name: \"alagard\", size: 32 } });\n        this._title.anchor = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Point\"](0.5, 0);\n        this._title.position.set(this._width >> 1, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin);\n        this._description = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"BitmapText\"](\"\", { font: { name: \"alagard\", size: 16 } });\n        this._description.position.set(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin + this._sprite_size + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin, _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin + 32 + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin);\n        super.addChild(background, this._title, this._description);\n    }\n    destroy() {\n        var _a;\n        super.destroy();\n        (_a = this._publisher) === null || _a === void 0 ? void 0 : _a.unsubscribe(this.handle, this);\n        this._publisher = null;\n    }\n    set publisher(publisher) {\n        var _a;\n        (_a = this._publisher) === null || _a === void 0 ? void 0 : _a.unsubscribe(this.handle, this);\n        this._publisher = null;\n        this._publisher = publisher;\n        this._publisher.subscribe(this.handle, this);\n    }\n    handle(drop) {\n        var _a;\n        (_a = this._sprite) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._sprite = null;\n        this._title.text = \"\";\n        this._description.text = \"\";\n        if (drop) {\n            const sprite = this._sprite = drop.sprite();\n            super.addChild(sprite);\n            sprite.anchor = new pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Point\"](0.5, 0.5);\n            sprite.position.set(_ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin + (this._sprite_size >> 1), _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin + (this._sprite_size >> 1) + 32 + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin);\n            const s_w = sprite.width;\n            const s_h = sprite.height;\n            const max_size = this._sprite_size - _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin;\n            if (s_w > s_h) {\n                this._sprite.width = max_size;\n                this._sprite.height = (max_size / s_w) * s_h;\n            }\n            else {\n                this._sprite.height = max_size;\n                this._sprite.width = (max_size / s_h) * s_w;\n            }\n            const info = drop.info();\n            this._title.text = info.name;\n            const text = [];\n            if (info.health)\n                text.push(`health: ${info.health}`);\n            if (info.speed)\n                text.push(`speed: ${info.speed * 100}%`);\n            if (info.distance)\n                text.push(`distance: ${info.distance}`);\n            if (info.damage)\n                text.push(`damage: ${info.damage}`);\n            if (info.price)\n                text.push(`price: ${info.price}$`);\n            this._description.text = text.join(\"\\n\");\n        }\n    }\n}\nclass InventoryCellActionsView extends pixi_js__WEBPACK_IMPORTED_MODULE_3__[\"Container\"] {\n    constructor(selectable, selectableOffset, controller) {\n        super();\n        this.buttons = [];\n        this._cell = null;\n        this.selectable = selectable;\n        this.selectableOffset = selectableOffset;\n        this.controller = controller;\n    }\n    destroy() {\n        var _a;\n        super.destroy();\n        (_a = this._cell) === null || _a === void 0 ? void 0 : _a.item.unsubscribe(this.handle, this);\n        this._cell = null;\n        this.removeButtons();\n    }\n    set cell(cell) {\n        var _a;\n        (_a = this._cell) === null || _a === void 0 ? void 0 : _a.item.unsubscribe(this.handle, this);\n        this.removeButtons();\n        this._cell = cell;\n        this._cell.item.subscribe(this.handle, this);\n    }\n    get cell() {\n        return this._cell;\n    }\n    handle(item) {\n        this.controller.handle(this, item);\n    }\n    removeButtons() {\n        for (let [button, x, y] of this.buttons) {\n            this.selectable.unmerge(x, y);\n            this.selectable.remove(x, y);\n            button.destroy();\n        }\n        this.selectable.reset();\n        this.buttons.splice(0, this.buttons.length);\n    }\n    addButton(label, action) {\n        const total = this.buttons.length;\n        const row = total >> 1;\n        const cell = total % 2;\n        const merge_width = 5;\n        const selectableX = this.selectableOffset + (cell * merge_width);\n        const selectableY = 10 + row;\n        const button = new _ui__WEBPACK_IMPORTED_MODULE_2__[\"Button\"]({\n            label: label,\n            width: BUTTON_WIDTH,\n            height: BUTTON_HEIGHT,\n        });\n        button.position.set(cell * (BUTTON_WIDTH + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin), row * (BUTTON_HEIGHT + _ui__WEBPACK_IMPORTED_MODULE_2__[\"Sizes\"].uiMargin));\n        this.buttons.push([button, selectableX, selectableY]);\n        this.selectable.set(selectableX, selectableY, button, action);\n        this.selectable.merge(selectableX, selectableY, merge_width, 1);\n        this.addChild(button);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW52ZW50b3J5LnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2ludmVudG9yeS50cz82YzE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdlYXBvbiB9IGZyb20gXCIuL2Ryb3BcIjtcbmltcG9ydCB7IE9ic2VydmFibGVWYXIsIEV2ZW50UHVibGlzaGVyIH0gZnJvbSBcIi4vb2JzZXJ2YWJsZVwiO1xuaW1wb3J0IHsgQ29sb3JzLCBTaXplcywgTGF5b3V0LCBCdXR0b24gfSBmcm9tIFwiLi91aVwiO1xuaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiO1xuY29uc3QgQ0VMTF9TSVpFID0gMzI7XG5jb25zdCBCVVRUT05fV0lEVEggPSAxNzA7XG5jb25zdCBCVVRUT05fSEVJR0hUID0gMzI7XG5leHBvcnQgY2xhc3MgSW52ZW50b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihoZXJvKSB7XG4gICAgICAgIHRoaXMuX2Ryb3AgPSBuZXcgRXZlbnRQdWJsaXNoZXIoKTtcbiAgICAgICAgdGhpcy5lcXVpcG1lbnQgPSBuZXcgRXF1aXBtZW50SW52ZW50b3J5KGhlcm8sIHRoaXMuX2Ryb3ApO1xuICAgICAgICB0aGlzLmJlbHQgPSBuZXcgQmVsdEludmVudG9yeShoZXJvLCB0aGlzLl9kcm9wKTtcbiAgICAgICAgdGhpcy5iYWNrcGFjayA9IG5ldyBCYWNrcGFja0ludmVudG9yeShoZXJvLCB0aGlzLl9kcm9wKTtcbiAgICB9XG4gICAgZ2V0IGRyb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wO1xuICAgIH1cbiAgICBzdGFjayhpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlbHQuc3RhY2soaXRlbSkgfHwgdGhpcy5iYWNrcGFjay5zdGFjayhpdGVtKTtcbiAgICB9XG4gICAgc2V0KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVsdC5zZXQoaXRlbSkgfHwgdGhpcy5iYWNrcGFjay5zZXQoaXRlbSk7XG4gICAgfVxuICAgIGFkZChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrKGl0ZW0pIHx8IHRoaXMuc2V0KGl0ZW0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFcXVpcG1lbnRJbnZlbnRvcnkge1xuICAgIGNvbnN0cnVjdG9yKGhlcm8sIGRyb3ApIHtcbiAgICAgICAgdGhpcy53ZWFwb24gPSBuZXcgSW52ZW50b3J5Q2VsbChoZXJvLCAxLCAoaXRlbSkgPT4gaXRlbSBpbnN0YW5jZW9mIFdlYXBvbiwgZHJvcCwgdGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJlbHRJbnZlbnRvcnkge1xuICAgIGNvbnN0cnVjdG9yKGhlcm8sIGRyb3ApIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxMDtcbiAgICAgICAgdGhpcy5jZWxscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbHNbaV0gPSBuZXcgSW52ZW50b3J5Q2VsbChoZXJvLCAzLCAoKSA9PiB0cnVlLCBkcm9wLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjZWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxzW2luZGV4XTtcbiAgICB9XG4gICAgc3RhY2soaXRlbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbGxzW2ldLnN0YWNrKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZXQoaXRlbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbGxzW2ldLnNldChpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2soaXRlbSkgfHwgdGhpcy5zZXQoaXRlbSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJhY2twYWNrSW52ZW50b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihoZXJvLCBkcm9wKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSAxMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSA1O1xuICAgICAgICB0aGlzLmNlbGxzID0gW107XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdGhpcy5jZWxscy5wdXNoKFtdKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsc1t5XVt4XSA9IG5ldyBJbnZlbnRvcnlDZWxsKGhlcm8sIDMsICgpID0+IHRydWUsIGRyb3AsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNlbGwoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsc1t5XVt4XTtcbiAgICB9XG4gICAgc3RhY2soaXRlbSkge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2VsbHNbeV1beF0uc3RhY2soaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2V0KGl0ZW0pIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNlbGxzW3ldW3hdLnNldChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhZGQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFjayhpdGVtKSB8fCB0aGlzLnNldChpdGVtKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW52ZW50b3J5Q2VsbCB7XG4gICAgY29uc3RydWN0b3IoaGVybywgbWF4SW5TdGFjaywgcHJlZGljYXRlLCBkcm9wLCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5faXRlbSA9IG5ldyBPYnNlcnZhYmxlVmFyKG51bGwpO1xuICAgICAgICB0aGlzLl9jb3VudCA9IG5ldyBPYnNlcnZhYmxlVmFyKDApO1xuICAgICAgICB0aGlzLl9oZXJvID0gaGVybztcbiAgICAgICAgdGhpcy5fbWF4SW5TdGFjayA9IG1heEluU3RhY2s7XG4gICAgICAgIHRoaXMuX3ByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5fZHJvcCA9IGRyb3A7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBnZXQgaXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW07XG4gICAgfVxuICAgIGdldCBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50O1xuICAgIH1cbiAgICBzdXBwb3J0cyhpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVkaWNhdGUoaXRlbSk7XG4gICAgfVxuICAgIHN0YWNrKGl0ZW0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2l0ZW0uZ2V0KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zYW1lKGl0ZW0pKSAmJiB0aGlzLl9jb3VudC5nZXQoKSA8IHRoaXMuX21heEluU3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50LnVwZGF0ZShjID0+IGMgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIGNsZWFyKCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbS5nZXQoKSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbS5zZXQobnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9jb3VudC5zZXQoMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KGl0ZW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pdGVtLmdldCgpICYmIHRoaXMuX3ByZWRpY2F0ZShpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5faXRlbS5zZXQoaXRlbSk7XG4gICAgICAgICAgICB0aGlzLl9jb3VudC5zZXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICBkZWNyZWFzZSgpIHtcbiAgICAgICAgdGhpcy5fY291bnQudXBkYXRlKGMgPT4gTWF0aC5tYXgoMCwgYyAtIDEpKTtcbiAgICAgICAgaWYgKHRoaXMuX2NvdW50LmdldCgpIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW0uc2V0KG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fY291bnQuc2V0KDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbS5nZXQoKSA9PSBudWxsO1xuICAgIH1cbiAgICB1c2UoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtLmdldCgpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS51c2UodGhpcywgdGhpcy5faGVybyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICBlcXVpcCgpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW0uZ2V0KCk7XG4gICAgICAgIGNvbnN0IHdlYXBvbiA9IHRoaXMuX2hlcm8uaW52ZW50b3J5LmVxdWlwbWVudC53ZWFwb247XG4gICAgICAgIGlmIChpdGVtICYmIHdlYXBvbi5zdXBwb3J0cyhpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IHdlYXBvbi5pdGVtLmdldCgpO1xuICAgICAgICAgICAgd2VhcG9uLmNsZWFyKCk7XG4gICAgICAgICAgICB3ZWFwb24uc2V0KGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChwcmV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0JlbHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtLmdldCgpO1xuICAgICAgICB3aGlsZSAoaXRlbSAmJiAhdGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGVyby5pbnZlbnRvcnkuYmVsdC5hZGQoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY3JlYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0JhY2twYWNrKCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbS5nZXQoKTtcbiAgICAgICAgd2hpbGUgKGl0ZW0gJiYgIXRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hlcm8uaW52ZW50b3J5LmJhY2twYWNrLmFkZChpdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjcmVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRyb3AoKSB7XG4gICAgICAgIGNvbnN0IGRyb3AgPSB0aGlzLl9pdGVtLmdldCgpO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuX2NvdW50LmdldCgpO1xuICAgICAgICBpZiAoZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5faXRlbS5zZXQobnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9jb3VudC5zZXQoMCk7XG4gICAgICAgICAgICB0aGlzLl9kcm9wLnNlbmQoW2Ryb3AsIGNvdW50XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmFzZUludmVudG9yeUFjdGlvbnNDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbnZlbnRvcnkpIHtcbiAgICAgICAgdGhpcy5pbnZlbnRvcnkgPSBpbnZlbnRvcnk7XG4gICAgfVxuICAgIGhhbmRsZSh2aWV3LCBpdGVtKSB7XG4gICAgICAgIHZpZXcucmVtb3ZlQnV0dG9ucygpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5iYXNpY0J1dHRvbnModmlldywgaXRlbSk7XG4gICAgICAgICAgICB0aGlzLmFkZGl0aW9uYWxCdXR0b25zKHZpZXcsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJhc2ljQnV0dG9ucyh2aWV3LCBpdGVtKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB2aWV3LmNlbGw7XG4gICAgICAgIGlmIChjZWxsLnBhcmVudCBpbnN0YW5jZW9mIEJlbHRJbnZlbnRvcnkgfHwgY2VsbC5wYXJlbnQgaW5zdGFuY2VvZiBCYWNrcGFja0ludmVudG9yeSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW52ZW50b3J5LmVxdWlwbWVudC53ZWFwb24uc3VwcG9ydHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICB2aWV3LmFkZEJ1dHRvbihcIkVxdWlwXCIsICgpID0+IGNlbGwuZXF1aXAoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2aWV3LmFkZEJ1dHRvbihcIlVzZSBpdGVtXCIsICgpID0+IGNlbGwudXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKGNlbGwucGFyZW50IGluc3RhbmNlb2YgQmVsdEludmVudG9yeSkpXG4gICAgICAgICAgICB2aWV3LmFkZEJ1dHRvbihcIlRvIGJlbHRcIiwgKCkgPT4gY2VsbC50b0JlbHQoKSk7XG4gICAgICAgIGlmICghKGNlbGwucGFyZW50IGluc3RhbmNlb2YgQmFja3BhY2tJbnZlbnRvcnkpKVxuICAgICAgICAgICAgdmlldy5hZGRCdXR0b24oXCJUbyBiYWNrcGFja1wiLCAoKSA9PiBjZWxsLnRvQmFja3BhY2soKSk7XG4gICAgICAgIHZpZXcuYWRkQnV0dG9uKFwiRHJvcFwiLCAoKSA9PiBjZWxsLmRyb3AoKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERlZmF1bHRJbnZlbnRvcnlBY3Rpb25zQ29udHJvbGxlciBleHRlbmRzIEJhc2VJbnZlbnRvcnlBY3Rpb25zQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoaW52ZW50b3J5KSB7XG4gICAgICAgIHN1cGVyKGludmVudG9yeSk7XG4gICAgfVxuICAgIGFkZGl0aW9uYWxCdXR0b25zKF92aWV3LCBfaXRlbSkge1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTZWxsaW5nSW52ZW50b3J5QWN0aW9uc0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlSW52ZW50b3J5QWN0aW9uc0NvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKGhlcm8sIG5wYykge1xuICAgICAgICBzdXBlcihoZXJvLmludmVudG9yeSk7XG4gICAgICAgIHRoaXMuaGVybyA9IGhlcm87XG4gICAgICAgIHRoaXMubnBjID0gbnBjO1xuICAgIH1cbiAgICBhZGRpdGlvbmFsQnV0dG9ucyh2aWV3LCBpdGVtKSB7XG4gICAgICAgIGNvbnN0IHByaWNlID0gaXRlbS5pbmZvKCkucHJpY2U7XG4gICAgICAgIGlmIChwcmljZSkge1xuICAgICAgICAgICAgdmlldy5hZGRCdXR0b24oJ1NlbGwnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmlldy5jZWxsLmRlY3JlYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZXJvLmFkZENvaW5zKHByaWNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmVudG9yeVZpZXcgZXh0ZW5kcyBQSVhJLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoaW52ZW50b3J5LCBjb250cm9sbGVyLCBzZWxlY3RhYmxlLCBzZWxlY3RhYmxlT2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGU7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZU9mZnNldCA9IHNlbGVjdGFibGVPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IG5ldyBMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5lcXVpcG1lbnQgPSBuZXcgRXF1aXBtZW50SW52ZW50b3J5VmlldyhpbnZlbnRvcnkuZXF1aXBtZW50KTtcbiAgICAgICAgdGhpcy5lcXVpcG1lbnQucG9zaXRpb24uc2V0KGxheW91dC54LCBsYXlvdXQueSk7XG4gICAgICAgIHRoaXMuZXF1aXBtZW50LmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KDAsIHRoaXMuZXF1aXBtZW50LmhlaWdodCk7XG4gICAgICAgIGxheW91dC5vZmZzZXQoMCwgU2l6ZXMudWlNYXJnaW4pO1xuICAgICAgICBzZWxlY3RhYmxlLnNldChzZWxlY3RhYmxlT2Zmc2V0LCAwLCB0aGlzLmVxdWlwbWVudC53ZWFwb24sICgpID0+IHRoaXMuc2hvdyhpbnZlbnRvcnkuZXF1aXBtZW50LndlYXBvbikpO1xuICAgICAgICBzZWxlY3RhYmxlLm1lcmdlKHNlbGVjdGFibGVPZmZzZXQsIDAsIDEwLCAxKTtcbiAgICAgICAgdGhpcy5iZWx0ID0gbmV3IEJlbHRJbnZlbnRvcnlWaWV3KGludmVudG9yeS5iZWx0KTtcbiAgICAgICAgdGhpcy5iZWx0LnBvc2l0aW9uLnNldChsYXlvdXQueCwgbGF5b3V0LnkpO1xuICAgICAgICB0aGlzLmJlbHQuY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICAgIGxheW91dC5vZmZzZXQoMCwgdGhpcy5iZWx0LmhlaWdodCk7XG4gICAgICAgIGxheW91dC5vZmZzZXQoMCwgU2l6ZXMudWlNYXJnaW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmVsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGludmVudG9yeS5iZWx0LmNlbGwoaSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGFibGUuc2V0KHNlbGVjdGFibGVPZmZzZXQgKyBpLCAxLCB0aGlzLmJlbHQuY2VsbChpKSwgKCkgPT4gdGhpcy5zaG93KGNlbGwpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhY2twYWNrID0gbmV3IEJhY2twYWNrSW52ZW50b3J5VmlldyhpbnZlbnRvcnkuYmFja3BhY2spO1xuICAgICAgICB0aGlzLmJhY2twYWNrLnBvc2l0aW9uLnNldChsYXlvdXQueCwgbGF5b3V0LnkpO1xuICAgICAgICB0aGlzLmJhY2twYWNrLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KDAsIHRoaXMuYmFja3BhY2suaGVpZ2h0KTtcbiAgICAgICAgbGF5b3V0Lm9mZnNldCgwLCBTaXplcy51aU1hcmdpbik7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgaW52ZW50b3J5LmJhY2twYWNrLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaW52ZW50b3J5LmJhY2twYWNrLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGludmVudG9yeS5iYWNrcGFjay5jZWxsKHgsIHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0YWJsZS5zZXQoc2VsZWN0YWJsZU9mZnNldCArIHgsIHkgKyAyLCB0aGlzLmJhY2twYWNrLmNlbGwoeCwgeSksICgpID0+IHRoaXMuc2hvdyhjZWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zID0gbmV3IEludmVudG9yeUNlbGxBY3Rpb25zVmlldyh0aGlzLnNlbGVjdGFibGUsIHRoaXMuc2VsZWN0YWJsZU9mZnNldCwgY29udHJvbGxlcik7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5wb3NpdGlvbi5zZXQobGF5b3V0LngsIGxheW91dC55KTtcbiAgICAgICAgbGF5b3V0Lm9mZnNldCgwLCBCVVRUT05fSEVJR0hUKTtcbiAgICAgICAgbGF5b3V0Lm9mZnNldCgwLCBTaXplcy51aU1hcmdpbik7XG4gICAgICAgIGxheW91dC5vZmZzZXQoMCwgQlVUVE9OX0hFSUdIVCk7XG4gICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gbGF5b3V0Lnk7XG4gICAgICAgIGxheW91dC5yZXNldCgpO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KHRoaXMuYmFja3BhY2sud2lkdGgsIDApO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KFNpemVzLnVpTWFyZ2luLCAwKTtcbiAgICAgICAgdGhpcy5jYXJkID0gbmV3IEludmVudG9yeUNlbGxDYXJkVmlldyh7XG4gICAgICAgICAgICB3aWR0aDogNDAwLFxuICAgICAgICAgICAgaGVpZ2h0OiB0b3RhbEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYXJkLnBvc2l0aW9uLnNldChsYXlvdXQueCwgbGF5b3V0LnkpO1xuICAgICAgICB0aGlzLmNhcmQuY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5lcXVpcG1lbnQsIHRoaXMuYmVsdCwgdGhpcy5iYWNrcGFjaywgdGhpcy5jYXJkLCB0aGlzLmFjdGlvbnMpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZXF1aXBtZW50LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5iZWx0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5iYWNrcGFjay5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY2FyZC5kZXN0cm95KCk7XG4gICAgfVxuICAgIHNob3coY2VsbCkge1xuICAgICAgICB0aGlzLmNhcmQucHVibGlzaGVyID0gY2VsbC5pdGVtO1xuICAgICAgICB0aGlzLmFjdGlvbnMuY2VsbCA9IGNlbGw7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEVxdWlwbWVudEludmVudG9yeVZpZXcgZXh0ZW5kcyBQSVhJLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoZXF1aXBtZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXF1aXBtZW50ID0gZXF1aXBtZW50O1xuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFBJWEkuR3JhcGhpY3MoKVxuICAgICAgICAgICAgLmJlZ2luRmlsbChDb2xvcnMudWlCYWNrZ3JvdW5kLCAwLjMpXG4gICAgICAgICAgICAuZHJhd1JlY3QoMCwgMCwgQ0VMTF9TSVpFICsgKFNpemVzLnVpQm9yZGVyIDw8IDEpLCBDRUxMX1NJWkUgKyAoU2l6ZXMudWlCb3JkZXIgPDwgMSkpXG4gICAgICAgICAgICAuZW5kRmlsbCgpO1xuICAgICAgICBzdXBlci5hZGRDaGlsZChiYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy53ZWFwb24gPSBuZXcgSW52ZW50b3J5Q2VsbFZpZXcoe1xuICAgICAgICAgICAgaXRlbTogdGhpcy5lcXVpcG1lbnQud2VhcG9uLml0ZW0sXG4gICAgICAgICAgICBjb3VudDogbmV3IE9ic2VydmFibGVWYXIobnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud2VhcG9uLnBvc2l0aW9uLnNldChTaXplcy51aUJvcmRlciwgU2l6ZXMudWlCb3JkZXIpO1xuICAgICAgICBzdXBlci5hZGRDaGlsZCh0aGlzLndlYXBvbik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJlbHRJbnZlbnRvcnlWaWV3IGV4dGVuZHMgUElYSS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGludmVudG9yeSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmludmVudG9yeSA9IGludmVudG9yeTtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IG5ldyBQSVhJLkdyYXBoaWNzKClcbiAgICAgICAgICAgIC5iZWdpbkZpbGwoQ29sb3JzLnVpQmFja2dyb3VuZCwgMC4zKVxuICAgICAgICAgICAgLmRyYXdSZWN0KDAsIDAsIFNpemVzLnVpQm9yZGVyICsgKENFTExfU0laRSArIFNpemVzLnVpQm9yZGVyKSAqIGludmVudG9yeS5sZW5ndGgsIENFTExfU0laRSArIChTaXplcy51aUJvcmRlciA8PCAxKSlcbiAgICAgICAgICAgIC5lbmRGaWxsKCk7XG4gICAgICAgIHN1cGVyLmFkZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgICB0aGlzLmNlbGxzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW52ZW50b3J5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gaW52ZW50b3J5LmNlbGwoaSk7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IEludmVudG9yeUNlbGxWaWV3KHtcbiAgICAgICAgICAgICAgICBpdGVtOiBjZWxsLml0ZW0sXG4gICAgICAgICAgICAgICAgY291bnQ6IGNlbGwuY291bnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZpZXcucG9zaXRpb24uc2V0KFNpemVzLnVpQm9yZGVyICsgKENFTExfU0laRSArIFNpemVzLnVpQm9yZGVyKSAqIGksIFNpemVzLnVpQm9yZGVyKTtcbiAgICAgICAgICAgIHRoaXMuY2VsbHMucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIHN1cGVyLmFkZENoaWxkKHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmVudG9yeS5sZW5ndGg7XG4gICAgfVxuICAgIGNlbGwoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbHNbaW5kZXhdO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCYWNrcGFja0ludmVudG9yeVZpZXcgZXh0ZW5kcyBQSVhJLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoaW52ZW50b3J5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSBuZXcgUElYSS5HcmFwaGljcygpXG4gICAgICAgICAgICAuYmVnaW5GaWxsKENvbG9ycy51aUJhY2tncm91bmQsIDAuMylcbiAgICAgICAgICAgIC5kcmF3UmVjdCgwLCAwLCBTaXplcy51aUJvcmRlciArIChDRUxMX1NJWkUgKyBTaXplcy51aUJvcmRlcikgKiBpbnZlbnRvcnkud2lkdGgsIFNpemVzLnVpQm9yZGVyICsgKENFTExfU0laRSArIFNpemVzLnVpQm9yZGVyKSAqIGludmVudG9yeS5oZWlnaHQpXG4gICAgICAgICAgICAuZW5kRmlsbCgpO1xuICAgICAgICBzdXBlci5hZGRDaGlsZChiYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy5jZWxscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGludmVudG9yeS5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdGhpcy5jZWxscy5wdXNoKFtdKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgaW52ZW50b3J5LndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gaW52ZW50b3J5LmNlbGwoeCwgeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBJbnZlbnRvcnlDZWxsVmlldyh7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGNlbGwuaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNlbGwuY291bnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmlldy5wb3NpdGlvbi5zZXQoU2l6ZXMudWlCb3JkZXIgKyAoQ0VMTF9TSVpFICsgU2l6ZXMudWlCb3JkZXIpICogeCwgU2l6ZXMudWlCb3JkZXIgKyAoQ0VMTF9TSVpFICsgU2l6ZXMudWlCb3JkZXIpICogeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsc1t5XVt4XSA9IHZpZXc7XG4gICAgICAgICAgICAgICAgc3VwZXIuYWRkQ2hpbGQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2VsbCh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxzW3ldW3hdO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnZlbnRvcnlDZWxsVmlldyBleHRlbmRzIFBJWEkuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3ByaXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXRlbSA9IG9wdGlvbnMuaXRlbTtcbiAgICAgICAgdGhpcy5fY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgICAgICB0aGlzLl9hbHBoYSA9IG9wdGlvbnMuYWxwaGEgfHwgMC4zO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY291bnRlciA9IG5ldyBQSVhJLkJpdG1hcFRleHQoXCIwXCIsIHsgZm9udDogeyBuYW1lOiBcImFsYWdhcmRcIiwgc2l6ZTogMTYgfSB9KTtcbiAgICAgICAgdGhpcy5jb3VudGVyLmFuY2hvciA9IG5ldyBQSVhJLlBvaW50KDEsIDApO1xuICAgICAgICB0aGlzLmNvdW50ZXIucG9zaXRpb24uc2V0KENFTExfU0laRSAtIFNpemVzLnVpQm9yZGVyLCAwKTtcbiAgICAgICAgc3VwZXIuYWRkQ2hpbGQodGhpcy5iYWNrZ3JvdW5kLCB0aGlzLmNvdW50ZXIpO1xuICAgICAgICB0aGlzLl9pdGVtLnN1YnNjcmliZSh0aGlzLnVwZGF0ZUl0ZW0sIHRoaXMpO1xuICAgICAgICB0aGlzLl9jb3VudC5zdWJzY3JpYmUodGhpcy51cGRhdGVDb3VudGVyLCB0aGlzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9pdGVtLnVuc3Vic2NyaWJlKHRoaXMudXBkYXRlSXRlbSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2NvdW50LnVuc3Vic2NyaWJlKHRoaXMudXBkYXRlQ291bnRlciwgdGhpcyk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kXG4gICAgICAgICAgICAuY2xlYXIoKVxuICAgICAgICAgICAgLmJlZ2luRmlsbChzZWxlY3RlZCA/IENvbG9ycy51aVNlbGVjdGVkIDogQ29sb3JzLnVpTm90U2VsZWN0ZWQsIHRoaXMuX2FscGhhKVxuICAgICAgICAgICAgLmRyYXdSZWN0KDAsIDAsIENFTExfU0laRSwgQ0VMTF9TSVpFKVxuICAgICAgICAgICAgLmVuZEZpbGwoKTtcbiAgICB9XG4gICAgdXBkYXRlQ291bnRlcihjb3VudGVyKSB7XG4gICAgICAgIGlmIChjb3VudGVyID09PSBudWxsIHx8IGNvdW50ZXIgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY291bnRlci50ZXh0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY291bnRlci50ZXh0ID0gY291bnRlci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUl0ZW0oaXRlbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuc3ByaXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnNwcml0ZSA9IG51bGw7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IGl0ZW0uc3ByaXRlKCk7XG4gICAgICAgICAgICBjb25zdCBtYXggPSBDRUxMX1NJWkUgLSAoU2l6ZXMudWlCb3JkZXIgPDwgMSk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IG1heCAvIE1hdGgubWF4KHRoaXMuc3ByaXRlLndpZHRoLCB0aGlzLnNwcml0ZS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc2NhbGUuc2V0KHNjYWxlLCBzY2FsZSk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5hbmNob3Iuc2V0KDAuNSwgMCk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5wb3NpdGlvbi5zZXQoQ0VMTF9TSVpFID4+IDEsIFNpemVzLnVpQm9yZGVyKTtcbiAgICAgICAgICAgIHN1cGVyLmFkZENoaWxkKHRoaXMuc3ByaXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnZlbnRvcnlDZWxsQ2FyZFZpZXcgZXh0ZW5kcyBQSVhJLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9zcHJpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9wdWJsaXNoZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl93aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgNDAwO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCA0MDA7XG4gICAgICAgIHRoaXMuX3Nwcml0ZV9zaXplID0gMTI4ICsgKFNpemVzLnVpTWFyZ2luIDw8IDEpO1xuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFBJWEkuR3JhcGhpY3MoKVxuICAgICAgICAgICAgLmJlZ2luRmlsbChDb2xvcnMudWlCYWNrZ3JvdW5kLCAwLjMpXG4gICAgICAgICAgICAuZHJhd1JlY3QoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodClcbiAgICAgICAgICAgIC5lbmRGaWxsKClcbiAgICAgICAgICAgIC5iZWdpbkZpbGwoQ29sb3JzLnVpTm90U2VsZWN0ZWQsIDAuMylcbiAgICAgICAgICAgIC5kcmF3UmVjdChTaXplcy51aU1hcmdpbiwgU2l6ZXMudWlNYXJnaW4gKyAzMiArIFNpemVzLnVpTWFyZ2luLCB0aGlzLl9zcHJpdGVfc2l6ZSwgdGhpcy5fc3ByaXRlX3NpemUpXG4gICAgICAgICAgICAuZW5kRmlsbCgpO1xuICAgICAgICB0aGlzLl90aXRsZSA9IG5ldyBQSVhJLkJpdG1hcFRleHQoXCJcIiwgeyBmb250OiB7IG5hbWU6IFwiYWxhZ2FyZFwiLCBzaXplOiAzMiB9IH0pO1xuICAgICAgICB0aGlzLl90aXRsZS5hbmNob3IgPSBuZXcgUElYSS5Qb2ludCgwLjUsIDApO1xuICAgICAgICB0aGlzLl90aXRsZS5wb3NpdGlvbi5zZXQodGhpcy5fd2lkdGggPj4gMSwgU2l6ZXMudWlNYXJnaW4pO1xuICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbiA9IG5ldyBQSVhJLkJpdG1hcFRleHQoXCJcIiwgeyBmb250OiB7IG5hbWU6IFwiYWxhZ2FyZFwiLCBzaXplOiAxNiB9IH0pO1xuICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbi5wb3NpdGlvbi5zZXQoU2l6ZXMudWlNYXJnaW4gKyB0aGlzLl9zcHJpdGVfc2l6ZSArIFNpemVzLnVpTWFyZ2luLCBTaXplcy51aU1hcmdpbiArIDMyICsgU2l6ZXMudWlNYXJnaW4pO1xuICAgICAgICBzdXBlci5hZGRDaGlsZChiYWNrZ3JvdW5kLCB0aGlzLl90aXRsZSwgdGhpcy5fZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgKF9hID0gdGhpcy5fcHVibGlzaGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5zdWJzY3JpYmUodGhpcy5oYW5kbGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9wdWJsaXNoZXIgPSBudWxsO1xuICAgIH1cbiAgICBzZXQgcHVibGlzaGVyKHB1Ymxpc2hlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuX3B1Ymxpc2hlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVuc3Vic2NyaWJlKHRoaXMuaGFuZGxlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcHVibGlzaGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHVibGlzaGVyID0gcHVibGlzaGVyO1xuICAgICAgICB0aGlzLl9wdWJsaXNoZXIuc3Vic2NyaWJlKHRoaXMuaGFuZGxlLCB0aGlzKTtcbiAgICB9XG4gICAgaGFuZGxlKGRyb3ApIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLl9zcHJpdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3Nwcml0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpdGxlLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbi50ZXh0ID0gXCJcIjtcbiAgICAgICAgaWYgKGRyb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IHNwcml0ZSA9IHRoaXMuX3Nwcml0ZSA9IGRyb3Auc3ByaXRlKCk7XG4gICAgICAgICAgICBzdXBlci5hZGRDaGlsZChzcHJpdGUpO1xuICAgICAgICAgICAgc3ByaXRlLmFuY2hvciA9IG5ldyBQSVhJLlBvaW50KDAuNSwgMC41KTtcbiAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoU2l6ZXMudWlNYXJnaW4gKyAodGhpcy5fc3ByaXRlX3NpemUgPj4gMSksIFNpemVzLnVpTWFyZ2luICsgKHRoaXMuX3Nwcml0ZV9zaXplID4+IDEpICsgMzIgKyBTaXplcy51aU1hcmdpbik7XG4gICAgICAgICAgICBjb25zdCBzX3cgPSBzcHJpdGUud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBzX2ggPSBzcHJpdGUuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbWF4X3NpemUgPSB0aGlzLl9zcHJpdGVfc2l6ZSAtIFNpemVzLnVpTWFyZ2luO1xuICAgICAgICAgICAgaWYgKHNfdyA+IHNfaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS53aWR0aCA9IG1heF9zaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS5oZWlnaHQgPSAobWF4X3NpemUgLyBzX3cpICogc19oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlLmhlaWdodCA9IG1heF9zaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS53aWR0aCA9IChtYXhfc2l6ZSAvIHNfaCkgKiBzX3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gZHJvcC5pbmZvKCk7XG4gICAgICAgICAgICB0aGlzLl90aXRsZS50ZXh0ID0gaW5mby5uYW1lO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IFtdO1xuICAgICAgICAgICAgaWYgKGluZm8uaGVhbHRoKVxuICAgICAgICAgICAgICAgIHRleHQucHVzaChgaGVhbHRoOiAke2luZm8uaGVhbHRofWApO1xuICAgICAgICAgICAgaWYgKGluZm8uc3BlZWQpXG4gICAgICAgICAgICAgICAgdGV4dC5wdXNoKGBzcGVlZDogJHtpbmZvLnNwZWVkICogMTAwfSVgKTtcbiAgICAgICAgICAgIGlmIChpbmZvLmRpc3RhbmNlKVxuICAgICAgICAgICAgICAgIHRleHQucHVzaChgZGlzdGFuY2U6ICR7aW5mby5kaXN0YW5jZX1gKTtcbiAgICAgICAgICAgIGlmIChpbmZvLmRhbWFnZSlcbiAgICAgICAgICAgICAgICB0ZXh0LnB1c2goYGRhbWFnZTogJHtpbmZvLmRhbWFnZX1gKTtcbiAgICAgICAgICAgIGlmIChpbmZvLnByaWNlKVxuICAgICAgICAgICAgICAgIHRleHQucHVzaChgcHJpY2U6ICR7aW5mby5wcmljZX0kYCk7XG4gICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbi50ZXh0ID0gdGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEludmVudG9yeUNlbGxBY3Rpb25zVmlldyBleHRlbmRzIFBJWEkuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3RhYmxlLCBzZWxlY3RhYmxlT2Zmc2V0LCBjb250cm9sbGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYnV0dG9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9jZWxsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gc2VsZWN0YWJsZTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlT2Zmc2V0ID0gc2VsZWN0YWJsZU9mZnNldDtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIChfYSA9IHRoaXMuX2NlbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pdGVtLnVuc3Vic2NyaWJlKHRoaXMuaGFuZGxlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fY2VsbCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVtb3ZlQnV0dG9ucygpO1xuICAgIH1cbiAgICBzZXQgY2VsbChjZWxsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fY2VsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLml0ZW0udW5zdWJzY3JpYmUodGhpcy5oYW5kbGUsIHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW92ZUJ1dHRvbnMoKTtcbiAgICAgICAgdGhpcy5fY2VsbCA9IGNlbGw7XG4gICAgICAgIHRoaXMuX2NlbGwuaXRlbS5zdWJzY3JpYmUodGhpcy5oYW5kbGUsIHRoaXMpO1xuICAgIH1cbiAgICBnZXQgY2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbGw7XG4gICAgfVxuICAgIGhhbmRsZShpdGVtKSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5oYW5kbGUodGhpcywgaXRlbSk7XG4gICAgfVxuICAgIHJlbW92ZUJ1dHRvbnMoKSB7XG4gICAgICAgIGZvciAobGV0IFtidXR0b24sIHgsIHldIG9mIHRoaXMuYnV0dG9ucykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RhYmxlLnVubWVyZ2UoeCwgeSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGFibGUucmVtb3ZlKHgsIHkpO1xuICAgICAgICAgICAgYnV0dG9uLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGFibGUucmVzZXQoKTtcbiAgICAgICAgdGhpcy5idXR0b25zLnNwbGljZSgwLCB0aGlzLmJ1dHRvbnMubGVuZ3RoKTtcbiAgICB9XG4gICAgYWRkQnV0dG9uKGxhYmVsLCBhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgdG90YWwgPSB0aGlzLmJ1dHRvbnMubGVuZ3RoO1xuICAgICAgICBjb25zdCByb3cgPSB0b3RhbCA+PiAxO1xuICAgICAgICBjb25zdCBjZWxsID0gdG90YWwgJSAyO1xuICAgICAgICBjb25zdCBtZXJnZV93aWR0aCA9IDU7XG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGVYID0gdGhpcy5zZWxlY3RhYmxlT2Zmc2V0ICsgKGNlbGwgKiBtZXJnZV93aWR0aCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGVZID0gMTAgKyByb3c7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IG5ldyBCdXR0b24oe1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgd2lkdGg6IEJVVFRPTl9XSURUSCxcbiAgICAgICAgICAgIGhlaWdodDogQlVUVE9OX0hFSUdIVCxcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1dHRvbi5wb3NpdGlvbi5zZXQoY2VsbCAqIChCVVRUT05fV0lEVEggKyBTaXplcy51aU1hcmdpbiksIHJvdyAqIChCVVRUT05fSEVJR0hUICsgU2l6ZXMudWlNYXJnaW4pKTtcbiAgICAgICAgdGhpcy5idXR0b25zLnB1c2goW2J1dHRvbiwgc2VsZWN0YWJsZVgsIHNlbGVjdGFibGVZXSk7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZS5zZXQoc2VsZWN0YWJsZVgsIHNlbGVjdGFibGVZLCBidXR0b24sIGFjdGlvbik7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZS5tZXJnZShzZWxlY3RhYmxlWCwgc2VsZWN0YWJsZVksIG1lcmdlX3dpZHRoLCAxKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChidXR0b24pO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/inventory.ts\n");

/***/ }),

/***/ "./src/observable.ts":
/*!***************************!*\
  !*** ./src/observable.ts ***!
  \***************************/
/*! exports provided: ObservableVar, EventPublisher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ObservableVar\", function() { return ObservableVar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventPublisher\", function() { return EventPublisher; });\nclass ObservableVar {\n    constructor(value) {\n        this.listeners = [];\n        this.value = value;\n    }\n    set(value) {\n        this.value = value;\n        for (let i = this.listeners.length - 1; i >= 0; i--) {\n            let listener = this.listeners[i];\n            if (listener.gc) {\n                this.listeners.splice(i, 1);\n            }\n            else {\n                listener.send(this.value);\n            }\n        }\n    }\n    update(f) {\n        this.set(f(this.value));\n    }\n    get() {\n        return this.value;\n    }\n    subscribe(callback, context) {\n        const listener = new Listener(callback, context);\n        this.listeners.push(listener);\n        listener.send(this.value);\n    }\n    unsubscribe(callback, context) {\n        var _a;\n        (_a = this.listeners.find(l => l.matches(callback, context))) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n}\nclass EventPublisher {\n    constructor() {\n        this.listeners = [];\n    }\n    send(value) {\n        for (let i = this.listeners.length - 1; i >= 0; i--) {\n            let listener = this.listeners[i];\n            if (listener.gc) {\n                this.listeners.splice(i, 1);\n            }\n            else {\n                listener.send(value);\n            }\n        }\n    }\n    subscribe(callback, context) {\n        const listener = new Listener(callback, context);\n        this.listeners.push(listener);\n    }\n    unsubscribe(callback, context) {\n        var _a;\n        (_a = this.listeners.find(l => l.matches(callback, context))) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n}\nclass Listener {\n    constructor(callback, context) {\n        this._gc = false;\n        this.callback = callback;\n        this.context = context || null;\n    }\n    get gc() {\n        return this._gc;\n    }\n    matches(callback, context) {\n        return this.callback === callback && this.context === context;\n    }\n    send(value) {\n        if (this.context) {\n            this.callback.call(this.context, value);\n        }\n        else {\n            this.callback(value);\n        }\n    }\n    unsubscribe() {\n        this._gc = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvb2JzZXJ2YWJsZS50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9vYnNlcnZhYmxlLnRzP2MyYWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIE9ic2VydmFibGVWYXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lci5nYykge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnNlbmQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKGYpIHtcbiAgICAgICAgdGhpcy5zZXQoZih0aGlzLnZhbHVlKSk7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHN1YnNjcmliZShjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IG5ldyBMaXN0ZW5lcihjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICBsaXN0ZW5lci5zZW5kKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZShjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXJzLmZpbmQobCA9PiBsLm1hdGNoZXMoY2FsbGJhY2ssIGNvbnRleHQpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEV2ZW50UHVibGlzaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgc2VuZCh2YWx1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5saXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLmdjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuc2VuZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IExpc3RlbmVyKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcnMuZmluZChsID0+IGwubWF0Y2hlcyhjYWxsYmFjaywgY29udGV4dCkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG5jbGFzcyBMaXN0ZW5lciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZ2MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG4gICAgfVxuICAgIGdldCBnYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2djO1xuICAgIH1cbiAgICBtYXRjaGVzKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrID09PSBjYWxsYmFjayAmJiB0aGlzLmNvbnRleHQgPT09IGNvbnRleHQ7XG4gICAgfVxuICAgIHNlbmQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIHRoaXMuX2djID0gdHJ1ZTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/observable.ts\n");

/***/ }),

/***/ "./src/resources.ts":
/*!**************************!*\
  !*** ./src/resources.ts ***!
  \**************************/
/*! exports provided: Resources */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Resources\", function() { return Resources; });\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass Resources {\n    constructor(loader) {\n        this._textures = {};\n        this._animations = {};\n        this.loader = loader;\n    }\n    load() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield new Promise((resolve => {\n                this.loader\n                    .add('npc.json')\n                    .add('dungeon.json')\n                    .add('bonfire.json')\n                    .add('dungeon.rules.json')\n                    .add('dungeon.rules.4.json')\n                    .add('dungeon.design.json')\n                    .add('dialogs.json')\n                    .add('alagard', 'fonts/alagard.fnt')\n                    .add('big_egg_collect', 'sounds/big_egg_collect.{ogg,mp3}')\n                    .add('fruit_collect', 'sounds/fruit_collect.{ogg,mp3}')\n                    .add('select', 'sounds/select.{ogg,mp3}')\n                    .add('confirm', 'sounds/confirm.{ogg,mp3}')\n                    .add('cancel', 'sounds/cancel.{ogg,mp3}')\n                    .add('text', 'sounds/text.{ogg,mp3}')\n                    .add('boss_hit', 'sounds/boss_hit.{ogg,mp3}')\n                    .add('hit_damage', 'sounds/hit_damage.{ogg,mp3}')\n                    .load((_loader, resources) => {\n                    resources['fonts/alagard.png'].texture.baseTexture.scaleMode = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"SCALE_MODES\"].NEAREST;\n                    this.add(resources['npc.json'].spritesheet);\n                    this.add(resources['dungeon.json'].spritesheet);\n                    this.add(resources['bonfire.json'].spritesheet);\n                    resolve();\n                });\n            }));\n        });\n    }\n    add(spritesheet) {\n        spritesheet.baseTexture.scaleMode = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"SCALE_MODES\"].NEAREST;\n        for (let name of Object.keys(spritesheet.textures)) {\n            this._textures[name] = spritesheet.textures[name];\n        }\n        for (let name of Object.keys(spritesheet.animations)) {\n            this._animations[name] = spritesheet.animations[name];\n        }\n    }\n    get textures() {\n        return Object.keys(this._textures);\n    }\n    get animations() {\n        return Object.keys(this._animations);\n    }\n    sprite(name) {\n        if (!this._textures[name]) {\n            throw `sprite not found: ${name}`;\n        }\n        const sprite = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"](this._textures[name]);\n        sprite.name = name;\n        return sprite;\n    }\n    animated(name, autoUpdate = true) {\n        if (!this._animations[name]) {\n            throw `animation not found: ${name}`;\n        }\n        const sprite = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"AnimatedSprite\"](this._animations[name], autoUpdate);\n        sprite.name = name;\n        return sprite;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcmVzb3VyY2VzLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy50cz9kODc5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCAqIGFzIFBJWEkgZnJvbSAncGl4aS5qcyc7XG5leHBvcnQgY2xhc3MgUmVzb3VyY2VzIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXIpIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IGxvYWRlcjtcbiAgICB9XG4gICAgbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJcbiAgICAgICAgICAgICAgICAgICAgLmFkZCgnbnBjLmpzb24nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKCdkdW5nZW9uLmpzb24nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKCdib25maXJlLmpzb24nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKCdkdW5nZW9uLnJ1bGVzLmpzb24nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKCdkdW5nZW9uLnJ1bGVzLjQuanNvbicpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoJ2R1bmdlb24uZGVzaWduLmpzb24nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKCdkaWFsb2dzLmpzb24nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKCdhbGFnYXJkJywgJ2ZvbnRzL2FsYWdhcmQuZm50JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZCgnYmlnX2VnZ19jb2xsZWN0JywgJ3NvdW5kcy9iaWdfZWdnX2NvbGxlY3Que29nZyxtcDN9JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZCgnZnJ1aXRfY29sbGVjdCcsICdzb3VuZHMvZnJ1aXRfY29sbGVjdC57b2dnLG1wM30nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKCdzZWxlY3QnLCAnc291bmRzL3NlbGVjdC57b2dnLG1wM30nKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKCdjb25maXJtJywgJ3NvdW5kcy9jb25maXJtLntvZ2csbXAzfScpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoJ2NhbmNlbCcsICdzb3VuZHMvY2FuY2VsLntvZ2csbXAzfScpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoJ3RleHQnLCAnc291bmRzL3RleHQue29nZyxtcDN9JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZCgnYm9zc19oaXQnLCAnc291bmRzL2Jvc3NfaGl0LntvZ2csbXAzfScpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoJ2hpdF9kYW1hZ2UnLCAnc291bmRzL2hpdF9kYW1hZ2Uue29nZyxtcDN9JylcbiAgICAgICAgICAgICAgICAgICAgLmxvYWQoKF9sb2FkZXIsIHJlc291cmNlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXNbJ2ZvbnRzL2FsYWdhcmQucG5nJ10udGV4dHVyZS5iYXNlVGV4dHVyZS5zY2FsZU1vZGUgPSBQSVhJLlNDQUxFX01PREVTLk5FQVJFU1Q7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHJlc291cmNlc1snbnBjLmpzb24nXS5zcHJpdGVzaGVldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHJlc291cmNlc1snZHVuZ2Vvbi5qc29uJ10uc3ByaXRlc2hlZXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChyZXNvdXJjZXNbJ2JvbmZpcmUuanNvbiddLnNwcml0ZXNoZWV0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkKHNwcml0ZXNoZWV0KSB7XG4gICAgICAgIHNwcml0ZXNoZWV0LmJhc2VUZXh0dXJlLnNjYWxlTW9kZSA9IFBJWEkuU0NBTEVfTU9ERVMuTkVBUkVTVDtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyhzcHJpdGVzaGVldC50ZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzW25hbWVdID0gc3ByaXRlc2hlZXQudGV4dHVyZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyhzcHJpdGVzaGVldC5hbmltYXRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uc1tuYW1lXSA9IHNwcml0ZXNoZWV0LmFuaW1hdGlvbnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRleHR1cmVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fdGV4dHVyZXMpO1xuICAgIH1cbiAgICBnZXQgYW5pbWF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2FuaW1hdGlvbnMpO1xuICAgIH1cbiAgICBzcHJpdGUobmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmVzW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBgc3ByaXRlIG5vdCBmb3VuZDogJHtuYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRoaXMuX3RleHR1cmVzW25hbWVdKTtcbiAgICAgICAgc3ByaXRlLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gc3ByaXRlO1xuICAgIH1cbiAgICBhbmltYXRlZChuYW1lLCBhdXRvVXBkYXRlID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IGBhbmltYXRpb24gbm90IGZvdW5kOiAke25hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5BbmltYXRlZFNwcml0ZSh0aGlzLl9hbmltYXRpb25zW25hbWVdLCBhdXRvVXBkYXRlKTtcbiAgICAgICAgc3ByaXRlLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gc3ByaXRlO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/resources.ts\n");

/***/ }),

/***/ "./src/scene.ts":
/*!***********************************!*\
  !*** ./src/scene.ts + 38 modules ***!
  \***********************************/
/*! exports provided: SceneController */
/*! ModuleConcatenation bailout: Cannot concat with ./src/curves.ts because of ./src/inventory.modal.ts */
/*! ModuleConcatenation bailout: Cannot concat with ./src/drop.ts because of ./src/inventory.modal.ts */
/*! ModuleConcatenation bailout: Cannot concat with ./src/inventory.modal.ts (<- Module uses injected variables (PIXI)) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/inventory.ts because of ./src/inventory.modal.ts */
/*! ModuleConcatenation bailout: Cannot concat with ./src/observable.ts because of ./src/inventory.modal.ts */
/*! ModuleConcatenation bailout: Cannot concat with ./src/ui.ts because of ./src/app.ts */
/*! ModuleConcatenation bailout: Cannot concat with external "PIXI" (<- Module is not an ECMAScript module) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"SceneController\", function() { return /* binding */ scene_SceneController; });\n\n// CONCATENATED MODULE: ./src/rng.ts\nconst rng_m = 0x80000000;\nconst rng_a = 1103515245;\nconst rng_c = 12345;\nclass RNG {\n    constructor(seed = null) {\n        this.state = seed ? seed : Math.floor(Math.random() * (rng_m - 1));\n        console.log(\"seed\", this.state);\n    }\n    get boolean() {\n        return this.nextInt() % 1 != 0;\n    }\n    get int() {\n        this.state = (rng_a * this.state + rng_c) % rng_m;\n        return this.state;\n    }\n    get float() {\n        return this.int / (rng_m - 1);\n    }\n    nextInt() {\n        return this.int;\n    }\n    nextFloat() {\n        return this.float;\n    }\n    nextRange(start, end) {\n        const rangeSize = end - start;\n        const randomUnder1 = this.nextInt() / rng_m;\n        return start + Math.floor(randomUnder1 * rangeSize);\n    }\n    choice(array) {\n        return array[this.nextRange(0, array.length)];\n    }\n    nextNormal(min, max, skew) {\n        let u = 0, v = 0;\n        while (u === 0)\n            u = Math.random();\n        while (v === 0)\n            v = Math.random();\n        let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n        num = num / 10.0 + 0.5;\n        if (num > 1 || num < 0)\n            num = this.nextNormal(min, max, skew);\n        num = Math.pow(num, skew);\n        num *= max - min;\n        num += min;\n        return num;\n    }\n}\n\n// CONCATENATED MODULE: ./src/input.ts\nvar KeyBindState;\n(function (KeyBindState) {\n    KeyBindState[KeyBindState[\"Await\"] = 1] = \"Await\";\n    KeyBindState[KeyBindState[\"Pressed\"] = 2] = \"Pressed\";\n})(KeyBindState || (KeyBindState = {}));\nclass KeyBind {\n    constructor(code) {\n        this.code = code;\n        this.state = KeyBindState.Await;\n        this._triggered = false;\n        this._processed = true;\n    }\n    get triggered() {\n        return this._triggered;\n    }\n    once() {\n        if (!this._processed) {\n            this._processed = true;\n            return true;\n        }\n        else\n            return false;\n    }\n    keydown(e) {\n        if (e.code === this.code) {\n            e.preventDefault();\n            if (this.state === KeyBindState.Await) {\n                this._triggered = true;\n                this._processed = false;\n                this.state = KeyBindState.Pressed;\n            }\n        }\n    }\n    keyup(e) {\n        if (e.code === this.code) {\n            e.preventDefault();\n            if (this.state === KeyBindState.Pressed) {\n                this._triggered = false;\n                this.state = KeyBindState.Await;\n            }\n        }\n    }\n    reset() {\n        this._triggered = false;\n        this._processed = true;\n    }\n}\nclass Joystick {\n    constructor() {\n        this.moveUp = new KeyBind('KeyW');\n        this.moveLeft = new KeyBind('KeyA');\n        this.moveDown = new KeyBind('KeyS');\n        this.moveRight = new KeyBind('KeyD');\n        this.hit = new KeyBind('KeyF');\n        this.drop = new KeyBind('KeyQ');\n        this.inventory = new KeyBind('KeyI');\n        this.digit1 = new KeyBind('Digit1');\n        this.digit2 = new KeyBind('Digit2');\n        this.digit3 = new KeyBind('Digit3');\n        this.digit4 = new KeyBind('Digit4');\n        this.digit5 = new KeyBind('Digit5');\n        this.digit6 = new KeyBind('Digit6');\n        this.digit7 = new KeyBind('Digit7');\n        this.digit8 = new KeyBind('Digit8');\n        this.digit9 = new KeyBind('Digit9');\n        this.digit0 = new KeyBind('Digit0');\n        this.bindings = {};\n        for (const property of Object.getOwnPropertyNames(this)) {\n            const value = this[property];\n            if (value && value instanceof KeyBind) {\n                this.bindings[value.code] = value;\n            }\n        }\n        window.addEventListener(\"keydown\", this.keydown.bind(this));\n        window.addEventListener(\"keyup\", this.keyup.bind(this));\n    }\n    digit(num) {\n        switch (num) {\n            case 1:\n                return this.digit1;\n            case 2:\n                return this.digit2;\n            case 3:\n                return this.digit3;\n            case 4:\n                return this.digit4;\n            case 5:\n                return this.digit5;\n            case 6:\n                return this.digit6;\n            case 7:\n                return this.digit7;\n            case 8:\n                return this.digit8;\n            case 9:\n                return this.digit9;\n            case 0:\n                return this.digit0;\n        }\n    }\n    reset() {\n        var _a;\n        for (const code of Object.getOwnPropertyNames(this.bindings)) {\n            (_a = this.bindings[code]) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    keydown(e) {\n        var _a;\n        (_a = this.bindings[e.code]) === null || _a === void 0 ? void 0 : _a.keydown(e);\n    }\n    keyup(e) {\n        var _a;\n        (_a = this.bindings[e.code]) === null || _a === void 0 ? void 0 : _a.keyup(e);\n    }\n}\n\n// EXTERNAL MODULE: external \"PIXI\"\nvar external_PIXI_ = __webpack_require__(\"pixi.js\");\n\n// CONCATENATED MODULE: ./src/dead.scene.ts\n\nclass dead_scene_YouDeadScene {\n    constructor(controller) {\n        this.controller = controller;\n    }\n    init() {\n        this.renderTitle();\n        this.renderHelp();\n        this.controller.app.ticker.add(this.handleInput, this);\n    }\n    destroy() {\n        this.controller.app.ticker.remove(this.handleInput, this);\n        this.controller.stage.removeChildren();\n    }\n    pause() {\n    }\n    resume() {\n    }\n    renderTitle() {\n        let title = new external_PIXI_[\"BitmapText\"](\"ROGUELIKE DUNGEON\", { font: { name: 'alagard', size: 64 } });\n        title.anchor = new external_PIXI_[\"Point\"](0.5, 0);\n        title.position.set(this.controller.app.screen.width >> 1, 64);\n        this.controller.stage.addChild(title);\n        let youDead = new external_PIXI_[\"BitmapText\"](\"YOU DEAD\", { font: { name: \"alagard\", size: 128 }, tint: 0xFF0000 });\n        youDead.anchor = 0.5;\n        youDead.position.set(this.controller.app.screen.width >> 1, 256);\n        this.controller.stage.addChild(youDead);\n    }\n    renderHelp() {\n        const line = new external_PIXI_[\"BitmapText\"](\"PRESS F TO RESTART\", { font: { name: \"alagard\", size: 32 } });\n        line.anchor = 0.5;\n        line.position.set(this.controller.app.screen.width >> 1, this.controller.app.screen.height - 64);\n        this.controller.stage.addChild(line);\n    }\n    handleInput() {\n        if (this.controller.joystick.hit.once()) {\n            this.controller.selectHero();\n        }\n    }\n}\n\n// EXTERNAL MODULE: ./src/drop.ts\nvar src_drop = __webpack_require__(\"./src/drop.ts\");\n\n// CONCATENATED MODULE: ./src/shadow.caster.ts\n\nconst TILE_SIZE = 16;\nclass EndPoint {\n    constructor(point, segment) {\n        this.begin = false;\n        this.angle = 0.0;\n        this.point = point;\n        this.segment = segment;\n    }\n}\nvar SegmentType;\n(function (SegmentType) {\n    SegmentType[SegmentType[\"NORMAL\"] = 0] = \"NORMAL\";\n    SegmentType[SegmentType[\"TOP\"] = 1] = \"TOP\";\n})(SegmentType || (SegmentType = {}));\nclass Segment {\n    constructor(p1, p2, type) {\n        this.distance = 0;\n        this.p1 = new EndPoint(p1, this);\n        this.p2 = new EndPoint(p2, this);\n        this.type = type;\n    }\n    toString() {\n        const p1 = this.p1.point;\n        const p2 = this.p2.point;\n        return `[${p1.x}:${p1.y} - ${p2.x}:${p2.y}]`;\n    }\n}\nclass shadow_caster_ShadowCaster {\n    constructor() {\n        this.segments = [];\n        this.endpoints = [];\n        this.light = new external_PIXI_[\"Point\"](0, 0);\n        this.maxDistance = 500;\n    }\n    init() {\n        this.segments = [];\n        this.endpoints = [];\n        this.light = new external_PIXI_[\"Point\"](0.0, 0.0);\n    }\n    addSegment(x1, y1, x2, y2, type) {\n        const p1 = new external_PIXI_[\"Point\"](x1, y1);\n        const p2 = new external_PIXI_[\"Point\"](x2, y2);\n        const segment = new Segment(p1, p2, type);\n        this.segments.push(segment);\n        this.endpoints.push(segment.p1);\n        this.endpoints.push(segment.p2);\n    }\n    static deduplicated(queue) {\n        const deduplicated = [];\n        while (queue.length > 0) {\n            const segment = queue.pop();\n            const duplicates = [];\n            for (let i = 0; i < queue.length; i++) {\n                let next = queue[i];\n                let sameType = segment.type === next.type;\n                let equal = segment.p1.point.equals(next.p1.point) && segment.p2.point.equals(next.p2.point);\n                if (sameType && equal) {\n                    duplicates.push(i);\n                }\n            }\n            for (let i of duplicates) {\n                queue.splice(i, 1);\n            }\n            deduplicated.push(segment);\n        }\n        return deduplicated;\n    }\n    static connected(segments) {\n        const connected = [];\n        for (let i = 0; i < segments.length; i++) {\n            let segment = segments[i];\n            let has_p1 = false;\n            let has_p2 = false;\n            for (let j = 0; j < segments.length; j++) {\n                if (j == i)\n                    continue;\n                let test = segments[j];\n                if (segment.p1.point.equals(test.p1.point) && segment.p2.point.equals(test.p2.point))\n                    continue;\n                if (!has_p1 && (segment.p1.point.equals(test.p1.point) || segment.p1.point.equals(test.p2.point))) {\n                    has_p1 = true;\n                }\n                if (!has_p2 && (segment.p2.point.equals(test.p1.point) || segment.p2.point.equals(test.p2.point))) {\n                    has_p2 = true;\n                }\n                if (has_p1 && has_p2) {\n                    connected.push(segment);\n                    break;\n                }\n            }\n        }\n        return connected;\n    }\n    static filtered(segments) {\n        const filtered = [];\n        const queue = [];\n        const parts = [\n            [0, 12, 0, 16],\n            [5, 12, 5, 16],\n            [0, 12, 5, 12],\n            [0, 0, 5, 0],\n            [11, 12, 11, 16],\n            [11, 12, 16, 12],\n            [11, 0, 16, 0],\n        ];\n        const isPart = (segment) => {\n            const s_x1 = segment.p1.point.x % 16;\n            const s_y1 = segment.p1.point.y % 16;\n            const s_x2 = segment.p2.point.x - segment.p1.point.x + s_x1;\n            const s_y2 = segment.p2.point.y - segment.p1.point.y + s_y1;\n            for (let [x1, y1, x2, y2] of parts) {\n                if (x1 === s_x1 && y1 === s_y1 && x2 === s_x2 && y2 === s_y2) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        for (const segment of segments) {\n            if (isPart(segment)) {\n                queue.push(segment);\n            }\n            else {\n                filtered.push(segment);\n            }\n        }\n        while (queue.length > 0) {\n            const segment = queue.pop();\n            const rect = [segment];\n            const points = [segment.p1.point, segment.p2.point];\n            const counts = [1, 1];\n            const joins = [];\n            for (let t = 0; t < 2; t++) {\n                for (let i = 0; i < queue.length; i++) {\n                    if (joins.indexOf(i) >= 0)\n                        continue;\n                    let next = queue[i];\n                    const p1 = next.p1.point;\n                    const p2 = next.p2.point;\n                    let has_p1 = false;\n                    let has_p2 = false;\n                    for (let j = 0; j < points.length; j++) {\n                        let p = points[j];\n                        if (p.equals(p1)) {\n                            has_p1 = true;\n                            counts[j]++;\n                        }\n                        else if (p.equals(p2)) {\n                            has_p2 = true;\n                            counts[j]++;\n                        }\n                    }\n                    if (has_p1 || has_p2) {\n                        joins.push(i);\n                        rect.push(next);\n                        if (!has_p1) {\n                            points.push(p1);\n                            counts.push(1);\n                        }\n                        if (!has_p2) {\n                            points.push(p2);\n                            counts.push(1);\n                        }\n                    }\n                }\n            }\n            if (counts.length === 4 && counts.every(c => c === 2)) {\n                let bottom = 0;\n                let bottom_y = 0;\n                for (let i = 0; i < 4; i++) {\n                    let s = rect[i];\n                    if (s.p1.point.y === s.p2.point.y && s.p1.point.y > bottom_y) {\n                        bottom = i;\n                        bottom_y = s.p1.point.y;\n                    }\n                }\n                for (let i of joins.reverse())\n                    queue.splice(i, 1);\n                rect.splice(bottom, 1);\n                filtered.push(...rect);\n            }\n            else {\n                filtered.push(segment);\n            }\n        }\n        return filtered;\n    }\n    static merge(queue) {\n        const merged = [];\n        while (queue.length > 0) {\n            const first = queue.pop();\n            let pair = null;\n            for (let i = 0; i < queue.length; i++) {\n                let next = queue[i];\n                if (first.type === next.type) {\n                    if (first.p2.point.equals(next.p1.point)) {\n                        queue.splice(i, 1);\n                        pair = [first, next];\n                        break;\n                    }\n                    else if (next.p2.point.equals(first.p1.point)) {\n                        queue.splice(i, 1);\n                        pair = [next, first];\n                        break;\n                    }\n                }\n            }\n            if (pair) {\n                const [a, b] = pair;\n                queue.push(new Segment(a.p1.point, b.p2.point, a.type));\n            }\n            else {\n                merged.push(first);\n            }\n        }\n        return merged;\n    }\n    optimize() {\n        console.log(`optimize: segments=${this.segments.length}`);\n        const deduplicated = shadow_caster_ShadowCaster.deduplicated([...this.segments]);\n        console.log(`optimize: deduplicated=${deduplicated.length}`);\n        const connected = shadow_caster_ShadowCaster.connected(deduplicated);\n        console.log(`optimize: connected=${connected.length}`);\n        const filtered = shadow_caster_ShadowCaster.filtered(connected);\n        console.log(`optimize: filtered=${filtered.length}`);\n        const connected2 = shadow_caster_ShadowCaster.connected(filtered);\n        console.log(`optimize: connected = ${connected2.length}`);\n        const merged = [\n            ...shadow_caster_ShadowCaster.merge(connected2.filter(s => s.p1.point.x === s.p2.point.x)),\n            ...shadow_caster_ShadowCaster.merge(connected2.filter(s => s.p1.point.y === s.p2.point.y)),\n        ];\n        console.log(`optimize: merged=${merged.length}`);\n        this.segments = [];\n        this.endpoints = [];\n        for (const segment of merged) {\n            this.segments.push(segment);\n            this.endpoints.push(segment.p1);\n            this.endpoints.push(segment.p2);\n        }\n    }\n    setLightLocation(x, y, maxDistance) {\n        this.light.x = x;\n        this.light.y = y;\n        this.maxDistance = maxDistance;\n        this.endpoints = [];\n        for (const segment of this.segments) {\n            let dx = 0.5 * (segment.p1.point.x + segment.p2.point.x) - x;\n            let dy = 0.5 * (segment.p1.point.y + segment.p2.point.y) - y;\n            segment.distance = Math.sqrt(dx * dx + dy * dy);\n            if (segment.distance < maxDistance) {\n                segment.p1.angle = Math.atan2(segment.p1.point.y - y, segment.p1.point.x - x);\n                segment.p2.angle = Math.atan2(segment.p2.point.y - y, segment.p2.point.x - x);\n                let dAngle = segment.p2.angle - segment.p1.angle;\n                if (dAngle <= -Math.PI) {\n                    dAngle += 2 * Math.PI;\n                }\n                if (dAngle > Math.PI) {\n                    dAngle -= 2 * Math.PI;\n                }\n                segment.p1.begin = (dAngle > 0.0);\n                segment.p2.begin = !segment.p1.begin;\n                this.endpoints.push(segment.p1, segment.p2);\n            }\n        }\n        this.endpoints.sort(shadow_caster_ShadowCaster.compare);\n    }\n    static compare(a, b) {\n        if (a.angle > b.angle)\n            return 1;\n        if (a.angle < b.angle)\n            return -1;\n        if (!a.begin && b.begin)\n            return 1;\n        if (a.begin && !b.begin)\n            return -1;\n        return 0;\n    }\n    static leftOf(s, p) {\n        const cross = (s.p2.point.x - s.p1.point.x) * (p.y - s.p1.point.y)\n            - (s.p2.point.y - s.p1.point.y) * (p.x - s.p1.point.x);\n        return cross < 0;\n    }\n    static interpolate(p, q, f) {\n        return new external_PIXI_[\"Point\"](p.x * (1 - f) + q.x * f, p.y * (1 - f) + q.y * f);\n    }\n    static segmentInFrontOf(a, b, relativeTo) {\n        const A1 = shadow_caster_ShadowCaster.leftOf(a, shadow_caster_ShadowCaster.interpolate(b.p1.point, b.p2.point, 0.01));\n        const A2 = shadow_caster_ShadowCaster.leftOf(a, shadow_caster_ShadowCaster.interpolate(b.p2.point, b.p1.point, 0.01));\n        const A3 = shadow_caster_ShadowCaster.leftOf(a, relativeTo);\n        const B1 = shadow_caster_ShadowCaster.leftOf(b, shadow_caster_ShadowCaster.interpolate(a.p1.point, a.p2.point, 0.01));\n        const B2 = shadow_caster_ShadowCaster.leftOf(b, shadow_caster_ShadowCaster.interpolate(a.p2.point, a.p1.point, 0.01));\n        const B3 = shadow_caster_ShadowCaster.leftOf(b, relativeTo);\n        if (B1 == B2 && B2 != B3)\n            return true;\n        if (A1 == A2 && A2 == A3)\n            return true;\n        if (A1 == A2 && A2 != A3)\n            return false;\n        if (B1 == B2 && B2 == B3)\n            return false;\n        return false;\n    }\n    sweep() {\n        const output = [];\n        const open = [];\n        let beginAngle = 0.0;\n        for (let pass = 0; pass <= 2; pass++) {\n            for (const p of this.endpoints) {\n                let current_old = open.length === 0 ? null : open[0];\n                if (p.begin) {\n                    let i = 0;\n                    let node = open[i];\n                    while (node != null && shadow_caster_ShadowCaster.segmentInFrontOf(p.segment, node, this.light)) {\n                        i++;\n                        node = open[i];\n                    }\n                    if (node == null) {\n                        open.push(p.segment);\n                    }\n                    else {\n                        open.splice(i, 0, p.segment);\n                    }\n                }\n                else {\n                    for (let i = 0; i < open.length; i++) {\n                        if (open[i] === p.segment)\n                            open.splice(i, 1);\n                    }\n                }\n                let current_new = open.length === 0 ? null : open[0];\n                if (current_old !== current_new) {\n                    if (pass == 1) {\n                        this.addTriangle(beginAngle, p.angle, current_old, output);\n                    }\n                    beginAngle = p.angle;\n                }\n            }\n        }\n        return output;\n    }\n    static lineIntersection(p1, p2, p3, p4) {\n        const s = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x))\n            / ((p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y));\n        return new external_PIXI_[\"Point\"](p1.x + s * (p2.x - p1.x), p1.y + s * (p2.y - p1.y));\n    }\n    addTriangle(angle1, angle2, segment, output) {\n        const angle1cos = Math.cos(angle1);\n        const angle1sin = Math.sin(angle1);\n        const angle2cos = Math.cos(angle2);\n        const angle2sin = Math.sin(angle2);\n        let p1 = this.light;\n        let p2 = new external_PIXI_[\"Point\"](this.light.x + angle1cos, this.light.y + angle1sin);\n        let p3 = new external_PIXI_[\"Point\"](0.0, 0.0);\n        let p4 = new external_PIXI_[\"Point\"](0.0, 0.0);\n        if (segment != null) {\n            p3.x = segment.p1.point.x;\n            p3.y = segment.p1.point.y;\n            p4.x = segment.p2.point.x;\n            p4.y = segment.p2.point.y;\n        }\n        else {\n            p3.x = this.light.x + angle1cos * this.maxDistance;\n            p3.y = this.light.y + angle1sin * this.maxDistance;\n            p4.x = this.light.x + angle2cos * this.maxDistance;\n            p4.y = this.light.y + angle2sin * this.maxDistance;\n        }\n        let pBegin = shadow_caster_ShadowCaster.lineIntersection(p3, p4, p1, p2);\n        pBegin.x = Math.round(pBegin.x);\n        pBegin.y = Math.round(pBegin.y);\n        p2.x = this.light.x + angle2cos;\n        p2.y = this.light.y + angle2sin;\n        let pEnd = shadow_caster_ShadowCaster.lineIntersection(p3, p4, p1, p2);\n        pEnd.x = Math.round(pEnd.x);\n        pEnd.y = Math.round(pEnd.y);\n        if (segment != null) {\n            switch (segment.type) {\n                case SegmentType.TOP:\n                    output.push(pBegin);\n                    output.push(new external_PIXI_[\"Point\"](pBegin.x, pBegin.y - TILE_SIZE));\n                    output.push(new external_PIXI_[\"Point\"](pEnd.x, pEnd.y - TILE_SIZE));\n                    output.push(pEnd);\n                    break;\n                case SegmentType.NORMAL:\n                    output.push(pBegin);\n                    output.push(pEnd);\n                    break;\n            }\n        }\n        else {\n            output.push(pBegin);\n            output.push(pEnd);\n        }\n    }\n    debug() {\n        const scale = 1;\n        const width = (80 * 16) * scale;\n        const height = (80 * 16) * scale;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = width * scale;\n        canvas.height = height * scale;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.fillRect(0, 0, width, height);\n        ctx.scale(scale, scale);\n        const segments = new Path2D();\n        for (let segment of this.segments) {\n            const start = segment.p1.point;\n            const end = segment.p2.point;\n            segments.moveTo(start.x, start.y);\n            segments.lineTo(end.x, end.y);\n        }\n        ctx.strokeStyle = 'rgba(255,0,0,0.5)';\n        ctx.stroke(segments);\n        console.log('%c ', `\n      font-size: 1px;\n      padding: ${canvas.height / 2}px ${canvas.width / 2}px;\n      background: no-repeat url(${canvas.toDataURL('image/png')});\n      background-size: ${canvas.width}px ${canvas.height}px;\n    `);\n    }\n}\n\n// CONCATENATED MODULE: ./src/dungeon.light.ts\n\n\nconst dungeon_light_TILE_SIZE = 16;\nclass dungeon_light_DungeonLight {\n    constructor(dungeon) {\n        this.lights = [];\n        this.wall_top = {\n            default: [\n                { x1: 0, y1: 12, x2: 16, y2: 12, type: SegmentType.NORMAL },\n                { x1: 0, y1: 12, x2: 0, y2: 16, type: SegmentType.NORMAL },\n                { x1: 16, y1: 12, x2: 16, y2: 16, type: SegmentType.NORMAL },\n            ],\n            top: [\n                { x1: 0, y1: 0, x2: 16, y2: 0, type: SegmentType.TOP },\n            ],\n            left: [\n                { x1: 0, y1: 0, x2: 0, y2: 12, type: SegmentType.NORMAL },\n            ],\n            right: [\n                { x1: 16, y1: 0, x2: 16, y2: 12, type: SegmentType.NORMAL },\n            ],\n            bottom: []\n        };\n        this.wall_side_left = {\n            default: [\n                { x1: 11, y1: 0, x2: 11, y2: 16, type: SegmentType.NORMAL },\n                { x1: 11, y1: 0, x2: 16, y2: 0, type: SegmentType.NORMAL },\n                { x1: 11, y1: 16, x2: 16, y2: 16, type: SegmentType.TOP },\n            ],\n            top: [\n                { x1: 0, y1: 0, x2: 11, y2: 0, type: SegmentType.TOP },\n            ],\n            left: [\n                { x1: 0, y1: 0, x2: 0, y2: 16, type: SegmentType.NORMAL },\n            ],\n            right: [],\n            bottom: [\n                { x1: 0, y1: 16, x2: 11, y2: 16, type: SegmentType.NORMAL },\n            ],\n        };\n        this.wall_side_right = {\n            default: [\n                { x1: 5, y1: 0, x2: 5, y2: 16, type: SegmentType.NORMAL },\n                { x1: 0, y1: 0, x2: 5, y2: 0, type: SegmentType.NORMAL },\n                { x1: 0, y1: 16, x2: 5, y2: 16, type: SegmentType.TOP },\n            ],\n            top: [\n                { x1: 5, y1: 0, x2: 16, y2: 0, type: SegmentType.TOP },\n            ],\n            left: [],\n            right: [\n                { x1: 16, y1: 0, x2: 16, y2: 16, type: SegmentType.NORMAL },\n            ],\n            bottom: [\n                { x1: 5, y1: 16, x2: 16, y2: 16, type: SegmentType.NORMAL },\n            ],\n        };\n        this.wall_corner_left = {\n            default: [\n                { x1: 5, y1: 0, x2: 5, y2: 12, type: SegmentType.NORMAL },\n                { x1: 5, y1: 12, x2: 16, y2: 12, type: SegmentType.NORMAL },\n                { x1: 16, y1: 12, x2: 16, y2: 16, type: SegmentType.NORMAL }\n            ],\n            top: [\n                { x1: 5, y1: 0, x2: 16, y2: 0, type: SegmentType.TOP },\n            ],\n            left: [],\n            right: [\n                { x1: 16, y1: 0, x2: 16, y2: 12, type: SegmentType.NORMAL },\n            ],\n            bottom: [],\n        };\n        this.wall_corner_right = {\n            default: [\n                { x1: 11, y1: 0, x2: 11, y2: 12, type: SegmentType.NORMAL },\n                { x1: 0, y1: 12, x2: 11, y2: 12, type: SegmentType.NORMAL },\n                { x1: 0, y1: 12, x2: 0, y2: 16, type: SegmentType.NORMAL }\n            ],\n            top: [\n                { x1: 0, y1: 0, x2: 11, y2: 0, type: SegmentType.TOP },\n            ],\n            left: [\n                { x1: 0, y1: 0, x2: 0, y2: 12, type: SegmentType.NORMAL },\n            ],\n            right: [],\n            bottom: [],\n        };\n        this.wall_default = {\n            default: [],\n            top: [\n                { x1: 0, y1: 0, x2: 16, y2: 0, type: SegmentType.TOP },\n            ],\n            left: [\n                { x1: 0, y1: 0, x2: 0, y2: 16, type: SegmentType.NORMAL },\n            ],\n            right: [\n                { x1: 16, y1: 0, x2: 16, y2: 16, type: SegmentType.NORMAL },\n            ],\n            bottom: [\n                { x1: 0, y1: 16, x2: 16, y2: 16, type: SegmentType.NORMAL },\n            ],\n        };\n        this.config = {\n            \"wall_top_mid.png\": this.wall_top,\n            \"wall_side_front_left.png\": this.wall_side_left,\n            \"wall_side_front_right.png\": this.wall_side_right,\n            \"wall_side_mid_left.png\": this.wall_side_left,\n            \"wall_side_mid_right.png\": this.wall_side_right,\n            \"wall_side_top_left.png\": {\n                default: [\n                    { x1: 11, y1: 12, x2: 16, y2: 12, type: SegmentType.NORMAL },\n                    { x1: 11, y1: 12, x2: 11, y2: 16, type: SegmentType.NORMAL },\n                ],\n                top: [\n                    { x1: 0, y1: 0, x2: 16, y2: 0, type: SegmentType.TOP },\n                ],\n                left: [\n                    { x1: 0, y1: 0, x2: 0, y2: 16, type: SegmentType.NORMAL },\n                ],\n                right: [\n                    { x1: 16, y1: 0, x2: 16, y2: 12, type: SegmentType.NORMAL },\n                ],\n                bottom: [\n                    { x1: 0, y1: 16, x2: 11, y2: 16, type: SegmentType.NORMAL },\n                ],\n            },\n            \"wall_side_top_right.png\": {\n                default: [\n                    { x1: 0, y1: 12, x2: 5, y2: 12, type: SegmentType.NORMAL },\n                    { x1: 5, y1: 12, x2: 5, y2: 16, type: SegmentType.NORMAL },\n                ],\n                top: [\n                    { x1: 0, y1: 0, x2: 16, y2: 0, type: SegmentType.TOP },\n                ],\n                left: [\n                    { x1: 0, y1: 12, x2: 0, y2: 16, type: SegmentType.NORMAL },\n                ],\n                right: [\n                    { x1: 16, y1: 0, x2: 16, y2: 16, type: SegmentType.NORMAL },\n                ],\n                bottom: [\n                    { x1: 5, y1: 16, x2: 16, y2: 16, type: SegmentType.NORMAL },\n                ],\n            },\n            \"wall_inner_corner_t_top_left.png\": this.wall_top,\n            \"wall_inner_corner_t_top_right.png\": this.wall_top,\n            \"wall_inner_corner_l_top_left.png\": this.wall_corner_left,\n            \"wall_inner_corner_l_top_right.png\": this.wall_corner_right,\n            \"wall_corner_bottom_left.png\": this.wall_corner_left,\n            \"wall_corner_bottom_right.png\": this.wall_corner_right,\n            \"wall_corner_top_left.png\": this.wall_top,\n            \"wall_corner_top_right.png\": this.wall_top,\n            \"wall_fountain_top.png\": {\n                default: [\n                    { x1: 0, y1: 12, x2: 0, y2: 16, type: SegmentType.NORMAL },\n                    { x1: 0, y1: 12, x2: 2, y2: 12, type: SegmentType.NORMAL },\n                    { x1: 2, y1: 9, x2: 2, y2: 12, type: SegmentType.NORMAL },\n                    { x1: 2, y1: 9, x2: 14, y2: 9, type: SegmentType.NORMAL },\n                    { x1: 14, y1: 9, x2: 14, y2: 12, type: SegmentType.NORMAL },\n                    { x1: 14, y1: 12, x2: 16, y2: 12, type: SegmentType.NORMAL },\n                    { x1: 16, y1: 12, x2: 16, y2: 16, type: SegmentType.NORMAL },\n                ],\n                top: [\n                    { x1: 0, y1: 0, x2: 16, y2: 0, type: SegmentType.TOP },\n                ],\n                left: [\n                    { x1: 0, y1: 0, x2: 0, y2: 12, type: SegmentType.NORMAL },\n                ],\n                right: [\n                    { x1: 16, y1: 0, x2: 16, y2: 12, type: SegmentType.NORMAL },\n                ],\n                bottom: []\n            },\n            \"wall_one_top.png\": this.wall_top,\n            \"wall_one_corner_left.png\": this.wall_corner_left,\n            \"wall_one_corner_right.png\": this.wall_corner_right,\n        };\n        this.dungeon = dungeon;\n        this.layer = new external_PIXI_[\"display\"].Layer();\n        this.layer.useRenderTexture = true;\n        this.layer.on('display', (element) => {\n            element.blendMode = external_PIXI_[\"BLEND_MODES\"].MULTIPLY;\n        });\n        this.layer.clearColor = [0, 0, 0, 1];\n        this.container = new external_PIXI_[\"Container\"]();\n        this.layer.addChild(this.container);\n        this.heroLightTexture = dungeon_light_DungeonLight.gradient(\"white\", 150);\n        this.fountainRedTexture = dungeon_light_DungeonLight.gradient(\"rgb(211,78,56)\", 50);\n        this.fountainBlueTexture = dungeon_light_DungeonLight.gradient(\"rgb(86,152,204)\", 50);\n        this.bonfireTexture = dungeon_light_DungeonLight.gradient(\"rgb(255,239,204)\", 100);\n        this.shadowCaster = new shadow_caster_ShadowCaster();\n        this.dungeon.ticker.add(this.update, this);\n    }\n    destroy() {\n        this.dungeon.ticker.remove(this.update, this);\n        this.lights.forEach(l => l.destroy());\n        this.heroLightTexture.destroy();\n        this.fountainBlueTexture.destroy();\n        this.fountainRedTexture.destroy();\n        this.bonfireTexture.destroy();\n        this.container.destroy();\n        this.layer.destroy();\n    }\n    loadMap() {\n        this.shadowCaster.init();\n        const dungeon = this.dungeon;\n        for (let y = 0; y < dungeon.height; y++) {\n            for (let x = 0; x < dungeon.width; x++) {\n                const cell = dungeon.cell(x, y);\n                if (cell.hasFloor) {\n                    switch (cell.floorName) {\n                        case 'wall_fountain_basin_red':\n                            this.addLight(new external_PIXI_[\"Point\"](x * dungeon_light_TILE_SIZE, y * dungeon_light_TILE_SIZE), LightType.RED_BASIN);\n                            break;\n                        case 'wall_fountain_basin_blue':\n                            this.addLight(new external_PIXI_[\"Point\"](x * dungeon_light_TILE_SIZE, y * dungeon_light_TILE_SIZE), LightType.BLUE_BASIN);\n                            break;\n                        default:\n                            break;\n                    }\n                    const has_top = y > 0 && dungeon.cell(x, y - 1).hasFloor;\n                    const has_bottom = y + 1 < dungeon.height && dungeon.cell(x, y + 1).hasFloor;\n                    const has_left = x > 0 && dungeon.cell(x - 1, y).hasFloor;\n                    const has_right = x + 1 < dungeon.width && dungeon.cell(x + 1, y).hasFloor;\n                    let config;\n                    const cellWall = cell.wallName;\n                    if (cellWall && this.config[cellWall]) {\n                        config = this.config[cellWall] || this.wall_default;\n                    }\n                    else {\n                        config = this.wall_default;\n                    }\n                    this.add(x, y, config.default);\n                    if (!has_top)\n                        this.add(x, y, config.top);\n                    if (!has_bottom)\n                        this.add(x, y, config.bottom);\n                    if (!has_left)\n                        this.add(x, y, config.left);\n                    if (!has_right)\n                        this.add(x, y, config.right);\n                }\n            }\n        }\n        this.shadowCaster.optimize();\n    }\n    addLight(position, type) {\n        switch (type) {\n            case LightType.HERO:\n                this.lights.push(new dungeon_light_LightSource(position, 350, this.heroLightTexture, this.container));\n                break;\n            case LightType.RED_BASIN:\n                this.lights.push(new dungeon_light_LightSource(position, 150, this.fountainRedTexture, this.container));\n                break;\n            case LightType.BLUE_BASIN:\n                this.lights.push(new dungeon_light_LightSource(position, 150, this.fountainBlueTexture, this.container));\n                break;\n            case LightType.BONFIRE:\n                this.lights.push(new dungeon_light_LightSource(position, 250, this.bonfireTexture, this.container));\n                break;\n        }\n    }\n    add(x, y, segments) {\n        for (let segment of segments) {\n            this.shadowCaster.addSegment(x * dungeon_light_TILE_SIZE + segment.x1, y * dungeon_light_TILE_SIZE + segment.y1, x * dungeon_light_TILE_SIZE + segment.x2, y * dungeon_light_TILE_SIZE + segment.y2, segment.type);\n        }\n    }\n    update() {\n        this.lights.forEach((light) => {\n            const start = new external_PIXI_[\"Point\"](light.position.x + 8, light.position.y + 8);\n            this.shadowCaster.setLightLocation(start.x, start.y, light.maxDistance);\n            const output = this.shadowCaster.sweep();\n            light.sprite.position.set(start.x, start.y);\n            light.mask.clear()\n                .beginFill(0xFFFFFF, 1)\n                .drawPolygon(output)\n                .endFill();\n        });\n    }\n    static gradient(color, radius) {\n        const diameter = radius << 1;\n        const c = document.createElement(\"canvas\");\n        c.width = diameter;\n        c.height = diameter;\n        const ctx = c.getContext(\"2d\");\n        if (ctx) {\n            const grd = ctx.createRadialGradient(radius, radius, 0, radius, radius, radius);\n            grd.addColorStop(0.1, color);\n            grd.addColorStop(1, \"transparent\");\n            ctx.fillStyle = grd;\n            ctx.fillRect(0, 0, diameter, diameter);\n        }\n        return external_PIXI_[\"Texture\"].from(c);\n    }\n}\nvar LightType;\n(function (LightType) {\n    LightType[LightType[\"HERO\"] = 0] = \"HERO\";\n    LightType[LightType[\"RED_BASIN\"] = 1] = \"RED_BASIN\";\n    LightType[LightType[\"BLUE_BASIN\"] = 2] = \"BLUE_BASIN\";\n    LightType[LightType[\"BONFIRE\"] = 3] = \"BONFIRE\";\n})(LightType || (LightType = {}));\nclass dungeon_light_LightSource {\n    constructor(position, maxDistance, texture, container) {\n        this.position = position;\n        this.maxDistance = maxDistance;\n        this.mask = new external_PIXI_[\"Graphics\"]();\n        this.mask.isMask = true;\n        this.sprite = new external_PIXI_[\"Sprite\"](texture);\n        this.sprite.anchor.set(0.5, 0.5);\n        this.sprite.mask = this.mask;\n        this.sprite.blendMode = external_PIXI_[\"BLEND_MODES\"].ADD;\n        container.addChild(this.mask);\n        container.addChild(this.sprite);\n    }\n    destroy() {\n        this.sprite.destroy();\n        this.mask.destroy();\n    }\n}\n\n// CONCATENATED MODULE: ./src/dungeon.map.ts\n\n\n\nconst dungeon_map_TILE_SIZE = 16;\nconst DungeonZIndexes = {\n    character: 60,\n    hero: 70,\n    drop: 50,\n    static: 40,\n    floor: 1,\n    wall: 100,\n    row: 256\n};\nclass dungeon_map_DungeonMap {\n    constructor(controller, ticker, rng, seed, level, width, height) {\n        this.scale = 2;\n        this.controller = controller;\n        this.ticker = ticker;\n        this.rng = rng;\n        this.seed = seed;\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.cells = [];\n        for (let y = 0; y < this.width; y++) {\n            this.cells[y] = [];\n            for (let x = 0; x < this.height; x++) {\n                this.cells[y][x] = new dungeon_map_MapCell(this, x, y);\n            }\n        }\n        this.container = new external_PIXI_[\"Container\"]();\n        this.container.zIndex = 0;\n        this.container.sortableChildren = true;\n        this.container.scale.set(this.scale, this.scale);\n        this.light = new dungeon_light_DungeonLight(this);\n        this.light.layer.zIndex = 1;\n        this.light.container.scale.set(this.scale, this.scale);\n        this.lighting = new external_PIXI_[\"Sprite\"](this.light.layer.getRenderTexture());\n        this.lighting.blendMode = external_PIXI_[\"BLEND_MODES\"].MULTIPLY;\n        this.lighting.zIndex = 2;\n    }\n    destroy() {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                this.cells[y][x].destroy();\n            }\n        }\n        this.lighting.destroy();\n        this.light.destroy();\n        this.container.destroy({ children: true });\n    }\n    log(message) {\n        console.info(message);\n    }\n    cell(x, y) {\n        return this.cells[y][x];\n    }\n    remove(x, y, object) {\n        for (let dx = 0; dx < object.width; dx++) {\n            for (let dy = 0; dy < object.height; dy++) {\n                const cell = this.cell(x + dx, y - dy);\n                const c = cell.object;\n                if (c && (c === object)) {\n                    cell.object = null;\n                }\n            }\n        }\n    }\n    set(x, y, object) {\n        for (let dx = 0; dx < object.width; dx++) {\n            for (let dy = 0; dy < object.height; dy++) {\n                this.cell(x + dx, y - dy).object = object;\n            }\n        }\n    }\n    available(x, y, object) {\n        for (let dx = 0; dx < object.width; dx++) {\n            for (let dy = 0; dy < object.height; dy++) {\n                const cell = this.cell(x + dx, y - dy);\n                if (!cell.hasFloor || cell.collide(object)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    camera(x, y) {\n        const c_w = this.controller.app.screen.width;\n        const c_h = this.controller.app.screen.height;\n        const p_x = (c_w >> 1) - x * this.scale;\n        const p_y = (c_h >> 1) - y * this.scale;\n        this.container.position.set(p_x, p_y);\n        this.light.container.position.set(p_x, p_y);\n    }\n    sprite(x, y, name) {\n        let sprite;\n        if (!name.endsWith('.png')) {\n            const animated = this.controller.resources.animated(name);\n            animated.animationSpeed = 0.2;\n            animated.play();\n            sprite = animated;\n        }\n        else {\n            sprite = this.controller.resources.sprite(name);\n        }\n        sprite.position.set(x * dungeon_map_TILE_SIZE, y * dungeon_map_TILE_SIZE);\n        this.container.addChild(sprite);\n        return sprite;\n    }\n    animated(x, y, name) {\n        const animated = this.controller.resources.animated(name);\n        animated.animationSpeed = 0.2;\n        animated.play();\n        animated.position.set(x * dungeon_map_TILE_SIZE, y * dungeon_map_TILE_SIZE);\n        this.container.addChild(animated);\n        return animated;\n    }\n}\nclass dungeon_map_MapCell {\n    constructor(dungeon, x, y) {\n        this._floor = null;\n        this._wall = null;\n        this._drop = null;\n        this._object = null;\n        this.dungeon = dungeon;\n        this.x = x;\n        this.y = y;\n    }\n    destroy() {\n        var _a, _b, _c, _d;\n        (_a = this._floor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._floor = null;\n        (_b = this._wall) === null || _b === void 0 ? void 0 : _b.destroy();\n        this._wall = null;\n        (_c = this._drop) === null || _c === void 0 ? void 0 : _c.destroy();\n        this._drop = null;\n        (_d = this._object) === null || _d === void 0 ? void 0 : _d.destroy();\n        this._object = null;\n    }\n    set floorName(name) {\n        var _a;\n        (_a = this._floor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._floor = null;\n        if (name) {\n            this._floor = new DefaultDungeonFloor(this.dungeon, this.x, this.y, name);\n        }\n    }\n    get floorName() {\n        var _a;\n        return ((_a = this._floor) === null || _a === void 0 ? void 0 : _a.name) || null;\n    }\n    get floor() {\n        return this._floor;\n    }\n    get hasFloor() {\n        return !!this._floor;\n    }\n    get wallName() {\n        var _a;\n        return ((_a = this._wall) === null || _a === void 0 ? void 0 : _a.name) || null;\n    }\n    set wallName(name) {\n        var _a;\n        (_a = this._wall) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._wall = null;\n        if (name) {\n            this._wall = new DungeonWall(this.dungeon, this.x, this.y, name);\n        }\n    }\n    get wall() {\n        return this._wall;\n    }\n    set dropItem(drop) {\n        var _a;\n        (_a = this._drop) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._drop = null;\n        if (drop) {\n            this._drop = new dungeon_map_DungeonDrop(this.dungeon, this.x, this.y, drop);\n        }\n    }\n    get drop() {\n        return this._drop;\n    }\n    get hasDrop() {\n        return !!this._drop;\n    }\n    randomDrop() {\n        const rng = this.dungeon.rng;\n        const resources = this.dungeon.controller.resources;\n        const weight_coins = 20;\n        const weight_health_flask = 10;\n        const weight_health_big_flask = 10;\n        const weight_weapon = 10;\n        const sum = weight_coins + weight_health_flask + weight_health_big_flask + weight_weapon;\n        let remaining_distance = rng.nextFloat() * sum;\n        if ((remaining_distance -= weight_weapon) <= 0) {\n            this.dropItem = src_drop[\"Weapon\"].create(resources, rng, this.dungeon.level);\n        }\n        else if ((remaining_distance -= weight_health_big_flask) <= 0) {\n            this.dropItem = new src_drop[\"HealthBigFlask\"](resources);\n        }\n        else if ((remaining_distance -= weight_health_flask) <= 0) {\n            this.dropItem = new src_drop[\"HealthFlask\"](resources);\n        }\n        else if ((remaining_distance - weight_coins) <= 0) {\n            this.dropItem = new src_drop[\"Coins\"](rng, resources);\n        }\n        return this.hasDrop;\n    }\n    get object() {\n        return this._object;\n    }\n    set object(object) {\n        if (object && !(this._object === null || this._object === object)) {\n            console.log(\"current char\", this._object);\n            console.log(\"new char\", object);\n            throw \"error while set char to cell\";\n        }\n        this._object = object;\n    }\n    get hasObject() {\n        return this._object != null;\n    }\n    ladder() {\n        var _a;\n        (_a = this._floor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._floor = new DungeonLadder(this.dungeon, this.x, this.y);\n    }\n    get interacting() {\n        var _a, _b, _c, _d;\n        return ((_a = this._floor) === null || _a === void 0 ? void 0 : _a.interacting) || ((_b = this._wall) === null || _b === void 0 ? void 0 : _b.interacting) || ((_c = this._drop) === null || _c === void 0 ? void 0 : _c.interacting) || ((_d = this._object) === null || _d === void 0 ? void 0 : _d.interacting) || false;\n    }\n    interact(hero) {\n        if (this._object && this._object.interacting) {\n            this._object.interact(hero);\n        }\n        else if (this._drop && this._drop.interacting) {\n            this._drop.interact(hero);\n        }\n        else if (this._wall && this._wall.interacting) {\n            this._wall.interact(hero);\n        }\n        else if (this._floor && this._floor.interacting) {\n            this._floor.interact(hero);\n        }\n    }\n    collide(object) {\n        return (this._object && this._object.collide(object)) ||\n            (this._wall && this._wall.collide(object)) ||\n            false;\n    }\n}\nclass DungeonFloor {\n    constructor(dungeon, x, y, name) {\n        this.height = 1;\n        this.width = 1;\n        this.static = true;\n        this.dungeon = dungeon;\n        this.x = x;\n        this.y = y;\n        this.name = name;\n        this.sprite = dungeon.sprite(x, y, name);\n        this.sprite.zIndex = DungeonZIndexes.floor;\n    }\n    collide(_) {\n        return false;\n    }\n    destroy() {\n        this.sprite.destroy();\n    }\n}\nclass DefaultDungeonFloor extends DungeonFloor {\n    constructor(dungeon, x, y, name) {\n        super(dungeon, x, y, name);\n        this.interacting = false;\n    }\n    interact(_) {\n    }\n}\nclass DungeonLadder extends DungeonFloor {\n    constructor(dungeon, x, y) {\n        super(dungeon, x, y, 'floor_ladder.png');\n        this.interacting = true;\n    }\n    interact(hero) {\n        this.dungeon.controller.updateHero(hero.character, this.dungeon.level + 1);\n    }\n}\nclass DungeonWall {\n    constructor(dungeon, x, y, name) {\n        this.height = 1;\n        this.width = 1;\n        this.static = true;\n        this.interacting = false;\n        this.dungeon = dungeon;\n        this.x = x;\n        this.y = y;\n        this.name = name;\n        this.sprite = dungeon.sprite(x, y, name);\n        this.sprite.zIndex = DungeonZIndexes.wall + y * DungeonZIndexes.row;\n    }\n    interact(_) {\n    }\n    collide(_) {\n        return !this.dungeon.cell(this.x, this.y).hasFloor;\n    }\n    destroy() {\n        this.sprite.destroy();\n    }\n}\nclass dungeon_map_DungeonDrop {\n    constructor(dungeon, x, y, drop) {\n        this.height = 1;\n        this.width = 1;\n        this.static = true;\n        this.interacting = true;\n        this.dungeon = dungeon;\n        this.x = x;\n        this.y = y;\n        this.drop = drop;\n        this.sprite = dungeon.sprite(x, y, drop.spriteName);\n        this.sprite.zIndex = DungeonZIndexes.drop + y * DungeonZIndexes.row;\n        this.sprite.x += (dungeon_map_TILE_SIZE >> 1);\n        this.sprite.y += dungeon_map_TILE_SIZE - 2;\n        this.sprite.anchor.set(0.5, 1);\n        if (this.sprite instanceof external_PIXI_[\"AnimatedSprite\"]) {\n            this.sprite.animationSpeed = 0.2;\n            this.sprite.play();\n        }\n    }\n    pickedUp(hero) {\n        if (this.drop.pickedUp(hero)) {\n            this.dungeon.cell(this.x, this.y).dropItem = null;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    interact(_) {\n    }\n    collide(_) {\n        return false;\n    }\n    destroy() {\n        this.sprite.destroy();\n    }\n}\nclass dungeon_map_DungeonTitle extends external_PIXI_[\"Container\"] {\n    constructor() {\n        super();\n        this.title = new external_PIXI_[\"BitmapText\"](\"\", { font: { name: 'alagard', size: 32 } });\n        this.title.anchor = 0.5;\n        this.title.position.set(0, 16);\n        this.addChild(this.title);\n    }\n    set level(level) {\n        this.title.text = `LEVEL ${level}`;\n    }\n    destroy() {\n        this.title.destroy();\n    }\n}\n\n// EXTERNAL MODULE: ./src/inventory.ts\nvar inventory = __webpack_require__(\"./src/inventory.ts\");\n\n// EXTERNAL MODULE: ./src/observable.ts\nvar observable = __webpack_require__(\"./src/observable.ts\");\n\n// EXTERNAL MODULE: ./src/curves.ts\nvar curves = __webpack_require__(\"./src/curves.ts\");\n\n// CONCATENATED MODULE: ./src/pathfinding.ts\n\nvar Heuristic;\n(function (Heuristic) {\n    Heuristic[Heuristic[\"Manhattan\"] = 0] = \"Manhattan\";\n    Heuristic[Heuristic[\"Euclidean\"] = 1] = \"Euclidean\";\n    Heuristic[Heuristic[\"Chebyshev\"] = 2] = \"Chebyshev\";\n    Heuristic[Heuristic[\"Octile\"] = 3] = \"Octile\";\n})(Heuristic || (Heuristic = {}));\nclass Node {\n    constructor(parent, position) {\n        this.g = 0;\n        this.h = 0;\n        this.f = 0;\n        this.parent = parent;\n        this.position = position;\n    }\n    equal(other) {\n        return this.position.equals(other.position);\n    }\n}\nclass pathfinding_PathFinding {\n    constructor(width, height, diagonalAllowed = true, includeStart = false, includeEnd = false, heuristic = Heuristic.Chebyshev, weight = 1) {\n        this.map = [];\n        this.weight = 1;\n        this.width = width;\n        this.height = height;\n        this.diagonalAllowed = diagonalAllowed;\n        this.includeStart = includeStart;\n        this.includeEnd = includeEnd;\n        this.heuristic = heuristic;\n        this.weight = weight;\n        for (let x = 0; x < width; x++) {\n            const row = [];\n            this.map.push(row);\n            for (let y = 0; y < height; y++) {\n                row.push(1);\n            }\n        }\n    }\n    clear(x, y) {\n        this.map[x][y] = 0;\n    }\n    mark(x, y) {\n        this.map[x][y] = 1;\n    }\n    find(start, end) {\n        let start_node = new Node(null, start);\n        let end_node = new Node(null, end);\n        let open_list = [];\n        let closed_list = [];\n        open_list.push(start_node);\n        while (open_list.length > 0) {\n            let current_node = open_list[0];\n            let current_index = 0;\n            for (let i = 1; i < open_list.length; i++) {\n                let item = open_list[i];\n                if (item.f < current_node.f) {\n                    current_node = item;\n                    current_index = i;\n                }\n            }\n            open_list.splice(current_index, 1);\n            closed_list.push(current_node);\n            if (current_node.equal(end_node)) {\n                const path = [];\n                let current;\n                if (this.includeEnd) {\n                    current = current_node;\n                }\n                else {\n                    current = current_node.parent;\n                }\n                while (current.parent !== null) {\n                    path.push(current.position);\n                    current = current.parent;\n                }\n                if (this.includeStart) {\n                    path.push(current.position);\n                }\n                return path.reverse();\n            }\n            const children = [];\n            const squares = this.diagonalAllowed ? pathfinding_PathFinding.adjacentSquaresDiagonal : pathfinding_PathFinding.adjacentSquares;\n            for (let i = 0; i < squares.length; i++) {\n                let new_position = squares[i];\n                let node_position = new external_PIXI_[\"Point\"](current_node.position.x + new_position.x, current_node.position.y + new_position.y);\n                if (node_position.x >= this.width || node_position.x < 0 ||\n                    node_position.y >= this.height || node_position.y < 0) {\n                    continue;\n                }\n                if (this.map[node_position.x][node_position.y] != 0) {\n                    continue;\n                }\n                let new_node = new Node(current_node, node_position);\n                children.push(new_node);\n            }\n            for (let i = 0; i < children.length; i++) {\n                let child = children[i];\n                if (closed_list.find(c => c.equal(child)) != null) {\n                    continue;\n                }\n                child.g = current_node.g + 1;\n                child.h = this.heuristicFunction(child.position, end_node.position);\n                child.f = child.g + child.h;\n                if (open_list.find(c => c.equal(child)) != null) {\n                    continue;\n                }\n                open_list.push(child);\n            }\n        }\n        return [];\n    }\n    heuristicFunction(pos0, pos1) {\n        let dx = Math.abs(pos1.x - pos0.x);\n        let dy = Math.abs(pos1.y - pos0.y);\n        switch (this.heuristic) {\n            case Heuristic.Manhattan:\n                return (dx + dy) * this.weight;\n            case Heuristic.Euclidean:\n                return Math.sqrt(dx * dx + dy * dy) * this.weight;\n            case Heuristic.Chebyshev:\n                return Math.max(dx, dy) * this.weight;\n            case Heuristic.Octile:\n                return (dx + dy - 0.58 * Math.min(dx, dy)) * this.weight;\n        }\n    }\n}\npathfinding_PathFinding.adjacentSquares = [\n    new external_PIXI_[\"Point\"](0, -1),\n    new external_PIXI_[\"Point\"](0, 1),\n    new external_PIXI_[\"Point\"](-1, 0),\n    new external_PIXI_[\"Point\"](1, 0),\n];\npathfinding_PathFinding.adjacentSquaresDiagonal = [\n    new external_PIXI_[\"Point\"](0, -1),\n    new external_PIXI_[\"Point\"](0, 1),\n    new external_PIXI_[\"Point\"](-1, 0),\n    new external_PIXI_[\"Point\"](1, 0),\n    new external_PIXI_[\"Point\"](-1, -1),\n    new external_PIXI_[\"Point\"](-1, 1),\n    new external_PIXI_[\"Point\"](1, -1),\n    new external_PIXI_[\"Point\"](1, 1)\n];\n\n// CONCATENATED MODULE: ./src/character.ts\n\n\n\n\n\nconst character_TILE_SIZE = 16;\nclass character_Character {\n    constructor(options) {\n        this.name = options.name;\n        this._speed = new observable[\"ObservableVar\"](options.speed);\n        this._healthMax = new observable[\"ObservableVar\"](options.healthMax);\n        this._health = new observable[\"ObservableVar\"](options.healthMax);\n        this._dead = new observable[\"ObservableVar\"](false);\n        this._killedBy = new observable[\"ObservableVar\"](null);\n    }\n    get speed() {\n        return this._speed.get();\n    }\n    get healthMax() {\n        return this._healthMax;\n    }\n    get health() {\n        return this._health;\n    }\n    get dead() {\n        return this._dead;\n    }\n    get killedBy() {\n        return this._killedBy;\n    }\n    heal(health) {\n        this._health.update(h => Math.min(this._healthMax.get(), h + health));\n    }\n    hitDamage(by, damage) {\n        if (!this._dead.get()) {\n            this._health.update((h) => Math.max(0, h - damage));\n            if (this._health.get() === 0) {\n                this._killedBy.set(by);\n                this._dead.set(true);\n            }\n        }\n    }\n}\nvar ScanDirection;\n(function (ScanDirection) {\n    ScanDirection[ScanDirection[\"LEFT\"] = 1] = \"LEFT\";\n    ScanDirection[ScanDirection[\"RIGHT\"] = 2] = \"RIGHT\";\n    ScanDirection[ScanDirection[\"AROUND\"] = 4] = \"AROUND\";\n})(ScanDirection || (ScanDirection = {}));\nclass character_BaseCharacterAI {\n    constructor(dungeon, options) {\n        this.static = false;\n        this._animation = null;\n        this.dungeon = dungeon;\n        this.width = options.width;\n        this.height = options.height;\n        this._x = options.x;\n        this._y = options.y;\n        this.view = new character_BaseCharacterView(dungeon, options.zIndex, options.width, options.on_position);\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n    set animation(animation) {\n        var _a;\n        (_a = this._animation) === null || _a === void 0 ? void 0 : _a.cancel();\n        this._animation = animation;\n        this._animation.run();\n    }\n    get animation() {\n        return this._animation;\n    }\n    init() {\n        this.setPosition(this._x, this._y);\n        this.character.killedBy.subscribe(this.handleKilledBy, this);\n        this.character.dead.subscribe(this.handleDead, this);\n        this.idle();\n    }\n    destroy() {\n        var _a;\n        (_a = this._animation) === null || _a === void 0 ? void 0 : _a.cancel();\n        this.character.killedBy.unsubscribe(this.handleKilledBy, this);\n        this.character.dead.unsubscribe(this.handleDead, this);\n        this.dungeon.remove(this._x, this._y, this);\n        this.view.destroy();\n    }\n    collide(object) {\n        return this !== object;\n    }\n    handleKilledBy(by) {\n        if (by)\n            this.onKilledBy(by);\n    }\n    handleDead(dead) {\n        if (dead) {\n            this.onDead();\n        }\n    }\n    findDropCell(max_distance = 5) {\n        return this.findCell(max_distance, cell => cell.hasFloor && !cell.hasObject && !cell.hasDrop);\n    }\n    findSpawnCell(max_distance = 5) {\n        return this.findCell(max_distance, cell => cell.hasFloor && !cell.hasObject);\n    }\n    findCell(max_distance, predicate) {\n        const pos_x = this.x;\n        const pos_y = this.y;\n        const is_left = this.view.is_left;\n        let closestCell = null;\n        let closestDistance = null;\n        const metric = (a) => {\n            return Math.max(Math.abs(a.x - pos_x), Math.abs(a.y - pos_y)) +\n                (a.y !== pos_y ? 0.5 : 0) +\n                (a.x === pos_x && a.y === pos_y ? 0 : 1) +\n                (is_left ? (a.x < pos_x ? 0 : 1) : (a.x > pos_x ? 0 : 0.5));\n        };\n        const min_x = Math.max(0, pos_x - max_distance);\n        const max_x = Math.min(this.dungeon.width - 1, pos_x + max_distance);\n        const min_y = Math.max(0, pos_y - max_distance);\n        const max_y = Math.min(this.dungeon.width - 1, pos_y + max_distance);\n        for (let x = min_x; x <= max_x; x++) {\n            for (let y = min_y; y <= max_y; y++) {\n                const cell = this.dungeon.cell(x, y);\n                if (cell.hasFloor && predicate(cell)) {\n                    const distance = metric(cell);\n                    if (closestDistance === null || closestDistance > distance) {\n                        closestCell = cell;\n                        closestDistance = distance;\n                    }\n                }\n            }\n        }\n        return closestCell;\n    }\n    move(mx, my) {\n        if (mx > 0)\n            this.view.is_left = false;\n        if (mx < 0)\n            this.view.is_left = true;\n        const new_x = this.x + mx;\n        const new_y = this.y + my;\n        if (this.dungeon.available(new_x, new_y, this)) {\n            this.run(new_x, new_y);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    findPath(character) {\n        const dungeon = this.dungeon;\n        const pf = new pathfinding_PathFinding(dungeon.width, dungeon.height);\n        for (let y = 0; y < dungeon.height; y++) {\n            for (let x = 0; x < dungeon.width; x++) {\n                const cell = dungeon.cell(x, y);\n                const m = cell.object;\n                if (cell.hasFloor && (!cell.collide(this) || m === character)) {\n                    pf.clear(x, y);\n                }\n                else {\n                    pf.mark(x, y);\n                }\n            }\n        }\n        const start = new external_PIXI_[\"Point\"](this.x, this.y);\n        const end = new external_PIXI_[\"Point\"](character.x, character.y);\n        return pf.find(start, end);\n    }\n    idle() {\n        this.animation = new IdleAnimation(this, this.dungeon.ticker, {\n            sprite: this.character.name + '_idle',\n            speed: this.character.speed,\n            update: (animation) => {\n                if (this.action(false)) {\n                    animation.cancel();\n                }\n            },\n            finish: () => {\n                if (!this.action(true)) {\n                    this.idle();\n                }\n            }\n        });\n    }\n    run(new_x, new_y) {\n        this.animation = new RunAnimation(this, this.dungeon.ticker, {\n            new_x: new_x,\n            new_y: new_y,\n            sprite: this.character.name + '_run',\n            speed: this.character.speed,\n            finish: () => {\n                if (!this.action(true)) {\n                    this.idle();\n                }\n            }\n        });\n    }\n    hit() {\n        const weapon = this.character.weapon;\n        this.animation = new HitAnimation(this, this.dungeon.ticker, {\n            sprite: this.character.name + '_idle',\n            speed: (weapon === null || weapon === void 0 ? void 0 : weapon.speed) || this.character.speed,\n            curve: weapon === null || weapon === void 0 ? void 0 : weapon.curve,\n            finish: () => {\n                this.scanHit();\n                if (!this.action(true)) {\n                    this.idle();\n                }\n            },\n        });\n    }\n    setPosition(x, y) {\n        this.dungeon.remove(this._x, this._y, this);\n        this._x = Math.floor(x);\n        this._y = Math.floor(y);\n        this.dungeon.set(this._x, this._y, this);\n        this.view.setPosition(x, y);\n    }\n    lookAt(character) {\n        if (character.x < this.x)\n            this.view.is_left = true;\n        if (character.x > this.x)\n            this.view.is_left = false;\n    }\n    scanObjects(direction, max_distance, predicate) {\n        const objects = this.scanCells(direction, max_distance, cell => cell.hasObject && predicate(cell.object))\n            .map(cell => cell.object);\n        const set = new Set(objects);\n        return [...set];\n    }\n    scanCells(direction, max_distance, predicate) {\n        const pos_x = this.x;\n        const pos_y = this.y;\n        const scan_left = direction === ScanDirection.AROUND || direction === ScanDirection.LEFT;\n        const scan_right = direction === ScanDirection.AROUND || direction === ScanDirection.RIGHT;\n        const scan_x_min = scan_left ? Math.max(0, pos_x - max_distance) : pos_x;\n        const scan_x_max = scan_right ? Math.min(this.dungeon.width - 1, pos_x + max_distance) : pos_x;\n        const scan_y_min = Math.max(0, pos_y - max_distance);\n        const scan_y_max = Math.min(this.dungeon.height - 1, pos_y + max_distance);\n        const cells = [];\n        for (let s_y = scan_y_min; s_y <= scan_y_max; s_y++) {\n            for (let s_x = scan_x_min; s_x <= scan_x_max; s_x++) {\n                const cell = this.dungeon.cell(s_x, s_y);\n                if (predicate(cell)) {\n                    cells.push(cell);\n                }\n            }\n        }\n        return cells;\n    }\n    raycastIsVisible(x1, y1) {\n        let x0 = this.x;\n        let y0 = this.y;\n        const dx = Math.abs(x1 - x0);\n        const dy = Math.abs(y1 - y0);\n        const sx = x0 < x1 ? 1 : -1;\n        const sy = y0 < y1 ? 1 : -1;\n        let err = (dx > dy ? dx : -dy) / 2;\n        while (true) {\n            if (x0 === x1 && y0 === y1)\n                break;\n            let e2 = err;\n            if (e2 > -dx) {\n                err -= dy;\n                x0 += sx;\n            }\n            if (e2 < dy) {\n                err += dx;\n                y0 += sy;\n            }\n            if (x0 === x1 && y0 === y1)\n                break;\n            const cell = this.dungeon.cell(x0, y0);\n            if (!cell.hasFloor)\n                return false;\n            if (cell.collide(this))\n                return false;\n        }\n        return true;\n    }\n}\nclass character_Animation {\n    constructor(character, ticker, options) {\n        this._spriteTime = 0;\n        this._spritePlay = false;\n        this._terminated = false;\n        this.character = character;\n        this.view = character.view;\n        this.ticker = ticker;\n        this.sprite = options.sprite;\n        this.speed = options.speed;\n        this.curve = options.curve || curves[\"LinearCurve\"].line();\n        this.on_start = options.start || null;\n        this.on_update = options.update || null;\n        this.on_frame = options.frame || null;\n        this.on_cancel = options.cancel || null;\n        this.on_finish = options.finish;\n    }\n    get spriteTime() {\n        return this._spriteTime;\n    }\n    run() {\n        this._spritePlay = true;\n        this._terminated = false;\n        this.start();\n        this.ticker.add(this.tick, this);\n        if (this.on_start)\n            this.on_start(this);\n    }\n    cancel() {\n        if (!this._terminated) {\n            this.terminate();\n            this.canceled();\n            if (this.on_cancel)\n                this.on_cancel(this);\n        }\n    }\n    tick(deltaTime) {\n        this.updateSprite(deltaTime);\n        this.update();\n        if (this.on_update)\n            this.on_update(this);\n        if (!this._terminated && !this._spritePlay) {\n            this.terminate();\n            this.finish();\n            if (this.on_finish)\n                this.on_finish(this);\n            console.assert(this.character.animation !== this);\n        }\n    }\n    terminate() {\n        if (!this._terminated) {\n            this._terminated = true;\n            this.ticker.remove(this.tick, this);\n        }\n    }\n    updateSprite(deltaTime) {\n        const sprite = this.view.sprite;\n        if (!sprite) {\n            console.warn(\"no sprite found\");\n            this._spriteTime = 0;\n            this._spritePlay = false;\n            return;\n        }\n        const elapsed = sprite.animationSpeed * deltaTime;\n        const previousFrame = sprite.currentFrame;\n        this._spriteTime += elapsed;\n        let currentFrame = Math.floor(this._spriteTime) % sprite.totalFrames;\n        if (currentFrame < 0) {\n            currentFrame += sprite.totalFrames;\n        }\n        if (this._spriteTime < 0) {\n            this._spriteTime = 0;\n            this._spritePlay = false;\n        }\n        else if (this._spriteTime >= sprite.totalFrames) {\n            this._spriteTime = sprite.totalFrames - 1;\n            this._spritePlay = false;\n        }\n        else if (previousFrame !== currentFrame) {\n            sprite.gotoAndStop(currentFrame);\n            if (this.on_frame)\n                this.on_frame(this);\n        }\n    }\n}\nclass IdleAnimation extends character_Animation {\n    constructor(character, ticker, options) {\n        super(character, ticker, options);\n    }\n    start() {\n        this.view.setSprite(this.sprite, this.speed);\n    }\n    update() {\n    }\n    finish() {\n    }\n    canceled() {\n    }\n}\nclass RunAnimation extends character_Animation {\n    constructor(character, ticker, options) {\n        super(character, ticker, options);\n        this.x = character.x;\n        this.y = character.y;\n        this.new_x = options.new_x;\n        this.new_y = options.new_y;\n    }\n    start() {\n        this.view.setSprite(this.sprite, this.speed);\n        this.character.dungeon.set(this.new_x, this.new_y, this.character);\n    }\n    update() {\n        const delta = this.spriteTime / this.view.sprite.totalFrames;\n        const pos_x = this.x + (this.new_x - this.x) * delta;\n        const pos_y = this.y + (this.new_y - this.y) * delta;\n        this.character.view.setPosition(pos_x, pos_y);\n    }\n    finish() {\n        this.character.dungeon.remove(this.x, this.y, this.character);\n        this.character.dungeon.remove(this.new_x, this.new_y, this.character);\n        this.character.setPosition(this.new_x, this.new_y);\n    }\n    canceled() {\n        this.character.dungeon.remove(this.x, this.y, this.character);\n        this.character.dungeon.remove(this.new_x, this.new_y, this.character);\n        this.character.setPosition(this.character.x, this.character.y);\n    }\n}\nclass HitAnimation extends character_Animation {\n    constructor(character, ticker, options) {\n        super(character, ticker, options);\n    }\n    start() {\n        this.view.setSprite(this.sprite, this.speed);\n    }\n    update() {\n        const weapon = this.view.weaponSprite;\n        if (weapon) {\n            const sprite = this.view.sprite;\n            const delta = this._spriteTime / sprite.totalFrames;\n            const curveDelta = this.curve(delta);\n            weapon.angle = (this.view.is_left ? -90 : 90) * curveDelta;\n        }\n    }\n    finish() {\n        const weapon = this.view.weaponSprite;\n        if (weapon) {\n            weapon.angle = 0;\n        }\n    }\n    canceled() {\n    }\n}\nclass character_BaseCharacterView extends external_PIXI_[\"Container\"] {\n    constructor(dungeon, zIndex, grid_width, on_position) {\n        super();\n        this._is_left = false;\n        this._sprite = null;\n        this._weaponSprite = null;\n        this.resources = dungeon.controller.resources;\n        this.base_zIndex = zIndex;\n        this.grid_width = grid_width;\n        this.on_position = on_position || null;\n        dungeon.container.addChild(this);\n    }\n    get is_left() {\n        return this._is_left;\n    }\n    set is_left(is_left) {\n        this._is_left = is_left;\n        this.updateSpriteOrientation();\n        this.updateWeaponOrientation();\n    }\n    get sprite() {\n        return this._sprite;\n    }\n    get weaponSprite() {\n        return this._weaponSprite;\n    }\n    destroy() {\n        var _a, _b;\n        (_a = this._sprite) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._sprite = null;\n        (_b = this._weaponSprite) === null || _b === void 0 ? void 0 : _b.destroy();\n        this._weaponSprite = null;\n        super.destroy();\n    }\n    setPosition(x, y) {\n        this.position.set(x * character_TILE_SIZE, y * character_TILE_SIZE);\n        this.zIndex = this.base_zIndex + Math.floor(y) * DungeonZIndexes.row;\n        if (this.on_position) {\n            this.on_position(x * character_TILE_SIZE, y * character_TILE_SIZE);\n        }\n    }\n    setSprite(name, speed) {\n        var _a;\n        (_a = this._sprite) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._sprite = this.resources.animated(name, false);\n        this._sprite.loop = false;\n        this._sprite.animationSpeed = 0.2 * speed;\n        this._sprite.anchor.set(0, 1);\n        this._sprite.position.y = character_TILE_SIZE - 2;\n        this._sprite.zIndex = 1;\n        this.addChild(this._sprite);\n        this.updateSpriteOrientation();\n        this.updateWeaponOrientation();\n    }\n    setWeapon(weapon) {\n        var _a;\n        (_a = this._weaponSprite) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._weaponSprite = null;\n        if (weapon) {\n            this._weaponSprite = weapon.sprite();\n            this._weaponSprite.zIndex = 2;\n            this._weaponSprite.position.x = character_TILE_SIZE;\n            this._weaponSprite.position.y = character_TILE_SIZE - 4;\n            if (this.is_left) {\n                this._weaponSprite.position.x = 0;\n                this._weaponSprite.scale.x = -1;\n            }\n            this._weaponSprite.anchor.set(0.5, 1);\n            this.addChild(this._weaponSprite);\n            this.sortChildren();\n        }\n    }\n    updateSpriteOrientation() {\n        if (this._sprite) {\n            if (this._is_left) {\n                this._sprite.position.x = this._sprite.width;\n                if (this._sprite.width > this.grid_width * character_TILE_SIZE) {\n                    this._sprite.position.x -= (this._sprite.width - this.grid_width * character_TILE_SIZE) / 2;\n                }\n                this._sprite.scale.x = -1;\n            }\n            else {\n                this._sprite.position.x = 0;\n                if (this._sprite.width > this.grid_width * character_TILE_SIZE) {\n                    this._sprite.position.x -= (this._sprite.width - this.grid_width * character_TILE_SIZE) / 2;\n                }\n                this._sprite.scale.x = 1;\n            }\n        }\n    }\n    updateWeaponOrientation() {\n        if (this._weaponSprite) {\n            if (this.is_left) {\n                this._weaponSprite.position.x = 0;\n                this._weaponSprite.scale.x = -1;\n            }\n            else {\n                this._weaponSprite.position.x = character_TILE_SIZE;\n                this._weaponSprite.scale.x = 1;\n            }\n        }\n    }\n}\n\n// EXTERNAL MODULE: ./src/ui.ts\nvar ui = __webpack_require__(\"./src/ui.ts\");\n\n// CONCATENATED MODULE: ./src/bar.view.ts\n\n\nconst BAR_HEIGHT = 18;\nclass bar_view_BarView extends external_PIXI_[\"Container\"] {\n    constructor(options) {\n        super();\n        this._color = options.color;\n        this._width = options.width || 0;\n        this._widthMax = options.widthMax;\n        this._rect = new external_PIXI_[\"Graphics\"]();\n        this._labelCenter = options.labelCenter || false;\n        this._label = new external_PIXI_[\"BitmapText\"](\"\", { font: { name: \"alagard\", size: 16 } });\n        this._label.anchor = new external_PIXI_[\"Point\"](this._labelCenter ? 0.5 : 0, 0.5);\n        this._label.position.set((ui[\"Sizes\"].uiBorder << 1) + (this._labelCenter ? this._widthMax >> 1 : 0), ui[\"Sizes\"].uiBorder + (BAR_HEIGHT >> 1));\n        super.addChild(this._rect, this._label);\n    }\n    set color(color) {\n        this._color = color;\n        this.updateRect();\n    }\n    set width(width) {\n        this._width = width;\n        this.updateRect();\n    }\n    set label(text) {\n        this._label.text = text;\n    }\n    set widthMax(widthMax) {\n        this._widthMax = widthMax;\n        this._label.position.set((ui[\"Sizes\"].uiBorder << 1) + (this._labelCenter ? this._widthMax >> 1 : 0), ui[\"Sizes\"].uiBorder + (BAR_HEIGHT >> 1));\n        this.updateRect();\n    }\n    updateRect() {\n        this._rect.clear()\n            .beginFill(ui[\"Colors\"].uiBackground, 0.3)\n            .drawRect(0, 0, this._widthMax + (ui[\"Sizes\"].uiBorder << 1), BAR_HEIGHT + (ui[\"Sizes\"].uiBorder << 1))\n            .endFill()\n            .beginFill(this._color, 0.3)\n            .drawRect(ui[\"Sizes\"].uiBorder, ui[\"Sizes\"].uiBorder, this._width, BAR_HEIGHT)\n            .endFill();\n    }\n}\n\n// CONCATENATED MODULE: ./src/monster.ts\n\n\nvar MonsterCategory;\n(function (MonsterCategory) {\n    MonsterCategory[MonsterCategory[\"DEMON\"] = 1] = \"DEMON\";\n    MonsterCategory[MonsterCategory[\"ZOMBIE\"] = 2] = \"ZOMBIE\";\n    MonsterCategory[MonsterCategory[\"ORC\"] = 3] = \"ORC\";\n    MonsterCategory[MonsterCategory[\"SLIME\"] = 4] = \"SLIME\";\n    MonsterCategory[MonsterCategory[\"UNDEAD\"] = 5] = \"UNDEAD\";\n})(MonsterCategory || (MonsterCategory = {}));\nvar MonsterType;\n(function (MonsterType) {\n    MonsterType[MonsterType[\"NORMAL\"] = 1] = \"NORMAL\";\n    MonsterType[MonsterType[\"LEADER\"] = 2] = \"LEADER\";\n    MonsterType[MonsterType[\"MINION\"] = 3] = \"MINION\";\n})(MonsterType || (MonsterType = {}));\nvar MonsterState;\n(function (MonsterState) {\n    MonsterState[MonsterState[\"READY\"] = 0] = \"READY\";\n    MonsterState[MonsterState[\"ALARM\"] = 1] = \"ALARM\";\n})(MonsterState || (MonsterState = {}));\nclass monster_MonsterCharacter extends character_Character {\n    constructor(options) {\n        super(options);\n        this.level = options.level;\n        this.luck = options.luck;\n        this.baseDamage = options.baseDamage;\n        this.xp = options.xp;\n        this.category = options.category;\n        this.type = options.type;\n        this.spawn = options.spawn;\n        this.weapon = options.weapon;\n    }\n    get damage() {\n        var _a;\n        return this.baseDamage + (((_a = this.weapon) === null || _a === void 0 ? void 0 : _a.damage) || 0);\n    }\n}\nclass monster_MonsterAI extends character_BaseCharacterAI {\n    constructor(dungeon, options) {\n        super(dungeon, options);\n        this.interacting = false;\n        this._state = MonsterState.READY;\n        this.last_path = [];\n        this.spawned = [];\n    }\n    interact() {\n    }\n    onKilledBy(by) {\n        if (by && by instanceof hero_Hero) {\n            this.dungeon.log(`${this.character.name} killed by ${by.name}`);\n            by.addXp(this.character.xp);\n        }\n    }\n    onDead() {\n        this.drop();\n        this.destroy();\n    }\n    ready() {\n        this._state = MonsterState.READY;\n    }\n    sendAlarm(hero) {\n        this._state = MonsterState.ALARM;\n        for (const monster of this.scanMonsters(ScanDirection.AROUND, this.max_distance)) {\n            monster.alarm(hero);\n        }\n    }\n    alarm(hero) {\n        if (!this.character.dead.get() &&\n            this.character.type !== MonsterType.LEADER &&\n            this._state === MonsterState.READY &&\n            this.animation instanceof IdleAnimation) {\n            this.moveTo(hero);\n        }\n    }\n    get state() {\n        return this._state;\n    }\n    randomMove() {\n        const random_move_percent = 0.1;\n        if (Math.random() < random_move_percent) {\n            const move_x = Math.floor(Math.random() * 3) - 1;\n            const move_y = Math.floor(Math.random() * 3) - 1;\n            if (this.move(move_x, move_y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    moveToHero() {\n        const [hero] = this.scanHero(ScanDirection.AROUND, this.max_distance);\n        if (hero) {\n            this.lookAt(hero);\n            this.sendAlarm(hero);\n            const dist_x = Math.abs(this.x - hero.x);\n            const dist_y = Math.abs(this.y - hero.y);\n            if (dist_x > this.width || dist_y > this.height) {\n                return this.moveTo(hero);\n            }\n            else if (this.character.luck < this.dungeon.rng.nextFloat()) {\n                this.hit();\n                return true;\n            }\n        }\n        return false;\n    }\n    moveTo(character) {\n        this.last_path = this.findPath(character);\n        return this.moveByPath();\n    }\n    moveByPath() {\n        if (this.last_path.length > 0) {\n            const next = this.last_path[0];\n            const d_x = next.x - this.x;\n            const d_y = next.y - this.y;\n            if (this.move(d_x, d_y)) {\n                this.last_path.splice(0, 1);\n                return true;\n            }\n            else {\n                this.last_path = [];\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    scanHit() {\n        const weapon = this.character.weapon;\n        const direction = this.view.is_left ? ScanDirection.LEFT : ScanDirection.RIGHT;\n        const distance = (weapon === null || weapon === void 0 ? void 0 : weapon.distance) || 1;\n        const heroes = this.scanHero(direction, distance);\n        for (const hero of heroes) {\n            hero.character.hitDamage(this.character, this.character.damage);\n        }\n    }\n    spawnMinions() {\n        for (let i = this.spawned.length - 1; i >= 0; i--) {\n            if (this.spawned[i].character.dead.get()) {\n                this.spawned.splice(i, 1);\n            }\n        }\n        if (this.spawned.length < this.character.spawn) {\n            if (Math.random() > 0.1) {\n                return false;\n            }\n            const cell = this.findSpawnCell();\n            if (!cell) {\n                console.warn(`spawn cell not found at ${this.x}:${this.y}`, this.character.category, this.character.type);\n                return false;\n            }\n            const minion = this.spawnMinion(cell.x, cell.y);\n            if (minion) {\n                cell.object = minion;\n                this.spawned.push(minion);\n                return true;\n            }\n            else {\n                console.warn(\"minion not spawned\", this.character.category, this.character.type);\n                return false;\n            }\n        }\n        return false;\n    }\n    scanHero(direction, max_distance) {\n        return this.scanObjects(direction, max_distance, c => c instanceof hero_HeroAI)\n            .filter(o => this.raycastIsVisible(o.x, o.y));\n    }\n    scanMonsters(direction, max_distance) {\n        return this.scanObjects(direction, max_distance, c => c instanceof monster_MonsterAI);\n    }\n}\n\n// CONCATENATED MODULE: ./src/hero.ts\n\n\n\n\n\n\n\n\n\nconst heroCharacterNames = [\n    \"elf_f\",\n    \"elf_m\",\n    \"knight_f\",\n    \"knight_m\",\n    \"wizard_f\",\n    \"wizard_m\",\n];\nconst defaultGlobalState = {\n    coins: 0,\n    baseDamage: 3,\n    level: 1,\n    levelXp: 0,\n    skillPoints: 0,\n    xp: 0,\n    healthMax: 30,\n    speed: 1,\n};\nclass hero_Hero extends character_Character {\n    constructor(name, state, persistent) {\n        super({\n            name: name,\n            speed: state.speed,\n            healthMax: state.healthMax\n        });\n        this.inventory = new inventory[\"Inventory\"](this);\n        this.dungeonSeeds = new Map();\n        this.bonfires = new Set();\n        this.persistent = persistent;\n        this._coins = new observable[\"ObservableVar\"](state.coins);\n        this._baseDamage = new observable[\"ObservableVar\"](state.baseDamage);\n        this._level = new observable[\"ObservableVar\"](state.level);\n        this._levelXp = new observable[\"ObservableVar\"](state.levelXp);\n        this._skillPoints = new observable[\"ObservableVar\"](state.skillPoints);\n        this._xp = new observable[\"ObservableVar\"](state.xp);\n        this.subscribe();\n    }\n    get coins() {\n        return this._coins;\n    }\n    addCoins(coins) {\n        this._coins.update(c => c + coins);\n    }\n    get damage() {\n        var _a;\n        return this._baseDamage.get() + (((_a = this.weapon) === null || _a === void 0 ? void 0 : _a.damage) || 0);\n    }\n    get weapon() {\n        return this.inventory.equipment.weapon.item.get() || null;\n    }\n    get level() {\n        return this._level;\n    }\n    get levelXp() {\n        return this._levelXp;\n    }\n    get skillPoints() {\n        return this._skillPoints;\n    }\n    get xp() {\n        return this._xp;\n    }\n    addXp(value) {\n        this._xp.update((v) => {\n            let newXp = v + value;\n            while (true) {\n                const levelXp = this._levelXp.get();\n                if (newXp >= levelXp) {\n                    newXp = newXp - levelXp;\n                    this._level.update((v) => v + 1);\n                    this._levelXp.update((v) => v + 1000);\n                    this._skillPoints.update((v) => v + 1);\n                }\n                else {\n                    break;\n                }\n            }\n            return newXp;\n        });\n    }\n    increaseHealth() {\n        this._skillPoints.update((points) => {\n            if (points > 0) {\n                points--;\n                this._healthMax.update((h) => h + 1);\n                this._health.update((h) => h + 1);\n            }\n            return points;\n        });\n    }\n    subscribe() {\n        this._coins.subscribe(this.save, this);\n        this._baseDamage.subscribe(this.save, this);\n        this._level.subscribe(this.save, this);\n        this._levelXp.subscribe(this.save, this);\n        this._skillPoints.subscribe(this.save, this);\n        this._xp.subscribe(this.save, this);\n        this._healthMax.subscribe(this.save, this);\n        this._speed.subscribe(this.save, this);\n    }\n    save() {\n        this.persistent.global.save(this.name, this.state);\n    }\n    get state() {\n        return {\n            coins: this._coins.get(),\n            baseDamage: this._baseDamage.get(),\n            level: this._level.get(),\n            levelXp: this._levelXp.get(),\n            skillPoints: this._skillPoints.get(),\n            xp: this._xp.get(),\n            healthMax: this._healthMax.get(),\n            speed: this._speed.get(),\n        };\n    }\n    static load(name, persistent) {\n        let state = persistent.global.load(name) || defaultGlobalState;\n        return new hero_Hero(name, state, persistent);\n    }\n}\nclass hero_HeroAI extends character_BaseCharacterAI {\n    constructor(character, dungeon, x, y) {\n        super(dungeon, {\n            x: x,\n            y: y,\n            width: 1,\n            height: 1,\n            zIndex: DungeonZIndexes.hero,\n            on_position: dungeon.camera.bind(dungeon),\n        });\n        this.interacting = false;\n        this.character = character;\n        this.init();\n        this.character.inventory.equipment.weapon.item.subscribe(this.onWeaponUpdate, this);\n        this.character.inventory.drop.subscribe(this.onDrop, this);\n    }\n    destroy() {\n        super.destroy();\n        this.character.inventory.equipment.weapon.item.unsubscribe(this.onWeaponUpdate, this);\n        this.character.inventory.drop.unsubscribe(this.onDrop, this);\n    }\n    interact() {\n    }\n    onKilledBy(by) {\n        this.dungeon.log(`${this.character.name} killed by ${by.name}`);\n    }\n    onDead() {\n        this.dungeon.controller.dead();\n    }\n    onDrop(event) {\n        let [drop] = event;\n        const cell = this.findDropCell();\n        if (cell) {\n            cell.dropItem = drop;\n        }\n    }\n    onWeaponUpdate(weapon) {\n        this.view.setWeapon(weapon);\n    }\n    action(finished) {\n        if (!this.character.dead.get()) {\n            const idle = this.animation instanceof IdleAnimation;\n            if (finished) {\n                this.scanDrop();\n            }\n            const joystick = this.dungeon.controller.joystick;\n            if (idle && joystick.inventory.once()) {\n                this.dungeon.controller.showInventory(this.character);\n                this.idle();\n                return true;\n            }\n            for (let d = 0; d <= 9; d++) {\n                const digit = (d + 1) % 10;\n                if (joystick.digit(digit).once()) {\n                    const cell = this.character.inventory.belt.cell(d);\n                    const item = cell.item.get();\n                    if (item && (item instanceof src_drop[\"Weapon\"] || idle)) {\n                        cell.use();\n                    }\n                }\n            }\n            if (idle && joystick.drop.once()) {\n                this.character.inventory.equipment.weapon.drop();\n            }\n            if (idle || finished) {\n                const triggered = joystick.hit.triggered;\n                const once = joystick.hit.once();\n                if (once) {\n                    const direction = this.view.is_left ? ScanDirection.LEFT : ScanDirection.RIGHT;\n                    const [object] = this.scanInteracting(direction, 1);\n                    if (object) {\n                        this.idle();\n                        object.interact(this);\n                        return true;\n                    }\n                }\n                if (triggered || once) {\n                    this.lookAtMonsters();\n                    this.hit();\n                    return true;\n                }\n            }\n            if (idle || finished) {\n                const d_x = hero_HeroAI.delta(joystick.moveLeft, joystick.moveRight);\n                const d_y = hero_HeroAI.delta(joystick.moveUp, joystick.moveDown);\n                if (d_x !== 0 || d_y !== 0) {\n                    if (this.move(d_x, d_y)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    static delta(a, b) {\n        if (a.triggered) {\n            return -1;\n        }\n        else if (b.triggered) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    scanDrop() {\n        var _a;\n        const cell = this.dungeon.cell(this.x, this.y);\n        if ((_a = cell.drop) === null || _a === void 0 ? void 0 : _a.pickedUp(this.character)) {\n            external_PIXI_[\"sound\"].play('fruit_collect');\n        }\n    }\n    scanHit() {\n        const weapon = this.character.weapon;\n        const distance = (weapon === null || weapon === void 0 ? void 0 : weapon.distance) || 1;\n        const direction = this.view.is_left ? ScanDirection.LEFT : ScanDirection.RIGHT;\n        const monsters = this.scanMonsters(direction, distance);\n        for (let monster of monsters) {\n            monster.character.hitDamage(this.character, this.character.damage);\n        }\n        if (monsters.length > 0) {\n            external_PIXI_[\"sound\"].play('hit_damage', { speed: (weapon === null || weapon === void 0 ? void 0 : weapon.speed) || 1 });\n        }\n    }\n    lookAtMonsters() {\n        const weapon = this.character.weapon;\n        const distance = (weapon === null || weapon === void 0 ? void 0 : weapon.distance) || 1;\n        const leftHealthSum = this.monstersHealth(ScanDirection.LEFT, distance);\n        const rightHealthSum = this.monstersHealth(ScanDirection.RIGHT, distance);\n        if (leftHealthSum > 0 && leftHealthSum > rightHealthSum) {\n            this.view.is_left = true;\n        }\n        else if (rightHealthSum > 0 && rightHealthSum > leftHealthSum) {\n            this.view.is_left = false;\n        }\n    }\n    scanInteracting(direction, max_distance) {\n        return this.scanCells(direction, max_distance, c => c.interacting);\n    }\n    scanMonsters(direction, max_distance) {\n        return this.scanObjects(direction, max_distance, c => c instanceof monster_MonsterAI);\n    }\n    monstersHealth(direction, max_distance) {\n        return this.scanMonsters(direction, max_distance).map(m => m.character.health.get()).reduce((a, b) => a + b, 0);\n    }\n}\nclass hero_HeroStateView extends external_PIXI_[\"Container\"] {\n    constructor(heroState, options) {\n        super();\n        this.fixedHPSize = options.fixedHPSize;\n        this.hpBarSize = options.hpBarSize || 8;\n        this.maxBarSize = options.maxBarSize || 256;\n        this.maxBarInnerSize = this.maxBarSize - (ui[\"Sizes\"].uiBorder << 1);\n        const barHeight = 18 + (ui[\"Sizes\"].uiBorder << 1);\n        const offsetY = barHeight + ui[\"Sizes\"].uiMargin;\n        this.heroState = heroState;\n        this.health = new bar_view_BarView({\n            color: ui[\"Colors\"].uiRed,\n            width: 0,\n            widthMax: this.maxBarInnerSize\n        });\n        this.xp = new bar_view_BarView({\n            color: ui[\"Colors\"].uiYellow,\n            width: 0,\n            widthMax: this.maxBarInnerSize\n        });\n        this.xp.position.set(0, offsetY);\n        this.coins = new external_PIXI_[\"BitmapText\"](\"\", { font: { name: \"alagard\", size: 16 } });\n        this.coins.position.set(0, offsetY * 2);\n        super.addChild(this.health, this.xp, this.coins);\n        heroState.health.subscribe(this.updateHealth, this);\n        heroState.healthMax.subscribe(this.updateHealthMax, this);\n        heroState.level.subscribe(this.updateXp, this);\n        heroState.levelXp.subscribe(this.updateXp, this);\n        heroState.skillPoints.subscribe(this.updateXp, this);\n        heroState.xp.subscribe(this.updateXp, this);\n        heroState.coins.subscribe(this.updateCoins, this);\n    }\n    destroy() {\n        super.destroy();\n        this.heroState.health.unsubscribe(this.updateHealth, this);\n        this.heroState.healthMax.unsubscribe(this.updateHealthMax, this);\n        this.heroState.level.unsubscribe(this.updateXp, this);\n        this.heroState.levelXp.unsubscribe(this.updateXp, this);\n        this.heroState.skillPoints.unsubscribe(this.updateXp, this);\n        this.heroState.xp.unsubscribe(this.updateXp, this);\n        this.heroState.coins.unsubscribe(this.updateCoins, this);\n    }\n    updateHealthMax(healthMax) {\n        const health = this.heroState.health.get();\n        if (!this.fixedHPSize) {\n            this.health.widthMax = this.hpBarSize * healthMax;\n        }\n        this.health.label = `${health}/${healthMax}`;\n    }\n    updateHealth(health) {\n        const healthMax = this.heroState.healthMax.get();\n        if (this.fixedHPSize) {\n            this.health.width = Math.floor(this.maxBarInnerSize * health / healthMax);\n        }\n        else {\n            this.health.width = this.hpBarSize * health;\n        }\n        this.health.label = `${health}/${healthMax}`;\n    }\n    updateXp() {\n        const level = this.heroState.level.get();\n        const levelXp = this.heroState.levelXp.get();\n        const skillPoints = this.heroState.skillPoints.get();\n        const xp = this.heroState.xp.get();\n        this.xp.widthMax = this.maxBarInnerSize;\n        this.xp.width = Math.floor(this.maxBarInnerSize * xp / levelXp);\n        this.xp.label = `L:${level} XP:${xp}/${levelXp} SP:${skillPoints}`;\n    }\n    updateCoins(coins) {\n        this.coins.text = `$${coins}`;\n    }\n}\n\n// CONCATENATED MODULE: ./src/tiny.monster.ts\n\n\n\n\nconst tinyMonsters = [\n    { name: \"chort\", category: MonsterCategory.DEMON, type: MonsterType.NORMAL, luck: 0.3, weapons: [] },\n    { name: \"wogol\", category: MonsterCategory.DEMON, type: MonsterType.NORMAL, luck: 0.3, weapons: [] },\n    { name: \"imp\", category: MonsterCategory.DEMON, type: MonsterType.NORMAL, luck: 0.3, weapons: [] },\n    {\n        name: \"ice_zombie\",\n        category: MonsterCategory.ZOMBIE,\n        type: MonsterType.NORMAL,\n        luck: 0.3,\n        weapons: [src_drop[\"monsterWeapons\"].knife]\n    },\n    {\n        name: \"tiny_zombie\",\n        category: MonsterCategory.ZOMBIE,\n        type: MonsterType.NORMAL,\n        luck: 0.3,\n        weapons: [src_drop[\"monsterWeapons\"].knife]\n    },\n    {\n        name: \"zombie\",\n        category: MonsterCategory.ZOMBIE,\n        type: MonsterType.NORMAL,\n        luck: 0.3,\n        weapons: [src_drop[\"monsterWeapons\"].knife]\n    },\n    {\n        name: \"orc_shaman\",\n        category: MonsterCategory.ORC,\n        type: MonsterType.LEADER,\n        luck: 0.4,\n        weapons: [src_drop[\"monsterWeapons\"].knife]\n    },\n    {\n        name: \"masked_orc\",\n        category: MonsterCategory.ORC,\n        type: MonsterType.NORMAL,\n        luck: 0.3,\n        weapons: [src_drop[\"monsterWeapons\"].knife]\n    },\n    {\n        name: \"orc_warrior\",\n        category: MonsterCategory.ORC,\n        type: MonsterType.MINION,\n        luck: 0.3,\n        weapons: [src_drop[\"monsterWeapons\"].knife]\n    },\n    { name: \"goblin\", category: MonsterCategory.ORC, type: MonsterType.MINION, luck: 0.3, weapons: [src_drop[\"monsterWeapons\"].knife] },\n    { name: \"swampy\", category: MonsterCategory.SLIME, type: MonsterType.NORMAL, luck: 0.3, weapons: [] },\n    { name: \"muddy\", category: MonsterCategory.SLIME, type: MonsterType.NORMAL, luck: 0.3, weapons: [] },\n    {\n        name: \"necromancer\",\n        category: MonsterCategory.UNDEAD,\n        type: MonsterType.LEADER,\n        luck: 0.4,\n        weapons: [src_drop[\"monsterWeapons\"].knife]\n    },\n    {\n        name: \"skeleton\",\n        category: MonsterCategory.UNDEAD,\n        type: MonsterType.MINION,\n        luck: 0.3,\n        weapons: [src_drop[\"monsterWeapons\"].knife]\n    },\n];\nclass tiny_monster_TinyMonster extends monster_MonsterCharacter {\n    constructor(config, level, weapon) {\n        super({\n            name: config.name,\n            category: config.category,\n            type: config.type,\n            speed: 0.8,\n            healthMax: 10 + Math.floor(level * 2),\n            level: level,\n            luck: config.luck,\n            baseDamage: 1 + 0.5 * level,\n            xp: 35 + 5 * level,\n            spawn: 3,\n            weapon: weapon,\n        });\n    }\n}\nclass tiny_monster_TinyMonsterAI extends monster_MonsterAI {\n    constructor(config, dungeon, x, y) {\n        super(dungeon, {\n            x: x,\n            y: y,\n            width: 1,\n            height: 1,\n            zIndex: DungeonZIndexes.character\n        });\n        this.max_distance = 5;\n        const weapon = config.luck < this.dungeon.rng.nextFloat() ?\n            src_drop[\"Weapon\"].select(this.dungeon.controller.resources, this.dungeon.rng, config.weapons) : null;\n        this.character = new tiny_monster_TinyMonster(config, dungeon.level, weapon);\n        this.view.setWeapon(this.character.weapon);\n        this.init();\n    }\n    action(finished) {\n        if (!this.character.dead.get() && finished) {\n            const leader = this.character.type === MonsterType.LEADER;\n            if (leader) {\n                if (this.spawnMinions()) {\n                    return false;\n                }\n                if (this.moveFromHeroOrAttack()) {\n                    return true;\n                }\n                this.ready();\n            }\n            else {\n                if (this.moveToHero()) {\n                    return true;\n                }\n                if (this.moveByPath()) {\n                    return true;\n                }\n                this.ready();\n                if (this.randomMove()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    moveFromHeroOrAttack() {\n        const [hero] = this.scanHero(ScanDirection.AROUND, this.max_distance);\n        if (hero) {\n            this.lookAt(hero);\n            this.sendAlarm(hero);\n            const dist_x = Math.abs(this.x - hero.x);\n            const dist_y = Math.abs(this.y - hero.y);\n            if (dist_x > this.width || dist_y > this.height) {\n                const dx = Math.min(1, Math.max(-1, this.x - hero.x));\n                const dy = Math.min(1, Math.max(-1, this.y - hero.y));\n                console.log(\"move from hero\");\n                return this.move(dx, dy) || this.move(dx, 0) || this.move(0, dy);\n            }\n            else if (this.character.luck < this.dungeon.rng.nextFloat()) {\n                console.log(\"attack hero\");\n                this.hit();\n                return true;\n            }\n        }\n        return false;\n    }\n    drop() {\n        var _a;\n        if (Math.random() < this.character.luck) {\n            (_a = this.findDropCell()) === null || _a === void 0 ? void 0 : _a.randomDrop();\n        }\n    }\n    spawnMinion(x, y) {\n        const minions = tinyMonsters.filter(c => c.category === this.character.category && c.type === MonsterType.MINION);\n        if (minions.length === 0) {\n            console.warn(\"no minion config found\", this.character.category);\n            return null;\n        }\n        const config = this.dungeon.rng.choice(minions);\n        return new tiny_monster_TinyMonsterAI(config, this.dungeon, x, y);\n    }\n}\n\n// CONCATENATED MODULE: ./src/boss.monster.ts\n\n\n\n\n\n\n\nconst bossMonsters = [\n    {\n        name: \"big_zombie\", category: MonsterCategory.ZOMBIE, weapons: [\n            src_drop[\"monsterWeapons\"].anime_sword,\n            src_drop[\"monsterWeapons\"].baton_with_spikes,\n            src_drop[\"monsterWeapons\"].big_hammer,\n            src_drop[\"monsterWeapons\"].cleaver,\n            src_drop[\"monsterWeapons\"].mace,\n        ]\n    },\n    { name: \"big_demon\", category: MonsterCategory.DEMON, weapons: [] },\n    {\n        name: \"ogre\", category: MonsterCategory.ORC, weapons: [\n            src_drop[\"monsterWeapons\"].anime_sword,\n            src_drop[\"monsterWeapons\"].baton_with_spikes,\n            src_drop[\"monsterWeapons\"].big_hammer,\n            src_drop[\"monsterWeapons\"].cleaver,\n            src_drop[\"monsterWeapons\"].mace,\n        ]\n    },\n];\nclass boss_monster_BossMonster extends monster_MonsterCharacter {\n    constructor(config, level, weapon) {\n        super({\n            name: config.name,\n            category: config.category,\n            type: MonsterType.LEADER,\n            speed: 0.5,\n            healthMax: 50 + Math.floor(level * 10),\n            level: level,\n            luck: 0.4,\n            baseDamage: 5 + 0.5 * level,\n            xp: 100 + 50 * level,\n            spawn: 5,\n            weapon: weapon,\n        });\n    }\n}\nclass boss_monster_BossMonsterAI extends monster_MonsterAI {\n    constructor(config, dungeon, x, y) {\n        super(dungeon, {\n            width: 2,\n            height: 2,\n            x: x,\n            y: y,\n            zIndex: DungeonZIndexes.character\n        });\n        this.max_distance = 7;\n        const weapon = src_drop[\"Weapon\"].select(this.dungeon.controller.resources, this.dungeon.rng, config.weapons);\n        this.character = new boss_monster_BossMonster(config, dungeon.level, weapon);\n        this.view.setWeapon(this.character.weapon);\n        this.init();\n        const c_w = dungeon.controller.app.screen.width;\n        const healthView = new boss_monster_BossHealthView(this.character);\n        healthView.zIndex = 13;\n        healthView.position.set((c_w >> 1), 64);\n        dungeon.controller.stage.addChild(healthView);\n    }\n    action(finished) {\n        if (!this.character.dead.get() && finished) {\n            if (this.spawnMinions()) {\n                return false;\n            }\n            if (this.moveToHero()) {\n                return true;\n            }\n            if (this.moveByPath()) {\n                return true;\n            }\n            this.ready();\n            if (this.randomMove()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    drop() {\n        var _a;\n        for (let i = 0; i < 9; i++) {\n            (_a = this.findDropCell()) === null || _a === void 0 ? void 0 : _a.randomDrop();\n        }\n    }\n    spawnMinion(x, y) {\n        const minions = tinyMonsters.filter(c => c.category === this.character.category && c.type !== MonsterType.LEADER);\n        if (minions.length === 0) {\n            console.warn(\"no minion config found\", this.character.category);\n            return null;\n        }\n        const config = this.dungeon.rng.choice(minions);\n        return new tiny_monster_TinyMonsterAI(config, this.dungeon, x, y);\n    }\n}\nclass boss_monster_BossHealthView extends external_PIXI_[\"Container\"] {\n    constructor(boss) {\n        super();\n        this.destroyed = false;\n        this.boss = boss;\n        const HEALTH_MAX_WIDTH = 500;\n        const HEALTH_WIDTH = 4;\n        this.pointWidth = Math.min(HEALTH_WIDTH, Math.floor(HEALTH_MAX_WIDTH / this.boss.healthMax.get()));\n        this.widthMax = this.pointWidth * this.boss.healthMax.get();\n        this.health = new bar_view_BarView({\n            color: ui[\"Colors\"].uiRed,\n            widthMax: this.widthMax,\n            labelCenter: true\n        });\n        this.health.position.set(-(this.widthMax >> 1), 0);\n        this.addChild(this.health);\n        this.boss.health.subscribe(this.updateHealth, this);\n        this.boss.dead.subscribe(this.updateDead, this);\n    }\n    destroy() {\n        if (!this.destroyed) {\n            this.destroyed = true;\n            this.boss.health.unsubscribe(this.updateHealth, this);\n            this.boss.dead.unsubscribe(this.updateDead, this);\n            this.health.destroy();\n            super.destroy();\n        }\n    }\n    updateHealth(health) {\n        this.health.width = this.pointWidth * health;\n        this.health.label = `${this.boss.name} - ${health}`;\n    }\n    updateDead(dead) {\n        if (dead) {\n            this.destroy();\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/npc.ts\n\n\n\nclass NpcSkill {\n    constructor(npc, controller) {\n        this.npc = npc;\n        this.controller = controller;\n    }\n}\nclass SellingSkill extends NpcSkill {\n    constructor(npc, controller) {\n        super(npc, controller);\n    }\n    use(hero) {\n        this.controller.showInventory(hero, this.npc);\n    }\n}\nSellingSkill.id = 'selling';\nclass npc_HealSkill extends NpcSkill {\n    constructor(npc, controller) {\n        super(npc, controller);\n    }\n    use(hero) {\n        external_PIXI_[\"sound\"].play('big_egg_collect');\n        hero.heal(hero.healthMax.get());\n    }\n}\nnpc_HealSkill.id = 'heal';\nconst npcCharacters = [\n    { name: \"alchemist\", width: 1, height: 1, skills: [SellingSkill.id] },\n    { name: \"archer\", width: 1, height: 1, skills: [SellingSkill.id] },\n    { name: \"bishop\", width: 1, height: 2, skills: [] },\n    { name: \"blacksmith\", width: 1, height: 1, skills: [SellingSkill.id] },\n    { name: \"butcher\", width: 1, height: 1, skills: [SellingSkill.id] },\n    { name: \"elite_knight\", width: 1, height: 1, skills: [] },\n    { name: \"executioner\", width: 2, height: 2, skills: [] },\n    { name: \"fat_nun\", width: 1, height: 1, skills: [npc_HealSkill.id] },\n    { name: \"heavy_knight\", width: 1, height: 1, skills: [] },\n    { name: \"herald\", width: 1, height: 1, skills: [] },\n    { name: \"king\", width: 1, height: 1, skills: [] },\n    { name: \"knight\", width: 1, height: 1, skills: [] },\n    { name: \"large_elite_knight\", width: 2, height: 2, skills: [] },\n    { name: \"large_knight\", width: 2, height: 2, skills: [] },\n    { name: \"mage\", width: 1, height: 1, skills: [SellingSkill.id] },\n    { name: \"magic_shop_keeper\", width: 1, height: 1, skills: [SellingSkill.id] },\n    { name: \"merchant\", width: 1, height: 1, skills: [SellingSkill.id] },\n    { name: \"mountain_king\", width: 1, height: 1, skills: [] },\n    { name: \"normal_nun\", width: 1, height: 1, skills: [npc_HealSkill.id] },\n    { name: \"princess\", width: 1, height: 1, skills: [] },\n    { name: \"queen\", width: 1, height: 1, skills: [] },\n    { name: \"skinny_nun\", width: 1, height: 1, skills: [npc_HealSkill.id] },\n    { name: \"thief\", width: 1, height: 1, skills: [SellingSkill.id] },\n    { name: \"townsfolk_f\", width: 1, height: 1, skills: [] },\n];\nclass npc_NpcCharacter extends character_Character {\n    constructor(name) {\n        super({\n            name: name,\n            speed: 1,\n            healthMax: 100\n        });\n        this._context = {};\n        this._skill = {};\n        this.damage = 1;\n        this.weapon = null;\n    }\n    setContext(key, value) {\n        this._context[key] = value;\n    }\n    getContext(key) {\n        return this._context[key];\n    }\n    hasSkill(id) {\n        return this._skill.hasOwnProperty(id);\n    }\n    getSkill(id) {\n        return this._skill[id] || null;\n    }\n    addSkill(id, skill) {\n        this._skill[id] = skill;\n    }\n}\nclass npc_NpcAI extends character_BaseCharacterAI {\n    constructor(config, dungeon, controller, x, y) {\n        super(dungeon, {\n            width: config.width,\n            height: config.height,\n            x: x,\n            y: y,\n            zIndex: DungeonZIndexes.character\n        });\n        this.interacting = true;\n        this.character = new npc_NpcCharacter(config.name);\n        this.initSkills(controller, config.skills);\n        this.init();\n    }\n    initSkills(controller, skills) {\n        for (const id of skills) {\n            switch (id) {\n                case SellingSkill.id:\n                    this.character.addSkill(id, new SellingSkill(this.character, controller));\n                    break;\n                case npc_HealSkill.id:\n                    this.character.addSkill(id, new npc_HealSkill(this.character, controller));\n                    break;\n            }\n        }\n    }\n    onDead() {\n    }\n    onKilledBy(_by) {\n    }\n    action() {\n        return false;\n    }\n    scanHit() {\n    }\n    interact(hero) {\n        this.lookAt(hero);\n        this.dungeon.controller.showDialog(hero.character, this.character);\n    }\n}\n\n// CONCATENATED MODULE: ./src/dungeon.bonfire.ts\n\n\n\n\nconst dungeon_bonfire_TILE_SIZE = 16;\nvar BonfireState;\n(function (BonfireState) {\n    BonfireState[BonfireState[\"UNLIT\"] = 0] = \"UNLIT\";\n    BonfireState[BonfireState[\"LIGHT\"] = 1] = \"LIGHT\";\n    BonfireState[BonfireState[\"LIT\"] = 2] = \"LIT\";\n})(BonfireState || (BonfireState = {}));\nclass dungeon_bonfire_DungeonBonfire {\n    constructor(dungeon, x, y, light) {\n        this.width = 1;\n        this.height = 1;\n        this.static = true;\n        this.interacting = true;\n        this.dungeon = dungeon;\n        this.x = x;\n        this.y = y;\n        this._state = BonfireState.UNLIT;\n        this._sprite = this.dungeon.animated(this.x, this.y, `bonfire_unlit`);\n        this._sprite.zIndex = DungeonZIndexes.static + this.y * DungeonZIndexes.row;\n        this.dungeon.set(this.x, this.y, this);\n        if (light)\n            this.light();\n    }\n    get state() {\n        return this._state;\n    }\n    destroy() {\n        this.dungeon.remove(this.x, this.y, this);\n        this._sprite.destroy();\n    }\n    interact(hero) {\n        switch (this._state) {\n            case BonfireState.UNLIT:\n                hero.character.bonfires.add(this.dungeon.level);\n                this.light();\n                break;\n            case BonfireState.LIGHT:\n            case BonfireState.LIT:\n                this.dungeon.controller.showBonfire(hero.character);\n                break;\n        }\n    }\n    collide(_) {\n        return true;\n    }\n    light() {\n        if (this._state === BonfireState.UNLIT) {\n            this._state = BonfireState.LIGHT;\n            this._sprite.destroy();\n            this._sprite = this.dungeon.animated(this.x, this.y, \"bonfire_light\");\n            this._sprite.zIndex = DungeonZIndexes.static + this.y * DungeonZIndexes.row;\n            this._sprite.loop = false;\n            this._sprite.onComplete = () => this.lit();\n            this.dungeon.light.addLight({\n                x: this.x * dungeon_bonfire_TILE_SIZE + 8,\n                y: this.y * dungeon_bonfire_TILE_SIZE - dungeon_bonfire_TILE_SIZE,\n            }, LightType.BONFIRE);\n        }\n    }\n    lit() {\n        var _a;\n        this._state = BonfireState.LIT;\n        (_a = this._sprite) === null || _a === void 0 ? void 0 : _a.destroy();\n        this._sprite = this.dungeon.animated(this.x, this.y, \"bonfire_lit\");\n        this._sprite.zIndex = DungeonZIndexes.static + this.y * DungeonZIndexes.row;\n    }\n}\nclass dungeon_bonfire_DungeonBonfireDialogModal {\n    constructor(controller, hero) {\n        this.container = null;\n        this.background = null;\n        this.selectable = null;\n        this.controller = controller;\n        this.hero = hero;\n    }\n    init() {\n        const width = 400;\n        const height = 400;\n        const button_height = 32;\n        const button_text_size = 24;\n        this.selectable = new ui[\"SelectableGrid\"](this.controller.joystick);\n        this.background = new external_PIXI_[\"Graphics\"]();\n        this.background.beginFill(0x000000).drawRect(0, 0, width, height).endFill();\n        this.background.zIndex = 0;\n        this.container = new external_PIXI_[\"Container\"]();\n        this.container.addChild(this.background);\n        this.container.sortChildren();\n        this.container.position.set((this.controller.app.screen.width >> 1) - (width >> 1), (this.controller.app.screen.height >> 1) - (height >> 1));\n        this.controller.stage.addChild(this.container);\n        this.controller.app.ticker.add(this.handleInput, this);\n        const layout = new ui[\"Layout\"]();\n        layout.offset(ui[\"Sizes\"].uiMargin, ui[\"Sizes\"].uiMargin);\n        layout.commit();\n        let y = 0;\n        const addButton = (label, action) => {\n            const button = new ui[\"Button\"]({\n                label: label,\n                width: width - ui[\"Sizes\"].uiMargin * 2,\n                height: button_height,\n                textSize: button_text_size\n            });\n            this.container.addChild(button);\n            button.position.set(layout.x, layout.y);\n            layout.offset(0, button_height);\n            layout.offset(0, ui[\"Sizes\"].uiMargin);\n            this.selectable.set(0, y, button, action);\n            y++;\n        };\n        const levels = [...this.hero.bonfires].sort((a, b) => a - b);\n        for (const level of levels) {\n            addButton(`Level ${level}`, () => this.goto(level));\n        }\n        addButton(`Cancel`, () => this.cancel());\n    }\n    goto(level) {\n        this.controller.closeModal();\n        this.controller.generateDungeon({\n            hero: this.hero,\n            level: level\n        });\n    }\n    cancel() {\n        this.controller.closeModal();\n    }\n    handleInput() {\n        var _a;\n        (_a = this.selectable) === null || _a === void 0 ? void 0 : _a.handleInput();\n    }\n    destroy() {\n        var _a, _b;\n        this.controller.app.ticker.remove(this.handleInput, this);\n        (_a = this.container) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.container = null;\n        (_b = this.background) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.background = null;\n        this.selectable = null;\n    }\n}\n\n// CONCATENATED MODULE: ./src/dungeon.generator.ts\n\n\n\n\n\n\n\n\n\nclass dungeon_generator_BaseDungeonGenerator {\n    constructor(controller) {\n        this.resources = controller.resources;\n        this.controller = controller;\n    }\n    createDungeon(rng, seed, level, width, height) {\n        return new dungeon_map_DungeonMap(this.controller, new external_PIXI_[\"Ticker\"](), rng, seed, level, width, height);\n    }\n    replaceFloorRandomly(rng, dungeon) {\n        const replacements = ['floor_2.png', 'floor_3.png', 'floor_4.png', 'floor_5.png', 'floor_6.png', 'floor_7.png', 'floor_8.png'];\n        const percent = 0.2;\n        for (let y = 0; y < dungeon.height; y++) {\n            for (let x = 0; x < dungeon.width; x++) {\n                const cell = dungeon.cell(x, y);\n                if (cell.hasFloor && rng.nextFloat() < percent) {\n                    cell.floorName = rng.choice(replacements);\n                }\n            }\n        }\n    }\n    replaceWallRandomly(rng, dungeon) {\n        const banners = [\n            'wall_banner_red.png',\n            'wall_banner_blue.png',\n            'wall_banner_green.png',\n            'wall_banner_yellow.png',\n        ];\n        const goo = [\n            'wall_goo.png',\n        ];\n        const fountains = [\n            'wall_fountain_mid_red',\n            'wall_fountain_mid_blue',\n        ];\n        const holes = [\n            'wall_hole_1.png',\n            'wall_hole_2.png',\n        ];\n        const percent = 0.3;\n        for (let y = 0; y < dungeon.height; y++) {\n            for (let x = 0; x < dungeon.width; x++) {\n                const cell = dungeon.cell(x, y);\n                if (cell.wallName === 'wall_mid.png') {\n                    if (rng.nextFloat() < percent) {\n                        const replacements = [...holes];\n                        const has_floor = y + 1 < dungeon.height && dungeon.cell(x, y + 1).floorName === 'floor_1.png';\n                        if (has_floor) {\n                            replacements.push(...banners);\n                            replacements.push(...goo);\n                        }\n                        const has_top = y > 0 && dungeon.cell(x, y - 1).wallName === 'wall_top_mid.png';\n                        if (has_top && has_floor) {\n                            replacements.push(...fountains);\n                        }\n                        const replacement = rng.choice(replacements);\n                        switch (replacement) {\n                            case 'wall_goo.png':\n                                dungeon.cell(x, y).wallName = 'wall_goo.png';\n                                dungeon.cell(x, y + 1).floorName = 'wall_goo_base.png';\n                                break;\n                            case 'wall_fountain_mid_red':\n                                dungeon.cell(x, y - 1).wallName = 'wall_fountain_top.png';\n                                dungeon.cell(x, y).wallName = 'wall_fountain_mid_red';\n                                dungeon.cell(x, y + 1).floorName = 'wall_fountain_basin_red';\n                                break;\n                            case 'wall_fountain_mid_blue':\n                                dungeon.cell(x, y - 1).wallName = 'wall_fountain_top.png';\n                                dungeon.cell(x, y).wallName = 'wall_fountain_mid_blue';\n                                dungeon.cell(x, y + 1).floorName = 'wall_fountain_basin_blue';\n                                break;\n                            default:\n                                dungeon.cell(x, y).wallName = replacement;\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    distance(a, b) {\n        return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n    }\n    findFreePositions(dungeon, width, height) {\n        const free = [];\n        for (let y = height; y < dungeon.height; y++) {\n            for (let x = 0; x < dungeon.width - width; x++) {\n                let valid = true;\n                for (let dy = 0; dy < height && valid; dy++) {\n                    for (let dx = 0; dx < width && valid; dx++) {\n                        const cell = dungeon.cell(x + dx, y - dy);\n                        valid = cell.hasFloor && !cell.hasObject;\n                    }\n                }\n                if (valid)\n                    free.push(dungeon.cell(x, y));\n            }\n        }\n        return free;\n    }\n    placeHero(rng, dungeon, hero) {\n        const free = this.findFreePositions(dungeon, 2, 2);\n        if (free.length === 0) {\n            throw \"hero not placed\";\n        }\n        const cell = rng.choice(free);\n        const ai = new hero_HeroAI(hero, dungeon, cell.x, cell.y);\n        dungeon.light.addLight(ai.view, LightType.HERO);\n        return ai;\n    }\n    placeNpc(rng, dungeon, hero) {\n        const max_hero_distance = 10;\n        const npc_count = 5;\n        for (let n = 0; n < npc_count; n++) {\n            const free = this.findFreePositions(dungeon, 2, 2).filter(cell => {\n                return this.distance(hero, cell) < max_hero_distance;\n            });\n            if (free.length === 0) {\n                console.warn(\"no free place for npc\");\n            }\n            const i = rng.nextRange(0, free.length);\n            const [cell] = free.splice(i, 1);\n            const config = rng.choice(npcCharacters);\n            new npc_NpcAI(config, dungeon, this.controller, cell.x, cell.y);\n        }\n    }\n    placeMonsters(rng, dungeon, hero) {\n        const total_space = dungeon.width * dungeon.height;\n        const floor_space = Math.floor(total_space * 0.4);\n        const spawn_space = Math.floor(floor_space * 0.2);\n        const monster_count = Math.floor(spawn_space * 0.07);\n        console.log(`floor_space: ${floor_space}`);\n        console.log(`monster_count: ${monster_count}`);\n        for (let m = 0; m < monster_count; m++) {\n            if (!this.placeMonster(rng, dungeon, hero)) {\n                break;\n            }\n        }\n    }\n    placeMonster(rng, dungeon, hero) {\n        const monster_category = this.bossConfig(dungeon).category;\n        const filtered_monsters = tinyMonsters.filter(config => {\n            return config.category === monster_category ||\n                (config.category != MonsterCategory.DEMON &&\n                    config.category != MonsterCategory.ORC &&\n                    config.category != MonsterCategory.ZOMBIE);\n        });\n        if (filtered_monsters.length === 0) {\n            console.warn(\"no tiny monster config found\");\n            return false;\n        }\n        const min_hero_distance = 15;\n        const free = this.findFreePositions(dungeon, 2, 2).filter(cell => {\n            return this.distance(hero, cell) > min_hero_distance;\n        });\n        if (free.length === 0) {\n            console.warn(\"no free place for tiny monster\");\n            return false;\n        }\n        const i = rng.nextRange(0, free.length);\n        let [cell] = free.splice(i, 1);\n        const config = rng.choice(filtered_monsters);\n        new tiny_monster_TinyMonsterAI(config, dungeon, cell.x, cell.y);\n        return true;\n    }\n    placeBoss(rng, dungeon, hero) {\n        const min_hero_distance = 20;\n        const free = this.findFreePositions(dungeon, 2, 2).filter(cell => {\n            return this.distance(hero, cell) > min_hero_distance;\n        });\n        if (free.length > 0) {\n            const i = rng.nextRange(0, free.length);\n            let [cell] = free.splice(i, 1);\n            const config = this.bossConfig(dungeon);\n            new boss_monster_BossMonsterAI(config, dungeon, cell.x, cell.y);\n        }\n        else {\n            console.error(\"boss not placed\");\n        }\n    }\n    bossConfig(dungeon) {\n        return bossMonsters[Math.floor(dungeon.level / 5) % bossMonsters.length];\n    }\n    placeDrop(rng, dungeon) {\n        const free = [];\n        for (let y = 0; y < dungeon.height; y++) {\n            for (let x = 0; x < dungeon.height; x++) {\n                const cell = dungeon.cell(x, y);\n                if (cell.hasFloor && !cell.hasDrop && !cell.hasObject) {\n                    free.push(cell);\n                }\n            }\n        }\n        const drop_percent = 3;\n        const drop_count = Math.floor(free.length * drop_percent / 100.0);\n        for (let d = 0; d < drop_count && free.length > 0; d++) {\n            const i = rng.nextRange(0, free.length);\n            free.splice(i, 1)[0].randomDrop();\n        }\n    }\n    placeLadder(rng, dungeon, hero) {\n        const free3 = [];\n        const free1 = [];\n        const directions = [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]];\n        for (let y = 1; y < dungeon.height - 1; y++) {\n            for (let x = 1; x < dungeon.height - 1; x++) {\n                const cell = dungeon.cell(x, y);\n                if (cell.hasFloor) {\n                    let c = 0;\n                    for (let [dx, dy] of directions) {\n                        if (dungeon.cell(x + dx, y + dy).hasFloor) {\n                            c++;\n                        }\n                    }\n                    const distance = this.distance(hero, { x: x, y: y });\n                    if (c === directions.length) {\n                        free3.push([cell, distance]);\n                    }\n                    else {\n                        free1.push([cell, distance]);\n                    }\n                }\n            }\n        }\n        free3.sort((a, b) => a[1] - b[1]);\n        free1.sort((a, b) => a[1] - b[1]);\n        const free = [...free1, ...free3].reverse().splice(0, 10);\n        if (free.length == 0) {\n            throw \"ladder not set\";\n        }\n        rng.choice(free)[0].ladder();\n    }\n    placeBonfire(rng, dungeon, hero) {\n        const max_hero_distance = 10;\n        const free = this.findFreePositions(dungeon, 2, 2).filter(cell => {\n            return this.distance(hero, cell) < max_hero_distance;\n        });\n        if (free.length > 0) {\n            const cell = rng.choice(free);\n            const light = hero.character.bonfires.has(dungeon.level);\n            return new dungeon_bonfire_DungeonBonfire(dungeon, cell.x, cell.y, light);\n        }\n        else {\n            throw \"bonfire not placed\";\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/concurency.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction yields(delay = 0) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield new Promise((resolve => setTimeout(resolve, delay)));\n    });\n}\n\n// CONCATENATED MODULE: ./src/wfc/model.ts\nvar model_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nfunction model_buffer(size, value) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n        a.push(value);\n    }\n    return a;\n}\nclass Color {\n    constructor(R, G, B, A = 255) {\n        this.R = R;\n        this.G = G;\n        this.B = B;\n        this.A = A;\n    }\n    static fromRgb(rgb) {\n        const r = (rgb >> 16) & 0xFF;\n        const g = (rgb >> 8) & 0xFF;\n        const b = rgb & 0xFF;\n        return new Color(r, g, b);\n    }\n    static fromImage(imageData, x, y) {\n        return Color.fromBuffer(imageData.data, imageData.width, x, y);\n    }\n    static fromBuffer(buffer, w, x, y) {\n        let offset = 4 * (y * w + x);\n        let R = buffer[offset];\n        let G = buffer[offset + 1];\n        let B = buffer[offset + 2];\n        let A = buffer[offset + 3];\n        return new Color(R, G, B, A);\n    }\n    equals(that) {\n        return this.R === that.R &&\n            this.G === that.G &&\n            this.B === that.B &&\n            this.A === that.A;\n    }\n}\nclass Tile {\n    constructor(value, color, equal = (a, b) => a === b) {\n        this.value = value;\n        this.color = color;\n        this.equal = equal;\n    }\n    equals(that) {\n        return that.equal(this.value, that.value);\n    }\n}\nvar Resolution;\n(function (Resolution) {\n    Resolution[Resolution[\"Decided\"] = 0] = \"Decided\";\n    Resolution[Resolution[\"Undecided\"] = -1] = \"Undecided\";\n    Resolution[Resolution[\"Contradiction\"] = -2] = \"Contradiction\";\n})(Resolution || (Resolution = {}));\nclass model_Model {\n    constructor(rng, width, height) {\n        this.wave = [];\n        this.propagator = [];\n        this.compatible = [];\n        this.observed = null;\n        this.toPropagate = [];\n        this.backtrackItems = [];\n        this.backtrackItemsLengths = [];\n        this.prevChoices = [];\n        this.droppedBacktrackItemsCount = 0;\n        this.T = 0;\n        this.periodic = false;\n        this.weights = [];\n        this.weightLogWeights = [];\n        this.sumsOfOnes = [];\n        this.sumOfWeights = 0;\n        this.sumOfWeightLogWeights = 0;\n        this.startingEntropy = 0;\n        this.sumsOfWeights = [];\n        this.sumsOfWeightLogWeights = [];\n        this.entropies = [];\n        this.status = Resolution.Undecided;\n        this.deferredConstraintsStep = false;\n        this.debug = false;\n        this.rng = rng;\n        this.FMX = width;\n        this.FMY = height;\n    }\n    get percent() {\n        let count = 0;\n        for (let i = 0; i < this.wave.length; i++) {\n            if (this.sumsOfOnes[i] === 1) {\n                count++;\n            }\n        }\n        return count * 100.0 / this.wave.length;\n    }\n    init() {\n        this.wave = model_buffer(this.FMX * this.FMY, []);\n        this.compatible = [];\n        for (let i = 0; i < this.wave.length; i++) {\n            this.wave[i] = model_buffer(this.T, true);\n            this.compatible[i] = [];\n            for (let t = 0; t < this.T; t++) {\n                this.compatible[i][t] = model_buffer(4, 0);\n            }\n        }\n        this.weightLogWeights = [];\n        this.sumOfWeights = 0;\n        this.sumOfWeightLogWeights = 0;\n        for (let t = 0; t < this.T; t++) {\n            this.weightLogWeights[t] = this.weights[t] * Math.log(this.weights[t]);\n            this.sumOfWeights += this.weights[t];\n            this.sumOfWeightLogWeights += this.weightLogWeights[t];\n        }\n        this.startingEntropy = Math.log(this.sumOfWeights) - this.sumOfWeightLogWeights / this.sumOfWeights;\n        this.status = Resolution.Undecided;\n        this.initConstraint();\n    }\n    clear() {\n        this.sumsOfOnes = [];\n        this.sumsOfWeights = [];\n        this.sumsOfWeightLogWeights = [];\n        this.entropies = [];\n        for (let i = 0; i < this.wave.length; i++) {\n            for (let t = 0; t < this.T; t++) {\n                this.wave[i][t] = true;\n                for (let d = 0; d < 4; d++) {\n                    this.compatible[i][t][d] = this.propagator[model_Model.opposite[d]][t].length;\n                }\n            }\n            this.sumsOfOnes[i] = this.weights.length;\n            this.sumsOfWeights[i] = this.sumOfWeights;\n            this.sumsOfWeightLogWeights[i] = this.sumOfWeightLogWeights;\n            this.entropies[i] = this.startingEntropy;\n        }\n        this.toPropagate = [];\n        this.backtrackItems = [];\n        this.backtrackItemsLengths = [0];\n        this.droppedBacktrackItemsCount = 0;\n        this.prevChoices = [];\n        this.status = Resolution.Undecided;\n    }\n    run(limit = 0, debug = false) {\n        return model_awaiter(this, void 0, void 0, function* () {\n            if (this.wave.length === 0) {\n                console.time(\"model.init\");\n                this.init();\n                console.timeEnd(\"model.init\");\n            }\n            console.time(\"model.clear\");\n            this.clear();\n            console.timeEnd(\"model.clear\");\n            console.time(\"model.run\");\n            this.debug = debug;\n            let i = 0;\n            for (; i < limit || limit === 0; i++) {\n                if (i % 50 === 0) {\n                    yield yields();\n                }\n                if (this.debug) {\n                    console.log(\"step\", i);\n                }\n                this.step();\n                if (this.debug) {\n                    console.log(\"after step\", i);\n                    this.graphics([]);\n                }\n                if (this.status !== Resolution.Undecided) {\n                    break;\n                }\n            }\n            console.timeEnd(\"model.run\");\n            console.log(`complete, steps: ${i}`);\n            return this.status;\n        });\n    }\n    step() {\n        let index = -1;\n        let pattern;\n        let restart = false;\n        if (this.deferredConstraintsStep) {\n            if (this.debug)\n                console.log(\"step constraint\");\n            this.stepConstraint();\n        }\n        if (this.status != Resolution.Undecided) {\n            index = 0;\n            restart = true;\n            if (this.debug)\n                console.log(\"restart = true\");\n        }\n        if (!restart) {\n            console.assert(this.toPropagate.length == 0);\n            this.backtrackItemsLengths.push(this.droppedBacktrackItemsCount + this.backtrackItems.length);\n            [index, pattern] = this.observe();\n            if (this.debug)\n                console.log(\"observed\", index, pattern);\n            if (index !== -1) {\n                if (this.debug)\n                    console.log(\"push to prev choices\");\n                this.prevChoices.push([index, pattern]);\n            }\n        }\n        do {\n            if (this.debug)\n                console.log(\"do loop\");\n            restart = false;\n            if (this.debug)\n                console.log(\"status\", this.status);\n            if (this.status === Resolution.Undecided)\n                this.propagate();\n            if (this.status === Resolution.Undecided)\n                this.stepConstraint();\n            if (index === -1 && this.status === Resolution.Undecided) {\n                if (this.debug)\n                    console.log(\"decided\");\n                this.status = Resolution.Decided;\n                return this.status;\n            }\n            if (this.status === Resolution.Contradiction) {\n                if (this.debug)\n                    console.log(\"contradiction\");\n                index = 0;\n                while (true) {\n                    if (this.debug)\n                        console.log(\"while backtrack\");\n                    if (this.backtrackItemsLengths.length == 1) {\n                        if (this.debug)\n                            console.log(\"We've backtracked as much as we can, but, it's still not possible. That means it is impossible\");\n                        return Resolution.Contradiction;\n                    }\n                    this.backtrack();\n                    let item = this.prevChoices.pop();\n                    this.toPropagate = [];\n                    this.status = Resolution.Undecided;\n                    if (this.debug) {\n                        console.log(\"Mark the given choice as impossible\", item[0], item[1]);\n                        this.graphics([item[0]]);\n                    }\n                    if (this.internalBan(item[0], item[1])) {\n                        this.status = Resolution.Contradiction;\n                    }\n                    if (this.status === Resolution.Undecided)\n                        this.propagate();\n                    if (this.status === Resolution.Contradiction) {\n                        if (this.debug)\n                            console.log(\"If still in contradiction, repeat backtracking\");\n                        continue;\n                    }\n                    else {\n                        if (this.debug)\n                            console.log(\"// Include the last ban as part of the previous backtrack\");\n                        console.assert(this.toPropagate.length === 0);\n                        this.backtrackItemsLengths.pop();\n                        this.backtrackItemsLengths.push(this.droppedBacktrackItemsCount + this.backtrackItems.length);\n                    }\n                    if (this.debug)\n                        console.log(\"restart = true and break\");\n                    restart = true;\n                    break;\n                }\n            }\n        } while (restart);\n        return this.status;\n    }\n    observe() {\n        if (this.debug)\n            console.log(\"observe\");\n        let min = 1E+3;\n        let argmin = -1;\n        for (let i = 0; i < this.wave.length; i++) {\n            if (this.onBoundary(i % this.FMX, Math.floor(i / this.FMX)))\n                continue;\n            let amount = this.sumsOfOnes[i];\n            if (amount === 0) {\n                if (this.debug)\n                    console.error(`[wave=${i}] found zero sum of ones`);\n                if (this.debug)\n                    this.graphics([i]);\n                this.status = Resolution.Contradiction;\n                return [-1, -1];\n            }\n            let entropy = this.entropies[i];\n            if (amount > 1 && entropy <= min) {\n                let noise = 1E-6 * this.rng.nextFloat();\n                if (entropy + noise < min) {\n                    min = entropy + noise;\n                    argmin = i;\n                }\n            }\n        }\n        if (argmin == -1) {\n            if (this.debug)\n                console.log(\"complete observed\");\n            this.observed = model_buffer(this.FMX * this.FMY, 0);\n            for (let i = 0; i < this.wave.length; i++) {\n                let x = i % this.FMX, y = Math.floor(i / this.FMX);\n                if (this.onBoundary(x, y)) {\n                    continue;\n                }\n                this.testObserved(i);\n                for (let t = 0; t < this.T; t++) {\n                    if (this.wave[i][t]) {\n                        this.observed[i] = t;\n                        break;\n                    }\n                }\n            }\n            return [-1, -1];\n        }\n        let distribution_sum = 0;\n        let distribution = [];\n        for (let t = 0; t < this.T; t++) {\n            distribution[t] = this.wave[argmin][t] ? this.weights[t] : 0;\n            distribution_sum += distribution[t];\n        }\n        let rnd = this.rng.nextFloat() * distribution_sum;\n        let r = 0;\n        for (let weight of distribution) {\n            rnd -= weight;\n            if (rnd < 0)\n                break;\n            r++;\n        }\n        let w = this.wave[argmin];\n        for (let t = 0; t < this.T; t++) {\n            if (w[t] != (t == r)) {\n                if (this.debug)\n                    console.log(\"observe select\");\n                if (this.internalBan(argmin, t)) {\n                    this.status = Resolution.Contradiction;\n                }\n            }\n        }\n        if (this.debug) {\n            console.log(\"observed\", [argmin, r]);\n            this.graphics([argmin]);\n        }\n        return [argmin, r];\n    }\n    propagate() {\n        while (this.toPropagate.length > 0) {\n            let [i, t] = this.toPropagate.pop();\n            let x = i % this.FMX, y = Math.floor(i / this.FMX);\n            for (let direction = 0; direction < 4; direction++) {\n                const dx = model_Model.DX[direction], dy = model_Model.DY[direction];\n                let sx = x + dx, sy = y + dy;\n                if (this.onBoundary(sx, sy)) {\n                    continue;\n                }\n                if (sx < 0)\n                    sx += this.FMX;\n                else if (sx >= this.FMX)\n                    sx -= this.FMX;\n                if (sy < 0)\n                    sy += this.FMY;\n                else if (sy >= this.FMY)\n                    sy -= this.FMY;\n                let s = sx + sy * this.FMX;\n                let pattern1 = this.propagator[direction][t];\n                let compat = this.compatible[s];\n                for (let st of pattern1) {\n                    let comp = compat[st];\n                    comp[direction]--;\n                    if (comp[direction] == 0) {\n                        if (this.internalBan(s, st)) {\n                            this.status = Resolution.Contradiction;\n                        }\n                    }\n                }\n            }\n            if (this.status == Resolution.Contradiction) {\n                break;\n            }\n        }\n    }\n    ban(index, pattern) {\n        if (this.debug)\n            console.log(\"ban\", index, pattern);\n        if (this.wave[index][pattern]) {\n            this.deferredConstraintsStep = true;\n            if (this.internalBan(index, pattern)) {\n                return this.status = Resolution.Contradiction;\n            }\n        }\n        this.propagate();\n        return this.status;\n    }\n    internalBan(index, pattern) {\n        if (this.debug)\n            console.log(\"internal ban\", index, pattern);\n        this.wave[index][pattern] = false;\n        let comp = this.compatible[index][pattern];\n        for (let d = 0; d < 4; d++) {\n            comp[d] -= this.T;\n        }\n        this.toPropagate.push([index, pattern]);\n        this.sumsOfOnes[index] -= 1;\n        this.sumsOfWeights[index] -= this.weights[pattern];\n        this.sumsOfWeightLogWeights[index] -= this.weightLogWeights[pattern];\n        let sum = this.sumsOfWeights[index];\n        this.entropies[index] = Math.log(sum) - this.sumsOfWeightLogWeights[index] / sum;\n        this.backtrackItems.push([index, pattern]);\n        this.banConstraint(index, pattern);\n        if (this.sumsOfOnes[index] === 0) {\n            if (this.debug) {\n                console.error(\"sum is zero\", index);\n                this.graphics([index]);\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    backtrack() {\n        const targetLength = this.backtrackItemsLengths.pop() - this.droppedBacktrackItemsCount;\n        if (this.debug)\n            console.warn(\"backtrack\", targetLength);\n        const markup = [];\n        const toPropagateSet = new Set(this.toPropagate.map((i) => i.join(\",\")));\n        while (this.backtrackItems.length > targetLength) {\n            let [index, patternIndex] = this.backtrackItems.pop();\n            markup.push(index);\n            let comp = this.compatible[index][patternIndex];\n            for (let d = 0; d < 4; d++) {\n                comp[d] += this.T;\n            }\n            this.wave[index][patternIndex] = true;\n            this.sumsOfOnes[index] += 1;\n            this.sumsOfWeights[index] += this.weights[patternIndex];\n            this.sumsOfWeightLogWeights[index] += this.weightLogWeights[patternIndex];\n            let sum = this.sumsOfWeights[index];\n            this.entropies[index] = Math.log(sum) - this.sumsOfWeightLogWeights[index] / sum;\n            if (!toPropagateSet.has([index, patternIndex].join(\",\"))) {\n                let x = index % this.FMX, y = Math.floor(index / this.FMX);\n                for (let direction = 0; direction < 4; direction++) {\n                    let dx = model_Model.DX[direction], dy = model_Model.DY[direction];\n                    let sx = x + dx, sy = y + dy;\n                    if (this.onBoundary(sx, sy)) {\n                        continue;\n                    }\n                    if (sx < 0)\n                        sx += this.FMX;\n                    else if (sx >= this.FMX)\n                        sx -= this.FMX;\n                    if (sy < 0)\n                        sy += this.FMY;\n                    else if (sy >= this.FMY)\n                        sy -= this.FMY;\n                    let s = sx + sy * this.FMX;\n                    markup.push(s);\n                    const pattern = this.propagator[direction][patternIndex];\n                    for (let st of pattern) {\n                        this.compatible[s][st][direction]++;\n                    }\n                }\n            }\n            this.backtrackConstraint(index, patternIndex);\n        }\n        if (this.debug) {\n            console.log(\"backtracked\");\n            this.graphics(markup);\n        }\n    }\n}\nmodel_Model.DX = [-1, 0, 1, 0];\nmodel_Model.DY = [0, 1, 0, -1];\nmodel_Model.opposite = [2, 3, 0, 1];\n\n// CONCATENATED MODULE: ./src/geometry.ts\nconst x_dist = 2;\nconst y_dist = 3;\nclass ImmutableRect {\n    constructor(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n    }\n    mutable() {\n        return new MutableRect(this.x, this.y, this.w, this.h);\n    }\n    expand() {\n        const a = this;\n        return new ImmutableRect(a.x - x_dist, a.y - y_dist, a.w + x_dist + x_dist, a.h + y_dist + y_dist);\n    }\n    expandV() {\n        const a = this;\n        return new ImmutableRect(a.x - x_dist, a.y, a.w + x_dist + x_dist, a.h);\n    }\n    expandH() {\n        const a = this;\n        return new ImmutableRect(a.x, a.y - y_dist, a.w, a.h + y_dist + y_dist);\n    }\n    isOverlap(b) {\n        const a = this;\n        return a.x < b.x + b.w\n            && a.x + a.w > b.x\n            && a.y < b.y + b.h\n            && a.y + a.h > b.y;\n    }\n    toString() {\n        return `{x=${this.x},y=${this.y},w=${this.w},h=${this.h}}`;\n    }\n}\nclass MutableRect {\n    constructor(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n    }\n    static from(rect) {\n        return new MutableRect(rect.x, rect.y, rect.w, rect.h);\n    }\n    immutable() {\n        return new ImmutableRect(this.x, this.y, this.w, this.h);\n    }\n    isOverlap(b) {\n        const a = this;\n        return a.x < b.x + b.w\n            && a.x + a.w > b.x\n            && a.y < b.y + b.h\n            && a.y + a.h > b.y;\n    }\n    toString() {\n        return `{x=${this.x},y=${this.y},w=${this.w},h=${this.h}}`;\n    }\n}\n\n// CONCATENATED MODULE: ./src/tunneling.ts\n\nclass tunneling_TunnelingAlgorithm {\n    constructor(rng, width, height, options) {\n        this.possible = [];\n        this.rooms = [];\n        this.corridorsV = [];\n        this.corridorsH = [];\n        this.rng = rng;\n        this.width = width;\n        this.height = height;\n        this.room_min_w = options.room_min_w || 5;\n        this.room_min_h = options.room_min_h || 5;\n        this.room_max_w = options.room_max_w || 20;\n        this.room_max_h = options.room_max_h || 20;\n        this.room_min_x = options.room_min_x || 2;\n        this.room_min_y = options.room_min_y || 2;\n        this.max_corr_dist = options.max_corr_dist || 20;\n        this.max_corr_width = options.max_corr_width || 5;\n        this.skew = options.skew || 3;\n        this.x_dist = options.x_dist || 2;\n        this.y_dist = options.y_dist || 2;\n        this.min_corr_dist_x = options.min_corr_dist_x || (this.x_dist << 1) + 1;\n        this.min_corr_dist_y = options.min_corr_dist_y || (this.y_dist << 1) + 1;\n        this.max_rooms = options.max_rooms || 0;\n        this.debug = options.debug || false;\n    }\n    isOverlap(a) {\n        const f = a.isOverlap.bind(a);\n        return this.rooms.some(f) ||\n            this.corridorsV.some(f) ||\n            this.corridorsH.some(f);\n    }\n    ;\n    valid(rect) {\n        return rect.x >= 0 && rect.y >= 0 && rect.w > 0 && rect.h > 0 &&\n            rect.x + rect.w < this.width &&\n            rect.y + rect.h < this.height &&\n            !this.isOverlap(rect);\n    }\n    generate() {\n        this.rooms.splice(0, this.rooms.length);\n        this.corridorsH.splice(0, this.corridorsH.length);\n        this.corridorsV.splice(0, this.corridorsV.length);\n        if (this.generateFirstRoom()) {\n            if (this.max_rooms > 0) {\n                while (this.rooms.length < this.max_rooms) {\n                    if (!this.generateNextRoom()) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            else {\n                while (this.generateNextRoom()) {\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    generateFirstRoom() {\n        const room_w = this.rng.nextRange(this.room_min_w, this.room_max_w);\n        const room_h = this.rng.nextRange(this.room_min_h, this.room_max_h);\n        const min_x = Math.max(this.room_min_x, (this.width >> 1) - room_w);\n        const min_y = Math.max(this.room_min_y, (this.height >> 1) - room_h);\n        const max_x = Math.min(this.width - this.room_min_x - room_w, (this.width >> 1) + room_w);\n        const max_y = Math.min(this.height - this.room_min_y - room_h, (this.height >> 1) + room_h);\n        const room = new ImmutableRect(this.nextRange(min_x, max_x), this.nextRange(min_y, max_y), room_w, room_h);\n        if (!this.isOverlap(room.expand())) {\n            this.rooms.push(room);\n            return true;\n        }\n        return false;\n    }\n    generateNextRoom() {\n        if (this.debug)\n            console.log(\"generate next room\");\n        this.possible.splice(0, this.possible.length);\n        this.rooms.forEach((room) => {\n            const topC = this.findTopCorridorArea(room);\n            const bottomC = this.findBottomCorridorArea(room);\n            const rightC = this.findRightCorridorArea(room);\n            const leftC = this.findLeftCorridorArea(room);\n            if (topC) {\n                if (this.debug)\n                    console.log(\"possible top corridor area\", room, topC);\n                const topR = this.findTopRoomArea(topC);\n                if (topR) {\n                    if (this.debug)\n                        console.log(\"add possible top room area\", room, topC, topR);\n                    this.possible.push(new Possible(topR, topC, Direction.TOP));\n                }\n            }\n            if (bottomC) {\n                if (this.debug)\n                    console.log(\"possible bottom corridor area\", room, bottomC);\n                const bottomR = this.findBottomRoomArea(bottomC);\n                if (bottomR) {\n                    if (this.debug)\n                        console.log(\"add possible bottom room area\", room, bottomC, bottomR);\n                    this.possible.push(new Possible(bottomR, bottomC, Direction.BOTTOM));\n                }\n            }\n            if (rightC) {\n                if (this.debug)\n                    console.log(\"possible right corridor area\", room, rightC);\n                const rightR = this.findRightRoomArea(rightC);\n                if (rightR) {\n                    if (this.debug)\n                        console.log(\"add possible right room area\", room, rightC, rightR);\n                    this.possible.push(new Possible(rightR, rightC, Direction.RIGHT));\n                }\n            }\n            if (leftC) {\n                if (this.debug)\n                    console.log(\"possible left corridor area\", room, leftC);\n                const leftR = this.findLeftRoomArea(leftC);\n                if (leftR) {\n                    if (this.debug)\n                        console.log(\"add possible left room area\", room, leftC, leftR);\n                    this.possible.push(new Possible(leftR, leftC, Direction.LEFT));\n                }\n            }\n        });\n        if (this.debug)\n            console.log(\"possible\", [...this.possible]);\n        if (this.debug)\n            console.log(\"rooms\", [...this.rooms]);\n        if (this.debug)\n            console.log(\"corridorsV\", [...this.corridorsV]);\n        if (this.debug)\n            console.log(\"corridorsH\", [...this.corridorsH]);\n        while (this.possible.length > 0) {\n            const i = this.rng.nextRange(0, this.possible.length);\n            const possible = this.possible[i];\n            this.possible.splice(i, 1);\n            switch (possible.direction) {\n                case Direction.TOP:\n                    if (this.generateTopRoom(possible)) {\n                        return true;\n                    }\n                    break;\n                case Direction.BOTTOM:\n                    if (this.generateBottomRoom(possible)) {\n                        return true;\n                    }\n                    break;\n                case Direction.RIGHT:\n                    if (this.generateRightRoom(possible)) {\n                        return true;\n                    }\n                    break;\n                case Direction.LEFT:\n                    if (this.generateLeftRoom(possible)) {\n                        return true;\n                    }\n                    break;\n            }\n        }\n        return false;\n    }\n    findTopCorridorArea(room) {\n        const buffer = MutableRect.from(room);\n        buffer.h = this.min_corr_dist_y;\n        buffer.y -= this.min_corr_dist_y;\n        buffer.x += this.x_dist;\n        buffer.w -= this.x_dist << 1;\n        let h = -1;\n        let y = -1;\n        for (; buffer.h <= this.max_corr_dist; buffer.h++, buffer.y--) {\n            if (this.valid(buffer)) {\n                h = buffer.h;\n                y = buffer.y;\n            }\n            else {\n                break;\n            }\n        }\n        if (h >= 0 && y >= 0) {\n            buffer.h = h;\n            buffer.y = y;\n            return buffer.immutable();\n        }\n        else {\n            return null;\n        }\n    }\n    findBottomCorridorArea(room) {\n        const buffer = MutableRect.from(room);\n        buffer.y += room.h;\n        buffer.h = this.min_corr_dist_y;\n        buffer.x += this.x_dist;\n        buffer.w -= this.x_dist << 1;\n        let h = -1;\n        for (; buffer.h < this.max_corr_dist; buffer.h++) {\n            if (this.valid(buffer)) {\n                h = buffer.h;\n            }\n            else {\n                break;\n            }\n        }\n        if (h >= 0) {\n            buffer.h = h;\n            return buffer.immutable();\n        }\n        else {\n            return null;\n        }\n    }\n    findRightCorridorArea(room) {\n        const buffer = MutableRect.from(room);\n        buffer.x += buffer.w;\n        buffer.y += this.y_dist;\n        buffer.h -= this.y_dist << 1;\n        let w = -1;\n        for (; buffer.w < this.max_corr_dist; buffer.w++) {\n            if (this.valid(buffer)) {\n                w = buffer.w;\n            }\n            else {\n                break;\n            }\n        }\n        if (w >= 0) {\n            buffer.w = w;\n            return buffer.immutable();\n        }\n        else {\n            return null;\n        }\n    }\n    findLeftCorridorArea(room) {\n        const buffer = MutableRect.from(room);\n        buffer.w = this.min_corr_dist_x;\n        buffer.x -= this.min_corr_dist_x;\n        buffer.y += this.y_dist;\n        buffer.h -= this.y_dist << 1;\n        let w = -1;\n        let x = -1;\n        for (; buffer.w <= this.max_corr_dist; buffer.w++, buffer.x--) {\n            if (this.valid(buffer)) {\n                w = buffer.w;\n                x = buffer.x;\n            }\n            else {\n                break;\n            }\n        }\n        if (w >= 0 && x >= 0) {\n            buffer.w = w;\n            buffer.x = x;\n            return buffer.immutable();\n        }\n        else {\n            return null;\n        }\n    }\n    findTopRoomArea(corridor) {\n        const buffer = MutableRect.from(corridor);\n        buffer.h -= this.min_corr_dist_y;\n        buffer.x -= this.x_dist;\n        buffer.w += this.x_dist << 1;\n        if (buffer.h < this.room_min_h) {\n            const d = this.room_min_h - buffer.h;\n            buffer.h += d;\n            buffer.y -= d;\n        }\n        let y = buffer.y;\n        let h = buffer.h;\n        for (; buffer.h <= this.room_max_h; buffer.h++, buffer.y--) {\n            if (this.valid(buffer)) {\n                h = buffer.h;\n                y = buffer.y;\n            }\n            else {\n                buffer.h = h;\n                buffer.y = y;\n                break;\n            }\n        }\n        if (y >= 0 && h >= 0) {\n            let x = buffer.x;\n            let w = buffer.w;\n            for (const min_x = corridor.x + this.x_dist + 1 - this.room_max_w; buffer.x > min_x; buffer.x--, buffer.w++) {\n                if (this.valid(buffer)) {\n                    x = buffer.x;\n                    w = buffer.w;\n                }\n                else {\n                    break;\n                }\n            }\n            buffer.x = x;\n            buffer.w = w;\n            for (const max_x = corridor.x + corridor.w - this.x_dist - 1 + this.room_max_w; buffer.x + buffer.w < max_x; buffer.w++) {\n                if (this.valid(buffer)) {\n                    w = buffer.w;\n                }\n                else {\n                    break;\n                }\n            }\n            buffer.w = w;\n            return buffer.immutable();\n        }\n        return null;\n    }\n    findBottomRoomArea(corridor) {\n        const buffer = MutableRect.from(corridor);\n        buffer.y += this.min_corr_dist_y;\n        buffer.h -= this.min_corr_dist_y;\n        buffer.x -= this.x_dist;\n        buffer.w += this.x_dist << 1;\n        if (buffer.h < this.room_min_h) {\n            buffer.h = this.room_min_h;\n        }\n        let h = buffer.h;\n        for (; buffer.h <= this.room_max_h; buffer.h++) {\n            if (this.valid(buffer)) {\n                h = buffer.h;\n            }\n            else {\n                buffer.h = h;\n                break;\n            }\n        }\n        if (h >= 0) {\n            let x = buffer.x;\n            let w = buffer.w;\n            for (const min_x = corridor.x + this.x_dist + 1 - this.room_max_w; buffer.x > min_x; buffer.x--, buffer.w++) {\n                if (this.valid(buffer)) {\n                    x = buffer.x;\n                    w = buffer.w;\n                }\n                else {\n                    break;\n                }\n            }\n            buffer.x = x;\n            buffer.w = w;\n            for (const max_x = corridor.x + corridor.w - this.x_dist - 1 + this.room_max_w; buffer.x + buffer.w < max_x; buffer.w++) {\n                if (this.valid(buffer)) {\n                    w = buffer.w;\n                }\n                else {\n                    break;\n                }\n            }\n            buffer.w = w;\n            return buffer.immutable();\n        }\n        return null;\n    }\n    findRightRoomArea(corridor) {\n        const buffer = MutableRect.from(corridor);\n        buffer.x += this.min_corr_dist_x;\n        buffer.w -= this.min_corr_dist_x;\n        buffer.y -= this.y_dist;\n        buffer.h += this.y_dist << 1;\n        if (buffer.w < this.room_min_w) {\n            buffer.w = this.room_min_w;\n        }\n        let w = buffer.w;\n        for (; buffer.w <= this.room_max_w; buffer.w++) {\n            if (this.valid(buffer)) {\n                w = buffer.w;\n            }\n            else {\n                buffer.w = w;\n                break;\n            }\n        }\n        if (w >= 0) {\n            let y = buffer.y;\n            let h = buffer.h;\n            for (const min_y = corridor.y + this.y_dist + 1 - this.room_max_h; buffer.y > min_y; buffer.y--, buffer.h++) {\n                if (this.valid(buffer)) {\n                    y = buffer.y;\n                    h = buffer.h;\n                }\n                else {\n                    buffer.y = y;\n                    buffer.h = h;\n                    break;\n                }\n            }\n            for (const max_y = corridor.y + corridor.h - this.y_dist - 1 + this.room_max_h; buffer.y + buffer.h < max_y; buffer.h++) {\n                if (this.valid(buffer)) {\n                    h = buffer.h;\n                }\n                else {\n                    buffer.h = h;\n                    break;\n                }\n            }\n            return buffer.immutable();\n        }\n        return null;\n    }\n    findLeftRoomArea(corridor) {\n        const buffer = MutableRect.from(corridor);\n        buffer.w -= this.min_corr_dist_x;\n        buffer.y -= this.y_dist;\n        buffer.h += this.y_dist << 1;\n        if (buffer.w < this.room_min_w) {\n            const d = this.room_min_w - buffer.w;\n            buffer.w += d;\n            buffer.x -= d;\n        }\n        let x = buffer.x;\n        let w = buffer.w;\n        for (; buffer.w <= this.room_max_w; buffer.w++, buffer.x--) {\n            if (this.valid(buffer)) {\n                w = buffer.w;\n                x = buffer.x;\n            }\n            else {\n                buffer.x = x;\n                buffer.w = w;\n                break;\n            }\n        }\n        if (x >= 0 && w >= 0) {\n            let y = buffer.y;\n            let h = buffer.h;\n            for (const min_y = corridor.y + this.y_dist + 1 - this.room_max_h; buffer.y > min_y; buffer.y--, buffer.h++) {\n                if (this.valid(buffer)) {\n                    y = buffer.y;\n                    h = buffer.h;\n                }\n                else {\n                    break;\n                }\n            }\n            buffer.y = y;\n            buffer.h = h;\n            for (const max_y = corridor.y - this.y_dist - 1 + this.room_max_h; buffer.y + buffer.h < max_y; buffer.h++) {\n                if (this.valid(buffer)) {\n                    h = buffer.h;\n                }\n                else {\n                    break;\n                }\n            }\n            buffer.h = h;\n            return buffer.immutable();\n        }\n        else {\n            if (this.debug)\n                console.warn(\"left room area not valid\", corridor, buffer);\n        }\n        return null;\n    }\n    generateTopRoom(possible) {\n        const corr_w = this.nextRange(1, Math.min(this.max_corr_width, possible.corridor.w));\n        const corr_h = this.nextRange(this.min_corr_dist_y, possible.corridor.h);\n        const corr_y = possible.corridor.y + (possible.corridor.h - corr_h);\n        const corr_x = this.nextRange(possible.corridor.x, possible.corridor.x + possible.corridor.w - corr_w);\n        const corr = new ImmutableRect(corr_x, corr_y, corr_w, corr_h);\n        if (this.valid(corr.expandV())) {\n            const room_min_y = Math.max(3, possible.room.y, corr.y - this.room_max_h);\n            const room_y = this.nextRange(room_min_y, corr.y - this.room_min_h);\n            const room_h = corr.y - room_y;\n            const room_max_x = corr.x - this.x_dist;\n            const room_min_x = Math.max(2, possible.room.x, corr.x + corr.w + this.x_dist - this.room_max_w);\n            const room_x = this.nextRange(room_min_x, room_max_x);\n            const room_min_right_x = corr.x + corr.w + this.x_dist;\n            const room_max_right_x = Math.min(possible.room.x + possible.room.w, room_x + this.room_max_w);\n            const room_right_x = this.nextRange(room_min_right_x, room_max_right_x);\n            const room_w = room_right_x - room_x;\n            const room = new ImmutableRect(room_x, room_y, room_w, room_h);\n            if (this.valid(room.expand())) {\n                if (this.debug)\n                    console.log(\"add top room\", corr, room);\n                this.corridorsV.push(corr);\n                this.rooms.push(room);\n                this.connectWithOthers(room);\n                return true;\n            }\n            else {\n                if (this.debug)\n                    console.warn(\"top room not valid\");\n            }\n        }\n        else {\n            if (this.debug)\n                console.warn(\"top corridor not valid\");\n        }\n        return false;\n    }\n    generateBottomRoom(possible) {\n        const corr_y = possible.corridor.y;\n        const corr_w = this.nextRange(1, Math.min(this.max_corr_width, possible.corridor.w));\n        const corr_h = this.nextRange(this.min_corr_dist_y, possible.corridor.h);\n        const corr_x = this.nextRange(possible.corridor.x, possible.corridor.x + possible.corridor.w - corr_w);\n        const corr = new ImmutableRect(corr_x, corr_y, corr_w, corr_h);\n        if (this.valid(corr.expandV())) {\n            const room_y = corr.y + corr.h;\n            const room_min_y = room_y + this.room_min_h;\n            const room_max_y = Math.min(possible.room.y + possible.room.h, room_min_y + this.room_max_h);\n            const room_bottom_y = this.nextRange(room_min_y, room_max_y);\n            const room_h = room_bottom_y - room_y;\n            const room_max_x = corr.x - this.x_dist;\n            const room_min_x = Math.max(2, possible.room.x, corr.x + corr.w + this.x_dist - this.room_max_w);\n            const room_x = this.nextRange(room_min_x, room_max_x);\n            const room_min_right_x = corr.x + corr.w + this.x_dist;\n            const room_max_right_x = Math.min(possible.room.x + possible.room.w, room_x + this.room_max_w);\n            const room_right_x = this.nextRange(room_min_right_x, room_max_right_x);\n            const room_w = room_right_x - room_x;\n            const room = new ImmutableRect(room_x, room_y, room_w, room_h);\n            if (this.valid(room.expand())) {\n                if (this.debug)\n                    console.log(\"add bottom room\", corr, room);\n                this.corridorsV.push(corr);\n                this.rooms.push(room);\n                this.connectWithOthers(room);\n                return true;\n            }\n            else {\n                if (this.debug)\n                    console.warn(\"bottom room not valid\", corr, room);\n            }\n        }\n        else {\n            if (this.debug)\n                console.warn(\"bottom corridor not valid\", corr);\n        }\n        return false;\n    }\n    generateRightRoom(possible) {\n        const corr_x = possible.corridor.x;\n        const corr_h = this.nextRange(1, Math.min(this.max_corr_width, possible.corridor.h));\n        const corr_w = this.nextRange(this.min_corr_dist_x, possible.corridor.w);\n        const corr_y = this.nextRange(possible.corridor.y, possible.corridor.y + possible.corridor.h - corr_h);\n        const corr = new ImmutableRect(corr_x, corr_y, corr_w, corr_h);\n        if (this.valid(corr.expandH())) {\n            const room_x = corr.x + corr.w;\n            const room_min_x = room_x + this.room_min_w;\n            const room_max_x = Math.min(possible.room.x + possible.room.w, room_min_x + this.room_max_w);\n            const room_right_x = this.nextRange(room_min_x, room_max_x);\n            const room_w = room_right_x - room_x;\n            const room_max_y = corr.y - this.y_dist;\n            const room_min_y = Math.max(2, possible.room.y, corr.y + corr.h + this.y_dist - this.room_max_h);\n            const room_y = this.nextRange(room_min_y, room_max_y);\n            const room_min_bottom_y = corr.y + corr.h + this.y_dist;\n            const room_max_bottom_y = Math.min(possible.room.y + possible.room.h, room_y + this.room_max_h);\n            const room_bottom_y = this.nextRange(room_min_bottom_y, room_max_bottom_y);\n            const room_h = room_bottom_y - room_y;\n            const room = new ImmutableRect(room_x, room_y, room_w, room_h);\n            if (this.valid(room.expand())) {\n                if (this.debug)\n                    console.log(\"add right room\", corr, room);\n                this.corridorsH.push(corr);\n                this.rooms.push(room);\n                this.connectWithOthers(room);\n                return true;\n            }\n            else {\n                if (this.debug)\n                    console.warn(\"right room not valid\", corr, room);\n            }\n        }\n        else {\n            if (this.debug)\n                console.warn(\"right corridor not valid\", corr);\n        }\n        return false;\n    }\n    generateLeftRoom(possible) {\n        const corr_h = this.nextRange(1, Math.min(this.max_corr_width, possible.corridor.h));\n        const corr_w = this.nextRange(this.min_corr_dist_x, possible.corridor.w);\n        const corr_x = possible.corridor.x + (possible.corridor.w - corr_w);\n        const corr_y = this.nextRange(possible.corridor.y, possible.corridor.y + possible.corridor.h - corr_h);\n        const corr = new ImmutableRect(corr_x, corr_y, corr_w, corr_h);\n        if (this.valid(corr.expandH())) {\n            const room_min_x = Math.max(2, possible.room.x, corr.x - this.room_max_w);\n            const room_x = this.nextRange(room_min_x, corr.x - this.room_min_w);\n            const room_w = corr.x - room_x;\n            const room_max_y = corr.y - this.y_dist;\n            const room_min_y = Math.max(3, possible.room.y, corr.y + corr.h + this.y_dist - this.room_max_h);\n            const room_y = this.nextRange(room_min_y, room_max_y);\n            const room_min_bottom_y = corr.y + corr.h + this.y_dist;\n            const room_max_bottom_y = Math.min(possible.room.y + possible.room.h, room_y + this.room_max_h);\n            const room_bottom_y = this.nextRange(room_min_bottom_y, room_max_bottom_y);\n            const room_h = room_bottom_y - room_y;\n            const room = new ImmutableRect(room_x, room_y, room_w, room_h);\n            if (this.valid(room.expand())) {\n                if (this.debug)\n                    console.log(\"add left room\", corr, room);\n                this.corridorsH.push(corr);\n                this.rooms.push(room);\n                this.connectWithOthers(room);\n                return true;\n            }\n            else {\n                if (this.debug)\n                    console.warn(\"left room not valid\");\n            }\n        }\n        else {\n            if (this.debug)\n                console.warn(\"left corridor not valid\");\n        }\n        return false;\n    }\n    connectWithOthers(room) {\n        const a = room;\n        for (let i = 0; i < this.rooms.length - 1; i++) {\n            let b = this.rooms[i];\n            const max_x = Math.max(a.x, b.x);\n            const min_x_w = Math.min(a.x + a.w, b.x + b.w);\n            if (max_x + 5 <= min_x_w) {\n                let rect;\n                if (a.y + a.h < b.y) {\n                    rect = new ImmutableRect(max_x + 2, a.y + a.h, min_x_w - max_x - 4, b.y - a.y - a.h);\n                }\n                else {\n                    rect = new ImmutableRect(max_x + 2, b.y + b.h, min_x_w - max_x - 4, a.y - b.y - b.h);\n                }\n                if (this.debug)\n                    console.log(\"test v corr\", rect);\n                if (rect.w < this.max_corr_dist && this.valid(rect.expandV())) {\n                    if (this.debug)\n                        console.log(\"add v corr\", rect);\n                    this.corridorsV.push(rect);\n                }\n            }\n            const max_y = Math.max(a.y, b.y);\n            const min_y_h = Math.min(a.y + a.h, b.y + b.h);\n            if (max_y + 3 <= min_y_h) {\n                let rect;\n                if (a.x + a.w < b.x) {\n                    rect = new ImmutableRect(a.x + a.w, max_y + 1, b.x - a.x - a.w, min_y_h - max_y - 2);\n                }\n                else {\n                    rect = new ImmutableRect(b.x + b.w, max_y + 1, a.x - b.x - b.w, min_y_h - max_y - 2);\n                }\n                if (this.debug)\n                    console.log(\"test h corr\", rect);\n                if (rect.h < this.max_corr_dist && this.valid(rect.expandH())) {\n                    if (this.debug)\n                        console.log(\"add h corr\", rect);\n                    this.corridorsH.push(rect);\n                }\n            }\n        }\n    }\n    nextRange(min, max) {\n        return Math.round(this.rng.nextNormal(min, max, this.skew));\n    }\n}\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"TOP\"] = 0] = \"TOP\";\n    Direction[Direction[\"RIGHT\"] = 1] = \"RIGHT\";\n    Direction[Direction[\"BOTTOM\"] = 2] = \"BOTTOM\";\n    Direction[Direction[\"LEFT\"] = 3] = \"LEFT\";\n})(Direction || (Direction = {}));\nclass Possible {\n    constructor(room, corridor, direction) {\n        this.room = room;\n        this.corridor = corridor;\n        this.direction = direction;\n    }\n}\n\n// CONCATENATED MODULE: ./src/indexer.ts\nclass Indexer {\n    constructor(equality) {\n        this.values = [];\n        this.equality = equality;\n    }\n    index(value) {\n        for (let i = 0; i < this.values.length; i++) {\n            if (this.equality(value, this.values[i])) {\n                return i;\n            }\n        }\n        this.values.push(value);\n        return this.values.length - 1;\n    }\n    get(n) {\n        return this.values[n];\n    }\n    static array() {\n        return new Indexer((a, b) => {\n            if (a.length !== b.length)\n                return false;\n            for (let i = 0; i < a.length; i++) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        });\n    }\n    static identity() {\n        return new Indexer((a, b) => a === b);\n    }\n}\n\n// CONCATENATED MODULE: ./src/tunneler/model.ts\nclass Point {\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    plus(that) {\n        return new Point(this.x + that.x, this.y + that.y);\n    }\n    minus(that) {\n        return new Point(this.x - that.x, this.y - that.y);\n    }\n    multiply(value) {\n        return new Point(this.x * value, this.y * value);\n    }\n    get negative() {\n        return new Point(-this.x, -this.y);\n    }\n    equal(x, y) {\n        return this.x === x && this.y === y;\n    }\n    equals(that) {\n        return this.x === that.x && this.y === that.y;\n    }\n    toString() {\n        return `{x: ${this.x}, y: ${this.y}}`;\n    }\n    static from(point) {\n        return new Point(point.x, point.y);\n    }\n}\nPoint.NORTH = new Point(-1, 0);\nPoint.SOUTH = new Point(1, 0);\nPoint.EAST = new Point(0, 1);\nPoint.WEST = new Point(0, -1);\nPoint.NORTH_EAST = new Point(-1, 1);\nPoint.SOUTH_EAST = new Point(1, 1);\nPoint.SOUTH_WEST = new Point(1, -1);\nPoint.NORTH_WEST = new Point(-1, -1);\nPoint.ZERO = new Point(0, 0);\nvar model_Direction;\n(function (Direction) {\n    Direction[Direction[\"NORTH\"] = 0] = \"NORTH\";\n    Direction[Direction[\"EAST\"] = 1] = \"EAST\";\n    Direction[Direction[\"SOUTH\"] = 2] = \"SOUTH\";\n    Direction[Direction[\"WEST\"] = 3] = \"WEST\";\n    Direction[Direction[\"NORTH_EAST\"] = 4] = \"NORTH_EAST\";\n    Direction[Direction[\"SOUTH_EAST\"] = 5] = \"SOUTH_EAST\";\n    Direction[Direction[\"SOUTH_WEST\"] = 6] = \"SOUTH_WEST\";\n    Direction[Direction[\"NORTH_WEST\"] = 7] = \"NORTH_WEST\";\n})(model_Direction || (model_Direction = {}));\nvar TunnelerCellType;\n(function (TunnelerCellType) {\n    TunnelerCellType[TunnelerCellType[\"OPEN\"] = 0] = \"OPEN\";\n    TunnelerCellType[TunnelerCellType[\"CLOSED\"] = 1] = \"CLOSED\";\n    TunnelerCellType[TunnelerCellType[\"GUARANTEED_OPEN\"] = 2] = \"GUARANTEED_OPEN\";\n    TunnelerCellType[TunnelerCellType[\"GUARANTEED_CLOSED\"] = 3] = \"GUARANTEED_CLOSED\";\n    TunnelerCellType[TunnelerCellType[\"NON_JOIN_OPEN\"] = 4] = \"NON_JOIN_OPEN\";\n    TunnelerCellType[TunnelerCellType[\"NON_JOIN_CLOSED\"] = 5] = \"NON_JOIN_CLOSED\";\n    TunnelerCellType[TunnelerCellType[\"NON_JOIN_GUARANTEED_OPEN\"] = 6] = \"NON_JOIN_GUARANTEED_OPEN\";\n    TunnelerCellType[TunnelerCellType[\"NON_JOIN_GUARANTEED_CLOSED\"] = 7] = \"NON_JOIN_GUARANTEED_CLOSED\";\n    TunnelerCellType[TunnelerCellType[\"INSIDE_ROOM_OPEN\"] = 8] = \"INSIDE_ROOM_OPEN\";\n    TunnelerCellType[TunnelerCellType[\"INSIDE_TUNNEL_OPEN\"] = 9] = \"INSIDE_TUNNEL_OPEN\";\n    TunnelerCellType[TunnelerCellType[\"INSIDE_ANTEROOM_OPEN\"] = 10] = \"INSIDE_ANTEROOM_OPEN\";\n    TunnelerCellType[TunnelerCellType[\"H_DOOR\"] = 11] = \"H_DOOR\";\n    TunnelerCellType[TunnelerCellType[\"V_DOOR\"] = 12] = \"V_DOOR\";\n    TunnelerCellType[TunnelerCellType[\"COLUMN\"] = 13] = \"COLUMN\";\n})(TunnelerCellType || (TunnelerCellType = {}));\nvar RoomSize;\n(function (RoomSize) {\n    RoomSize[RoomSize[\"SMALL\"] = 0] = \"SMALL\";\n    RoomSize[RoomSize[\"MEDIUM\"] = 1] = \"MEDIUM\";\n    RoomSize[RoomSize[\"LARGE\"] = 2] = \"LARGE\";\n})(RoomSize || (RoomSize = {}));\nclass Room {\n    constructor(inside = []) {\n        this.inside = inside;\n        this.inDungeon = false;\n    }\n    randomSquare() {\n        return this.inside[Math.floor(Math.random() * this.inside.length)];\n    }\n    static compare(first, second) {\n        return first.inside.length - second.inside.length;\n    }\n}\nclass FillRect {\n    constructor(startX, startY, endX, endY, type) {\n        this.startX = startX;\n        this.startY = startY;\n        this.endX = endX;\n        this.endY = endY;\n        this.type = type;\n    }\n}\n\n// CONCATENATED MODULE: ./src/tunneler/crawler.ts\n\nclass crawler_Crawler {\n    constructor(rng, dungeonCrawler, location, direction, age, maxAge, generation) {\n        this.rng = rng;\n        this.dungeonCrawler = dungeonCrawler;\n        this.config = dungeonCrawler.config;\n        this.location = location;\n        this.direction = direction;\n        this.age = age;\n        this.maxAge = maxAge;\n        this.generation = generation;\n        console.assert(this.valid(location));\n        console.assert(this.validDirection(direction));\n    }\n    rightDirection() {\n        if (this.direction.x === 0) {\n            return new Point(this.direction.y, 0);\n        }\n        else if (this.direction.y === 0) {\n            return new Point(0, -this.direction.x);\n        }\n        else {\n            throw \"illegal direction\";\n        }\n    }\n    valid(point) {\n        return point.x >= 0 && point.y >= 0 && point.x < this.config.width && point.y < this.config.height;\n    }\n    validDirection(direction) {\n        return (direction.x === 0 && (direction.y === -1 || direction.y === 1)) || (direction.y === 0 && (direction.x === -1 || direction.x === 1));\n    }\n    frontFree(position, heading, leftFree, rightFree) {\n        console.assert((leftFree >= 1) && (rightFree >= 1));\n        console.assert(this.valid(position));\n        console.assert(heading.x === 0 && ((heading.y === 1) || (heading.y === -1)) || heading.y === 0 && ((heading.x === 1) || (heading.x === -1)));\n        let right;\n        if (heading.x === 0) {\n            right = new Point(heading.y, 0);\n        }\n        else if (heading.y === 0) {\n            right = new Point(0, -heading.x);\n        }\n        else {\n            throw \"invalid heading\";\n        }\n        const frontFree = this.findFrontFree(leftFree, rightFree, position, right, heading);\n        console.assert(frontFree >= 0);\n        if (frontFree > 0) {\n            leftFree = this.findLeftFree(leftFree, frontFree, position, right, heading);\n            rightFree = this.findRightFree(rightFree, frontFree, position, right, heading);\n        }\n        return [frontFree, leftFree, rightFree];\n    }\n    findFrontFree(leftFree, rightFree, position, right, heading) {\n        let frontFree = 0;\n        while (true) {\n            frontFree++;\n            for (let i = -leftFree; i <= rightFree; i++) {\n                const cell = position.plus(right.multiply(i)).plus(heading.multiply(frontFree));\n                if (!this.valid(cell)) {\n                    return Math.max(0, frontFree - 1);\n                }\n                if (this.freePredicate(this.dungeonCrawler.getMap(cell))) {\n                    return Math.max(0, frontFree - 1);\n                }\n            }\n        }\n    }\n    findLeftFree(leftFree, frontFree, position, right, heading) {\n        while (true) {\n            leftFree++;\n            for (let i = 1; i <= frontFree; i++) {\n                const cell = position.minus(right.multiply(leftFree)).plus(heading.multiply(i));\n                if (!this.valid(cell)) {\n                    return leftFree - 1;\n                }\n                if (this.freePredicate(this.dungeonCrawler.getMap(cell))) {\n                    return leftFree - 1;\n                }\n            }\n        }\n    }\n    findRightFree(rightFree, frontFree, position, right, heading) {\n        while (true) {\n            rightFree++;\n            for (let i = 1; i <= frontFree; i++) {\n                const cell = position.plus(right.multiply(rightFree)).plus(heading.multiply(i));\n                if (!this.valid(cell)) {\n                    return rightFree - 1;\n                }\n                if (this.freePredicate(this.dungeonCrawler.getMap(cell))) {\n                    return rightFree - 1;\n                }\n            }\n        }\n    }\n    freePredicate(type) {\n        return (type !== TunnelerCellType.CLOSED) && (type !== TunnelerCellType.NON_JOIN_CLOSED);\n    }\n    contains(value, ...options) {\n        for (const option of options) {\n            if (value === option) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n// CONCATENATED MODULE: ./src/tunneler/wall.crawler.ts\n\n\nclass wall_crawler_WallCrawler extends crawler_Crawler {\n    constructor(rng, dungeonCrawler, location, direction, age, maxAge, generation, intendedDirection, stepLength, opening, corridorWidth, straightSingleSpawnProbability, straightDoubleSpawnProbability, turnSingleSpawnProbability, turnDoubleSpawnProbability, changeDirectionProbability) {\n        super(rng, dungeonCrawler, location, direction, age, maxAge, generation);\n        this.intendedDirection = intendedDirection;\n        this.stepLength = stepLength;\n        this.opening = opening;\n        this.corridorWidth = corridorWidth;\n        this.straightSingleSpawnProbability = straightSingleSpawnProbability;\n        this.straightDoubleSpawnProbability = straightDoubleSpawnProbability;\n        this.turnSingleSpawnProbability = turnSingleSpawnProbability;\n        this.turnDoubleSpawnProbability = turnDoubleSpawnProbability;\n        this.changeDirectionProbability = changeDirectionProbability;\n        console.assert(corridorWidth >= 0);\n    }\n    freePredicate(type) {\n        if (this.config.crawlersInTunnels && this.config.crawlersInAnterooms) {\n            if (!this.contains(type, TunnelerCellType.OPEN, TunnelerCellType.NON_JOIN_OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN, TunnelerCellType.NON_JOIN_GUARANTEED_OPEN)) {\n                return true;\n            }\n        }\n        else if (this.config.crawlersInTunnels) {\n            if (!this.contains(type, TunnelerCellType.OPEN, TunnelerCellType.NON_JOIN_OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.NON_JOIN_GUARANTEED_OPEN)) {\n                return true;\n            }\n        }\n        else {\n            if (!this.contains(type, TunnelerCellType.OPEN, TunnelerCellType.NON_JOIN_OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.NON_JOIN_GUARANTEED_OPEN)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    stepAhead() {\n        if (this.generation !== this.dungeonCrawler.activeGeneration) {\n            console.assert(this.generation > this.dungeonCrawler.activeGeneration);\n            return true;\n        }\n        this.age++;\n        if (this.age >= this.maxAge) {\n            return false;\n        }\n        else if (this.age < 0) {\n            return true;\n        }\n        let [frontFree, leftFree, rightFree] = this.frontFree(this.location, this.direction, this.corridorWidth, this.corridorWidth);\n        const right = this.rightDirection();\n        const left = right.negative;\n        let test = right;\n        if ((this.opening === 0) && (frontFree < this.config.joinDistance)) {\n            if (this.join(frontFree)) {\n                return false;\n            }\n        }\n        let tilesLaid = this.stepLength;\n        if (frontFree > this.corridorWidth) {\n            if ((frontFree - this.corridorWidth) < this.stepLength) {\n                tilesLaid = frontFree - this.corridorWidth;\n            }\n            for (let i = 1; i <= tilesLaid; i++) {\n                test = this.location.plus(this.direction.multiply(i));\n                if (this.opening === 1) {\n                    this.dungeonCrawler.setMap(test, TunnelerCellType.CLOSED);\n                }\n                else {\n                    console.assert(this.opening === 0);\n                    this.dungeonCrawler.setMap(test, TunnelerCellType.NON_JOIN_CLOSED);\n                }\n            }\n            this.location = test;\n            let diceRoll = this.rng.int % 100;\n            let childGeneration = this.generation + 1;\n            let summedProbability = 0;\n            for (let i = 0; i <= 10; i++) {\n                summedProbability = summedProbability + this.getChildDelayProbabilityForGenerationCrawlers(i);\n                if (diceRoll < summedProbability) {\n                    childGeneration = this.generation + i;\n                    break;\n                }\n            }\n            const options = {\n                straightSingleSpawnProbability: this.dungeonCrawler.mutate(this.straightSingleSpawnProbability),\n                straightDoubleSpawnProbability: this.dungeonCrawler.mutate(this.straightDoubleSpawnProbability),\n                turnSingleSpawnProbability: this.dungeonCrawler.mutate(this.turnSingleSpawnProbability),\n                turnDoubleSpawnProbability: this.dungeonCrawler.mutate(this.turnDoubleSpawnProbability),\n                changeDirectionProbability: this.dungeonCrawler.mutate(this.changeDirectionProbability),\n            };\n            if ((this.rng.int % 100) < this.changeDirectionProbability) {\n                let oldDirection = this.direction;\n                if (((this.intendedDirection.x === 0) && (this.intendedDirection.y === 0)) ||\n                    ((this.intendedDirection.x === this.direction.x) && (this.intendedDirection.y === this.direction.y))) {\n                    let random = this.rng.int % 4;\n                    if (random === 0) {\n                        this.direction = right;\n                    }\n                    else if (random === 1) {\n                        this.direction = left;\n                    }\n                    else {\n                        if ((rightFree > leftFree) || ((rightFree === leftFree) && this.rng.boolean)) {\n                            this.direction = right;\n                        }\n                        else {\n                            this.direction = left;\n                        }\n                    }\n                }\n                else {\n                    if ((this.intendedDirection.x === 0) || (this.intendedDirection.y === 0)) {\n                        this.direction = this.intendedDirection;\n                    }\n                    else {\n                        console.assert(!this.intendedDirection.equal(0, 0));\n                        this.direction = this.intendedDirection.minus(this.direction);\n                    }\n                }\n                if ((this.rng.int % 100) < this.turnDoubleSpawnProbability) {\n                    this.spawnWallCrawler(this.direction.negative, this.direction.negative, childGeneration, options);\n                    this.spawnWallCrawler(oldDirection, oldDirection, childGeneration, options);\n                }\n                else if ((this.rng.int % 100) < this.turnSingleSpawnProbability) {\n                    this.spawnWallCrawler(this.direction.negative, this.direction.negative, childGeneration, options);\n                }\n            }\n            else {\n                if ((this.rng.int % 100) < this.straightDoubleSpawnProbability) {\n                    this.spawnWallCrawler(right, right, childGeneration, options);\n                    this.spawnWallCrawler(left, left, childGeneration, options);\n                }\n                else if ((this.rng.int % 100) < this.straightSingleSpawnProbability) {\n                    if (leftFree > rightFree || leftFree === rightFree && this.rng.boolean) {\n                        test = left;\n                    }\n                    else {\n                        test = right;\n                    }\n                    if ((this.rng.int % 3) === 0) {\n                        test = test.negative;\n                    }\n                    this.spawnWallCrawler(test, test, childGeneration, options);\n                }\n            }\n        }\n        else {\n            if (this.direction.equals(this.intendedDirection) || this.intendedDirection.equal(0, 0)) {\n                let [rightFree] = this.frontFree(this.location, right, this.corridorWidth, this.corridorWidth);\n                let [leftFree] = this.frontFree(this.location, left, this.corridorWidth, this.corridorWidth);\n                if ((rightFree <= this.corridorWidth) && (leftFree <= this.corridorWidth)) {\n                    return false;\n                }\n                else if ((rightFree > 2 * this.corridorWidth + 1) && (leftFree > 2 * this.corridorWidth + 1)) {\n                    if (this.rng.boolean) {\n                        this.direction = right;\n                    }\n                    else {\n                        this.direction = left;\n                    }\n                }\n                else if (rightFree > leftFree)\n                    this.direction = right;\n                else if (leftFree > rightFree)\n                    this.direction = left;\n                else if (this.rng.boolean) {\n                    this.direction = right;\n                }\n                else {\n                    this.direction = left;\n                }\n            }\n            else {\n                if ((this.intendedDirection.x === 0) || (this.intendedDirection.y === 0)) {\n                    let [directionFree] = this.frontFree(this.location, this.intendedDirection, this.corridorWidth, this.corridorWidth);\n                    if (directionFree > this.corridorWidth) {\n                        this.direction = this.intendedDirection;\n                    }\n                    else {\n                        return false;\n                    }\n                }\n                else {\n                    console.assert(!this.intendedDirection.equal(0, 0));\n                    test = this.intendedDirection.minus(this.direction);\n                    let [testFree] = this.frontFree(this.location, test, this.corridorWidth, this.corridorWidth);\n                    if (testFree > this.corridorWidth) {\n                        this.direction = test;\n                    }\n                    else {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    spawnWallCrawler(direction, intendedDirection, generation, options) {\n        if ((this.rng.int % 100) < this.config.noHeadingProbability) {\n            intendedDirection = Point.ZERO;\n        }\n        this.dungeonCrawler.createWallCrawler(this.location, direction, 0, this.dungeonCrawler.getMaxAgeCrawlers(generation), generation, intendedDirection, this.dungeonCrawler.getStepLength(generation), 1, this.dungeonCrawler.getCorridorWidth(generation), options.straightSingleSpawnProbability, options.straightDoubleSpawnProbability, options.turnSingleSpawnProbability, options.turnDoubleSpawnProbability, options.changeDirectionProbability);\n    }\n    join(frontFree) {\n        let right = this.rightDirection();\n        let test = this.location.plus(this.direction.multiply(frontFree + 1));\n        if (!this.valid(test)) {\n            return false;\n        }\n        let type = this.dungeonCrawler.getMap(test);\n        if (this.contains(type, TunnelerCellType.CLOSED, TunnelerCellType.GUARANTEED_CLOSED)) {\n            for (let i = 1; i <= frontFree; i++) {\n                const point = this.location.plus(this.direction.multiply(i));\n                if (!this.valid(point)) {\n                    return false;\n                }\n                this.dungeonCrawler.setMap(point, TunnelerCellType.NON_JOIN_CLOSED);\n            }\n            return true;\n        }\n        else if (this.contains(type, TunnelerCellType.NON_JOIN_CLOSED, TunnelerCellType.NON_JOIN_GUARANTEED_CLOSED)) {\n            return false;\n        }\n        let wall = new Point();\n        let sidestep = 0;\n        for (let i = 1; i <= this.corridorWidth; i++) {\n            let point = this.location.plus(right.multiply(i)).plus(this.direction.multiply(frontFree + 1));\n            if (!this.valid(point)) {\n                return false;\n            }\n            type = this.dungeonCrawler.getMap(point);\n            if (this.contains(type, TunnelerCellType.CLOSED, TunnelerCellType.GUARANTEED_CLOSED, TunnelerCellType.NON_JOIN_CLOSED, TunnelerCellType.NON_JOIN_GUARANTEED_CLOSED)) {\n                wall = point;\n                sidestep = i;\n                break;\n            }\n            point = this.location.minus(right.multiply(i).plus(this.direction.multiply(frontFree + 1)));\n            if (!this.valid(point)) {\n                return false;\n            }\n            type = this.dungeonCrawler.getMap(point);\n            if (this.contains(type, TunnelerCellType.CLOSED, TunnelerCellType.GUARANTEED_CLOSED, TunnelerCellType.NON_JOIN_CLOSED, TunnelerCellType.NON_JOIN_GUARANTEED_CLOSED)) {\n                wall = point;\n                sidestep = -i;\n                break;\n            }\n        }\n        if ((wall.x !== 0) || (wall.y !== 0)) {\n            return false;\n        }\n        if (sidestep !== 0) {\n            return false;\n        }\n        if (this.contains(type, TunnelerCellType.NON_JOIN_CLOSED, TunnelerCellType.NON_JOIN_GUARANTEED_CLOSED)) {\n            return false;\n        }\n        if (sidestep < 0) {\n            test = right;\n        }\n        else {\n            test = right.negative;\n        }\n        let [free] = this.frontFree(wall, test, 1, 1);\n        let abs_sidestep;\n        let factor_sidestep;\n        if (sidestep > 0) {\n            abs_sidestep = sidestep;\n            factor_sidestep = 1;\n        }\n        else {\n            abs_sidestep = -sidestep;\n            factor_sidestep = -1;\n        }\n        if (free < abs_sidestep + 1) {\n            return false;\n        }\n        for (let i = 1; i <= frontFree + 1; i++) {\n            const point = this.location.plus(this.direction.multiply(i));\n            if (!this.valid(point)) {\n                return false;\n            }\n            this.dungeonCrawler.setMap(point, TunnelerCellType.NON_JOIN_CLOSED);\n        }\n        for (let i = 1; i < abs_sidestep; i++) {\n            const point = this.location.plus(right.multiply(i * factor_sidestep)).plus(this.direction.multiply(frontFree + 1));\n            if (!this.valid(point)) {\n                return false;\n            }\n            this.dungeonCrawler.setMap(point, TunnelerCellType.NON_JOIN_CLOSED);\n        }\n        return true;\n    }\n    getChildDelayProbabilityForGenerationCrawlers(generation) {\n        if ((0 <= generation) && (generation <= 10)) {\n            return this.config.childDelayProbabilityForGenerationCrawlers[generation];\n        }\n        else {\n            return 0;\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/tunneler/tunnel.crawler.ts\n\n\nclass tunnel_crawler_TunnelCrawler extends crawler_Crawler {\n    constructor(rng, dungeonCrawler, location, direction, age, maxAge, generation, intendedDirection, stepLength, tunnelWidth, straightDoubleSpawnProbability, turnDoubleSpawnProbability, changeDirectionProbability, makeRoomsRightProbability, makeRoomsLeftProbability, joinPreference) {\n        super(rng, dungeonCrawler, location, direction, age, maxAge, generation);\n        this.intendedDirection = intendedDirection;\n        this.stepLength = stepLength;\n        this.tunnelWidth = tunnelWidth;\n        this.straightDoubleSpawnProbability = straightDoubleSpawnProbability;\n        this.turnDoubleSpawnProbability = turnDoubleSpawnProbability;\n        this.changeDirectionProbability = changeDirectionProbability;\n        this.makeRoomsRightProbability = makeRoomsRightProbability;\n        this.makeRoomsLeftProbability = makeRoomsLeftProbability;\n        this.joinPreference = joinPreference;\n    }\n    stepAhead() {\n        const dungeonCrawler = this.dungeonCrawler;\n        if (this.generation !== dungeonCrawler.activeGeneration) {\n            console.assert(this.generation > dungeonCrawler.activeGeneration);\n            return true;\n        }\n        this.age++;\n        if (this.age >= this.maxAge)\n            return false;\n        else if (this.age < 0)\n            return true;\n        console.assert(this.tunnelWidth >= 0);\n        let [frontFree, leftFree, rightFree] = this.frontFree(this.location, this.direction, this.tunnelWidth + 1, this.tunnelWidth + 1);\n        if (frontFree === 0) {\n            return false;\n        }\n        let [sizeSideways, sizeBranching] = this.sidewaysBranchingRoomSizes();\n        let right = this.rightDirection();\n        let left = right.negative;\n        const roomGeneration = this.roomGeneration();\n        if ((frontFree < (2 * this.stepLength)) || ((this.maxAge - 1) === this.age)) {\n            return this.joinOrBuildTerminatingRoom(sizeBranching, frontFree, leftFree, rightFree, right, left);\n        }\n        console.assert(frontFree >= 2 * this.stepLength);\n        console.assert(this.stepLength > 0);\n        this.buildTunnel(this.stepLength, this.tunnelWidth);\n        if ((this.rng.int % 100) < this.makeRoomsRightProbability) {\n            let spawnPoint = this.location.plus(this.direction.multiply((this.stepLength >> 1 + 1))).plus(right.multiply(this.tunnelWidth));\n            this.spawnRoomCrawler(spawnPoint, right, -1, 2, roomGeneration, sizeSideways, false);\n        }\n        if ((this.rng.int % 100) < this.makeRoomsLeftProbability) {\n            let spawnPoint = this.location.plus(this.direction.multiply((this.stepLength >> 1 + 1))).plus(left.multiply(this.tunnelWidth));\n            this.spawnRoomCrawler(spawnPoint, left, -1, 2, roomGeneration, sizeSideways, false);\n        }\n        this.location = this.location.plus(this.direction.multiply(this.stepLength));\n        const smallAnteroomPossible = this.isAnteroomPossible(right, this.tunnelWidth + 2, this.tunnelWidth + 2, 2 * this.tunnelWidth + 5);\n        const largeAnteroomPossible = this.isAnteroomPossible(right, this.tunnelWidth + 3, this.tunnelWidth + 3, 2 * this.tunnelWidth + 7);\n        let sizeUpTunnel = false;\n        let sizeDownTunnel = false;\n        let diceRoll = this.rng.int % 100;\n        const sizeUpProbability = this.getSizeUpProbability(this.generation);\n        let sizeDownProbability = sizeUpProbability + this.getSizeDownProbability(this.generation);\n        if (diceRoll < sizeUpProbability) {\n            sizeUpTunnel = true;\n        }\n        else if (diceRoll < sizeDownProbability) {\n            sizeDownTunnel = true;\n        }\n        if (sizeUpTunnel && !largeAnteroomPossible) {\n            return true;\n        }\n        const changeDirection = this.isChangeDirection();\n        const doSpawn = this.isSpawn(changeDirection);\n        if (!changeDirection && !doSpawn) {\n            return true;\n        }\n        const doSpawnRoom = this.isSpawnRoom(doSpawn);\n        const diceRollSpawn = this.rng.int % 100;\n        let childGeneration = this.generation + 1;\n        if (doSpawn) {\n            if (!sizeUpTunnel) {\n                let summedProbability = 0;\n                for (let i = 0; i <= 10; i++) {\n                    summedProbability = summedProbability + this.getChildDelayProbabilityForGenerationTunnelCrawlers(i);\n                    if (diceRollSpawn < summedProbability) {\n                        childGeneration = this.generation + i;\n                        break;\n                    }\n                }\n            }\n            else {\n                childGeneration = this.generation + this.config.sizeUpGenDelay;\n            }\n        }\n        const options = this.mutateOptions();\n        let spawnPoints = this.determineSpawnPoints(sizeUpTunnel, doSpawn, smallAnteroomPossible, right, left);\n        if (spawnPoints === true) {\n            return true;\n        }\n        const [spawnPointDirection, spawnPointRight, spawnPointLeft, builtAnteroom] = spawnPoints;\n        let usedRight = false;\n        let usedLeft = false;\n        let oldDirection = this.direction;\n        let goStraight = false;\n        if (changeDirection) {\n            let [frontFreeRight] = this.frontFree(spawnPointRight, right, this.tunnelWidth + 1, this.tunnelWidth + 1);\n            let [frontFreeLeft] = this.frontFree(spawnPointLeft, left, this.tunnelWidth + 1, this.tunnelWidth + 1);\n            if (this.intendedDirection.equal(0, 0) || this.intendedDirection.equals(this.direction)) {\n                if ((!sizeUpTunnel) || (!doSpawn)) {\n                    if ((frontFreeRight > frontFreeLeft) || ((frontFreeRight === frontFreeLeft) && this.rng.boolean)) {\n                        if (frontFreeRight > 0) {\n                            this.location = spawnPointRight;\n                            this.direction = right;\n                            usedRight = true;\n                        }\n                    }\n                    else if (frontFreeLeft > 0) {\n                        this.location = spawnPointLeft;\n                        this.direction = left;\n                        usedLeft = true;\n                    }\n                }\n                else {\n                    console.assert(doSpawn);\n                    if ((frontFreeRight < frontFreeLeft) || ((frontFreeRight === frontFreeLeft) && this.rng.boolean)) {\n                        if (frontFreeRight > 0) {\n                            this.location = spawnPointRight;\n                            this.direction = right;\n                            usedRight = true;\n                        }\n                    }\n                    else if (frontFreeLeft > 0) {\n                        this.location = spawnPointLeft;\n                        this.direction = left;\n                        usedLeft = true;\n                    }\n                }\n            }\n            else {\n                if ((this.intendedDirection.x === 0) || (this.intendedDirection.y === 0)) {\n                    this.direction = this.intendedDirection;\n                    if ((this.direction.equals(right))) {\n                        if (frontFreeRight > 0) {\n                            usedRight = true;\n                            this.location = spawnPointRight;\n                        }\n                    }\n                    else if (frontFreeLeft > 0) {\n                        console.assert(this.direction.equals(left));\n                        this.location = spawnPointLeft;\n                        usedLeft = true;\n                    }\n                }\n                else {\n                    console.assert(!this.intendedDirection.equal(0, 0));\n                    this.direction = this.intendedDirection.minus(this.direction);\n                    if (this.direction.equals(right)) {\n                        if (frontFreeRight > 0) {\n                            usedRight = true;\n                            this.location = spawnPointRight;\n                        }\n                    }\n                    else if (frontFreeLeft > 0) {\n                        console.assert(this.direction.equals(left));\n                        this.location = spawnPointLeft;\n                        usedLeft = true;\n                    }\n                }\n            }\n            if (doSpawn) {\n                let spawnPoint = Point.ZERO;\n                let spawnDirection = Point.ZERO;\n                if (usedLeft) {\n                    spawnPoint = spawnPointRight;\n                    spawnDirection = right;\n                }\n                else if (usedRight) {\n                    spawnPoint = spawnPointLeft;\n                    spawnDirection = left;\n                }\n                else {\n                    goStraight = true;\n                }\n                if (!goStraight) {\n                    let diceRoll = this.rng.int % 100;\n                    if (doSpawnRoom && (diceRoll < 50)) {\n                        this.spawnRoomCrawler(spawnPoint, spawnDirection, 0, 2, roomGeneration, sizeBranching, builtAnteroom);\n                    }\n                    else {\n                        this.spawnTunnelCrawler(sizeUpTunnel, sizeDownTunnel, spawnPoint, spawnDirection, childGeneration, spawnDirection, options);\n                    }\n                    if (doSpawnRoom && (diceRoll >= 50)) {\n                        this.spawnRoomCrawler(spawnPointDirection, oldDirection, 0, 2, roomGeneration, sizeBranching, builtAnteroom);\n                    }\n                    else {\n                        this.spawnTunnelCrawler(sizeUpTunnel, sizeDownTunnel, spawnPointDirection, oldDirection, childGeneration, oldDirection, options);\n                    }\n                }\n            }\n        }\n        else {\n            goStraight = true;\n        }\n        if (goStraight) {\n            this.location = spawnPointDirection;\n            const diceRoll = this.rng.int % 100;\n            if (doSpawnRoom && (diceRoll < 50)) {\n                this.spawnRoomCrawler(spawnPointRight, right, 0, 2, roomGeneration, sizeBranching, builtAnteroom);\n            }\n            else {\n                this.spawnTunnelCrawler(sizeUpTunnel, sizeDownTunnel, spawnPointRight, right, childGeneration, right, options);\n            }\n            if (doSpawnRoom && (diceRoll >= 50)) {\n                this.spawnRoomCrawler(spawnPointRight, left, 0, 2, roomGeneration, sizeBranching, builtAnteroom);\n            }\n            else {\n                this.spawnTunnelCrawler(sizeUpTunnel, sizeDownTunnel, spawnPointLeft, left, childGeneration, left, options);\n            }\n        }\n        return true;\n    }\n    isAnteroomPossible(right, leftFree, rightFree, minFrontFree) {\n        const dungeonCrawler = this.dungeonCrawler;\n        let anteroomPossible = false;\n        console.assert(this.tunnelWidth >= 0);\n        console.assert(dungeonCrawler.getMap(this.location) === TunnelerCellType.INSIDE_TUNNEL_OPEN);\n        dungeonCrawler.setMap(this.location, TunnelerCellType.CLOSED);\n        for (let m = 1; m <= this.tunnelWidth; m++) {\n            console.assert(dungeonCrawler.getMap(this.location.plus(right.multiply(m))) === TunnelerCellType.INSIDE_TUNNEL_OPEN);\n            console.assert(dungeonCrawler.getMap(this.location.minus(right.multiply(m))) === TunnelerCellType.INSIDE_TUNNEL_OPEN);\n            dungeonCrawler.setMap(this.location.plus(right.multiply(m)), TunnelerCellType.CLOSED);\n            dungeonCrawler.setMap(this.location.minus(right.multiply(m)), TunnelerCellType.CLOSED);\n        }\n        let [frontFree] = this.frontFree(this.location.minus(this.direction), this.direction, leftFree, rightFree);\n        if (frontFree >= minFrontFree) {\n            anteroomPossible = true;\n        }\n        dungeonCrawler.setMap(this.location, TunnelerCellType.INSIDE_TUNNEL_OPEN);\n        for (let m = 1; m <= this.tunnelWidth; m++) {\n            dungeonCrawler.setMap(this.location.plus(right.multiply(m)), TunnelerCellType.INSIDE_TUNNEL_OPEN);\n            dungeonCrawler.setMap(this.location.minus(right.multiply(m)), TunnelerCellType.INSIDE_TUNNEL_OPEN);\n        }\n        return anteroomPossible;\n    }\n    determineSpawnPoints(sizeUpTunnel, doSpawn, smallAnteroomPossible, right, left) {\n        const dungeonCrawler = this.dungeonCrawler;\n        if (sizeUpTunnel) {\n            if (((this.rng.int % 100) < this.getAnteroomProbability(this.tunnelWidth)) || doSpawn) {\n                const result = this.buildAnteroom(2 * this.tunnelWidth + 5, this.tunnelWidth + 2);\n                console.assert(result);\n                const spawnDirection = this.location.plus(this.direction.multiply(2 * this.tunnelWidth + 5));\n                const spawnRight = this.location.plus(this.direction.multiply(this.tunnelWidth + 3)).plus(right.multiply(this.tunnelWidth + 2));\n                const spawnLeft = this.location.plus(this.direction.multiply(this.tunnelWidth + 3)).plus(left.multiply(this.tunnelWidth + 2));\n                return [spawnDirection, spawnRight, spawnLeft, true];\n            }\n        }\n        else {\n            if (((this.rng.int % 100) < this.getAnteroomProbability(this.tunnelWidth)) && smallAnteroomPossible) {\n                const result = this.buildAnteroom(2 * this.tunnelWidth + 3, this.tunnelWidth + 1);\n                console.assert(result);\n                const spawnDirection = this.location.plus(this.direction.multiply(2 * this.tunnelWidth + 3));\n                const spawnRight = this.location.plus(this.direction.multiply(this.tunnelWidth + 2)).plus(right.multiply(this.tunnelWidth + 1));\n                const spawnLeft = this.location.plus(this.direction.multiply(this.tunnelWidth + 2)).plus(left.multiply(this.tunnelWidth + 1));\n                return [spawnDirection, spawnRight, spawnLeft, true];\n            }\n        }\n        const spawnDirection = this.location;\n        const spawnRight = this.location.minus(this.direction.multiply(this.tunnelWidth)).plus(right.multiply(this.tunnelWidth));\n        const spawnLeft = this.location.minus(this.direction.multiply(this.tunnelWidth)).plus(left.multiply(this.tunnelWidth));\n        if (this.dungeonCrawler.getMap(spawnRight) !== TunnelerCellType.INSIDE_TUNNEL_OPEN ||\n            dungeonCrawler.getMap(spawnLeft) !== TunnelerCellType.INSIDE_TUNNEL_OPEN) {\n            return true;\n        }\n        else {\n            return [spawnDirection, spawnRight, spawnLeft, false];\n        }\n    }\n    joinOrBuildTerminatingRoom(sizeBranching, frontFree, leftFree, rightFree, right, left) {\n        const dungeonCrawler = this.dungeonCrawler;\n        let guaranteedClosedAhead = false;\n        let openAhead = false;\n        let roomAhead = false;\n        let count = 0;\n        for (let i = -this.tunnelWidth; i <= this.tunnelWidth; i++) {\n            const test = this.location.plus(this.direction.multiply(frontFree + 1)).plus(right.multiply(i));\n            const cell = dungeonCrawler.getMap(test);\n            if (this.contains(cell, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN)) {\n                openAhead = true;\n                count++;\n            }\n            else if (this.contains(cell, TunnelerCellType.GUARANTEED_CLOSED, TunnelerCellType.NON_JOIN_GUARANTEED_CLOSED)) {\n                guaranteedClosedAhead = true;\n                count = 0;\n            }\n            else if (cell === TunnelerCellType.INSIDE_ROOM_OPEN) {\n                roomAhead = true;\n                count = 0;\n            }\n            else\n                count = 0;\n        }\n        if ((((this.rng.int % 100) <= this.joinPreference) &&\n            ((this.age < this.maxAge - 1) || (frontFree <= this.config.tunnelJoinDist))) || (frontFree < 5)) {\n            const result = this.joinOtherTunnel(count, frontFree, leftFree, rightFree, openAhead, roomAhead, guaranteedClosedAhead, right);\n            if (result != null) {\n                return result;\n            }\n        }\n        if (dungeonCrawler.isMoreRoomsDungeon(sizeBranching)) {\n            this.spawnRoomCrawler(this.location, this.direction, 0, 2, this.generation, sizeBranching, false);\n        }\n        let joinPreference = (this.rng.int % 11) * 10;\n        if ((this.joinPreference !== 100) || (this.makeRoomsLeftProbability !== this.config.lastChanceTunnelCrawler.makeRoomsLeftProbability) ||\n            (this.makeRoomsRightProbability !== this.config.lastChanceTunnelCrawler.makeRoomsRightProbability) ||\n            (this.changeDirectionProbability !== this.config.lastChanceTunnelCrawler.changeDirectionProbability) ||\n            (this.straightDoubleSpawnProbability !== this.config.lastChanceTunnelCrawler.straightDoubleSpawnProbability) ||\n            (this.turnDoubleSpawnProbability !== this.config.lastChanceTunnelCrawler.turnDoubleSpawnProbability) ||\n            (this.tunnelWidth !== 0)) {\n            let [frontFreeRight] = this.frontFree(this.location.plus(right.multiply(this.tunnelWidth)), right, this.tunnelWidth + 1, this.tunnelWidth + 1);\n            let [frontFreeLeft] = this.frontFree(this.location.minus(right.multiply(this.tunnelWidth)), left, this.tunnelWidth + 1, this.tunnelWidth + 1);\n            let [frontFreeBack] = this.frontFree(this.location, this.direction.negative, this.tunnelWidth + 1, this.tunnelWidth + 1);\n            const fork = (location, direction, generation, intendedDirection) => {\n                this.dungeonCrawler.createTunnelCrawler(location, direction, 0, this.maxAge, generation, intendedDirection, 3, 0, this.config.lastChanceTunnelCrawler.straightDoubleSpawnProbability, this.config.lastChanceTunnelCrawler.turnDoubleSpawnProbability, this.config.lastChanceTunnelCrawler.changeDirectionProbability, this.config.lastChanceTunnelCrawler.makeRoomsRightProbability, this.config.lastChanceTunnelCrawler.makeRoomsLeftProbability, joinPreference);\n            };\n            if (this.tunnelWidth === 0) {\n                if ((this.makeRoomsLeftProbability === this.config.lastChanceTunnelCrawler.makeRoomsLeftProbability) &&\n                    (this.makeRoomsRightProbability === this.config.lastChanceTunnelCrawler.makeRoomsRightProbability) &&\n                    (this.changeDirectionProbability === this.config.lastChanceTunnelCrawler.changeDirectionProbability) &&\n                    (this.straightDoubleSpawnProbability === this.config.lastChanceTunnelCrawler.straightDoubleSpawnProbability) &&\n                    (this.turnDoubleSpawnProbability === this.config.lastChanceTunnelCrawler.turnDoubleSpawnProbability)) {\n                    if ((frontFree >= frontFreeRight) && (frontFree >= frontFreeLeft) && (frontFree >= frontFreeBack)) {\n                        fork(this.location, this.direction, this.generation + 1, this.direction);\n                    }\n                    else if ((frontFreeBack >= frontFreeRight) && (frontFreeBack >= frontFreeLeft)) {\n                        fork(this.location, this.direction.negative, this.generation + this.config.genDelayLastChance, this.direction.negative);\n                    }\n                    else if ((frontFreeRight >= frontFreeLeft) || ((frontFreeRight === frontFreeLeft) && ((this.rng.int % 100) < 50))) {\n                        fork(this.location, right, this.generation + this.config.genDelayLastChance, right);\n                    }\n                    else {\n                        fork(this.location, left, this.generation + this.config.genDelayLastChance, left);\n                    }\n                }\n                else {\n                    fork(this.location, this.direction, this.generation + this.config.genDelayLastChance, this.direction);\n                }\n            }\n            else {\n                if (guaranteedClosedAhead) {\n                    fork(this.location.plus(right.multiply(this.tunnelWidth)), right, this.generation + this.config.genDelayLastChance, right);\n                    fork(this.location.minus(right.multiply(this.tunnelWidth)), left, this.generation + this.config.genDelayLastChance, left);\n                }\n                else if ((frontFreeRight >= frontFreeLeft) || ((frontFreeRight === frontFreeLeft) && ((this.rng.int % 100) < 50))) {\n                    fork(this.location.plus(right.multiply(this.tunnelWidth)), right, this.generation + this.config.genDelayLastChance, right);\n                    fork(this.location.minus(right.multiply(this.tunnelWidth)), this.direction, this.generation + this.config.genDelayLastChance, this.direction);\n                }\n                else {\n                    fork(this.location.plus(right.multiply(this.tunnelWidth)), this.direction, this.generation + this.config.genDelayLastChance, this.direction);\n                    fork(this.location.minus(right.multiply(this.tunnelWidth)), this.direction, this.generation + this.config.genDelayLastChance, this.direction);\n                }\n            }\n        }\n        return false;\n    }\n    joinOtherTunnel(count, frontFree, leftFree, rightFree, openAhead, roomAhead, guaranteedClosedAhead, right) {\n        const dungeonCrawler = this.dungeonCrawler;\n        if ((2 * this.tunnelWidth + 1) === count) {\n            this.buildTunnel(frontFree, this.tunnelWidth);\n            return false;\n        }\n        if (openAhead) {\n            return this.buildSmallerTunnel(frontFree, dungeonCrawler, right);\n        }\n        if (roomAhead && (this.tunnelWidth === 0)) {\n            if (frontFree > 1) {\n                const test = this.location.plus(this.direction.multiply(frontFree + 1));\n                const cell = dungeonCrawler.getMap(test);\n                console.assert(cell === TunnelerCellType.INSIDE_ROOM_OPEN);\n                this.buildTunnel(frontFree - 1, 0);\n                if (this.direction.x === 0)\n                    dungeonCrawler.setMap(this.location.plus(this.direction.multiply(frontFree)), TunnelerCellType.V_DOOR);\n                else {\n                    console.assert(this.direction.y === 0);\n                    dungeonCrawler.setMap(this.location.plus(this.direction.multiply(frontFree)), TunnelerCellType.H_DOOR);\n                }\n                return false;\n            }\n        }\n        if (guaranteedClosedAhead) {\n            if (this.tunnelWidth === 0) {\n                if (this.joinPreference !== 100 ||\n                    this.makeRoomsLeftProbability !== 20 ||\n                    this.makeRoomsRightProbability !== 20 ||\n                    this.changeDirectionProbability !== 30 ||\n                    this.straightDoubleSpawnProbability !== 0 ||\n                    this.turnDoubleSpawnProbability !== 0 ||\n                    this.tunnelWidth !== 0) {\n                    const joinPreference = (this.rng.int % 11) * 10;\n                    const direction = leftFree >= rightFree ? right.negative : right;\n                    dungeonCrawler.createTunnelCrawler(this.location, direction, 0, this.maxAge, this.generation + 1, direction, 3, 0, 0, 0, 30, 20, 20, joinPreference);\n                }\n                return false;\n            }\n        }\n        if (!openAhead && !guaranteedClosedAhead) {\n            if (this.isSpecialCase(frontFree, right)) {\n                const isJoined = this.buildTunnel(frontFree, this.tunnelWidth);\n                console.assert(isJoined);\n                for (let i = -this.tunnelWidth; i <= this.tunnelWidth; i++) {\n                    dungeonCrawler.setMap(this.location.plus(this.direction.multiply(frontFree + 1)).plus(right.multiply(i)), TunnelerCellType.INSIDE_TUNNEL_OPEN);\n                }\n                let directionLength = frontFree + 2;\n                let contactInNextRow = true;\n                let rowAfterIsOK = true;\n                while (contactInNextRow && rowAfterIsOK) {\n                    for (let i = -this.tunnelWidth; i <= this.tunnelWidth; i++) {\n                        const test = this.location.plus(this.direction.multiply(directionLength)).plus(right.multiply(i));\n                        const cell = dungeonCrawler.getMap(test);\n                        if (cell !== TunnelerCellType.CLOSED) {\n                            contactInNextRow = false;\n                            break;\n                        }\n                    }\n                    let testRight = this.location.plus(this.direction.multiply(directionLength)).plus(right.multiply(this.tunnelWidth + 1));\n                    let testLeft = this.location.plus(this.direction.multiply(directionLength)).minus(right.multiply(this.tunnelWidth + 1));\n                    let rightCell = dungeonCrawler.getMap(testRight);\n                    let leftCell = dungeonCrawler.getMap(testLeft);\n                    if (!this.contains(rightCell, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN) &&\n                        !this.contains(leftCell, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN)) {\n                        contactInNextRow = false;\n                        break;\n                    }\n                    if ((rightCell === TunnelerCellType.INSIDE_ROOM_OPEN) || (leftCell === TunnelerCellType.INSIDE_ROOM_OPEN)) {\n                        contactInNextRow = false;\n                        break;\n                    }\n                    for (let i = -this.tunnelWidth; i <= this.tunnelWidth; i++) {\n                        const test = this.location.plus(this.direction.multiply(directionLength + 1)).plus(right.multiply(i));\n                        const cell = dungeonCrawler.getMap(test);\n                        if (cell !== TunnelerCellType.CLOSED) {\n                            rowAfterIsOK = false;\n                        }\n                    }\n                    testRight = this.location.plus(this.direction.multiply(directionLength + 1)).plus(right.multiply(this.tunnelWidth + 1));\n                    testLeft = this.location.plus(this.direction.multiply(directionLength + 1)).minus(right.multiply(this.tunnelWidth + 1));\n                    rightCell = dungeonCrawler.getMap(testRight);\n                    leftCell = dungeonCrawler.getMap(testLeft);\n                    if (!this.contains(rightCell, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN, TunnelerCellType.CLOSED) &&\n                        !this.contains(leftCell, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN, TunnelerCellType.CLOSED)) {\n                        rowAfterIsOK = false;\n                    }\n                    if ((rightCell === TunnelerCellType.INSIDE_ROOM_OPEN) || (leftCell === TunnelerCellType.INSIDE_ROOM_OPEN))\n                        rowAfterIsOK = false;\n                    let allOpen = true;\n                    for (let i = -this.tunnelWidth - 1; i <= this.tunnelWidth + 1; i++) {\n                        const test = this.location.plus(this.direction.multiply(directionLength + 1)).plus(right.multiply(i));\n                        const cell = dungeonCrawler.getMap(test);\n                        if ((cell !== TunnelerCellType.INSIDE_TUNNEL_OPEN) && (cell !== TunnelerCellType.INSIDE_ANTEROOM_OPEN)) {\n                            allOpen = false;\n                        }\n                    }\n                    if (allOpen) {\n                        rowAfterIsOK = true;\n                    }\n                    if (contactInNextRow && rowAfterIsOK) {\n                        for (let i = -this.tunnelWidth; i <= this.tunnelWidth; i++) {\n                            dungeonCrawler.setMap(this.location.plus(this.direction.multiply(directionLength)).plus(right.multiply(i)), TunnelerCellType.INSIDE_TUNNEL_OPEN);\n                        }\n                    }\n                    directionLength++;\n                }\n                return false;\n            }\n            if (this.tunnelWidth === 0) {\n                if (dungeonCrawler.getMap(this.location.plus(this.direction.multiply(frontFree + 1))) === TunnelerCellType.CLOSED) {\n                    if (dungeonCrawler.getMap(this.location.plus(this.direction.multiply(frontFree + 1)).plus(right)) === TunnelerCellType.INSIDE_ROOM_OPEN) {\n                        this.direction = right.negative;\n                        if (this.direction.equals(this.intendedDirection.negative)) {\n                            this.direction = this.intendedDirection;\n                        }\n                        return true;\n                    }\n                    else if (dungeonCrawler.getMap(this.location.plus(this.direction.multiply(frontFree + 1)).minus(right)) === TunnelerCellType.INSIDE_ROOM_OPEN) {\n                        this.direction = right;\n                        if (this.direction.equals(this.intendedDirection.negative)) {\n                            this.direction = this.intendedDirection;\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    isSpecialCase(frontFree, right) {\n        const dungeonCrawler = this.dungeonCrawler;\n        let isSpecialCase = true;\n        for (let i = -this.tunnelWidth; i <= this.tunnelWidth; i++) {\n            const test = this.location.plus(this.direction.multiply(frontFree + 1)).plus(right.multiply(i));\n            const cell = dungeonCrawler.getMap(test);\n            if (cell !== TunnelerCellType.CLOSED) {\n                isSpecialCase = false;\n                break;\n            }\n        }\n        let testRight = this.location.plus(this.direction.multiply(frontFree + 1)).plus(right.multiply(this.tunnelWidth + 1));\n        let testLeft = this.location.plus(this.direction.multiply(frontFree + 1)).minus(right.multiply(this.tunnelWidth + 1));\n        let rightCell = dungeonCrawler.getMap(testRight);\n        let leftCell = dungeonCrawler.getMap(testLeft);\n        if (!this.contains(rightCell, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN) &&\n            !this.contains(leftCell, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN)) {\n            isSpecialCase = false;\n        }\n        if ((rightCell === TunnelerCellType.INSIDE_ROOM_OPEN) || (leftCell === TunnelerCellType.INSIDE_ROOM_OPEN)) {\n            isSpecialCase = false;\n        }\n        for (let i = -this.tunnelWidth - 1; i <= this.tunnelWidth + 1; i++) {\n            const test = this.location.plus(this.direction.multiply(frontFree + 2)).plus(right.multiply(i));\n            const cell = dungeonCrawler.getMap(test);\n            if (cell === TunnelerCellType.INSIDE_ROOM_OPEN) {\n                isSpecialCase = false;\n                break;\n            }\n        }\n        return isSpecialCase;\n    }\n    spawnTunnelCrawler(sizeUpTunnel, sizeDownTunnel, location, direction, generation, intendedDirection, options) {\n        let tunnelWidth = this.tunnelWidth;\n        let stepLength = this.stepLength;\n        if (sizeUpTunnel) {\n            tunnelWidth++;\n            stepLength = stepLength + 2;\n        }\n        else if (sizeDownTunnel) {\n            tunnelWidth--;\n            if (tunnelWidth < 0) {\n                tunnelWidth = 0;\n            }\n            stepLength = stepLength - 2;\n            if (stepLength < 3) {\n                stepLength = 3;\n            }\n        }\n        this.dungeonCrawler.createTunnelCrawler(location, direction, 0, this.getMaxAgeTunnelCrawlers(generation), generation, intendedDirection, stepLength, tunnelWidth, options.straightDoubleSpawnProbability, options.turnDoubleSpawnProbability, options.changeDirectionProbability, options.makeRoomsRightProbability, options.makeRoomsLeftProbability, options.joinPreference);\n    }\n    spawnRoomCrawler(location, direction, age, maxAge, generation, size, builtAnteroom) {\n        const defaultWidth = Math.max(1, 2 * this.tunnelWidth);\n        if (builtAnteroom) {\n            generation = this.generation + Math.floor((generation - this.generation) / (this.config.genSpeedUpOnAnteroom));\n        }\n        this.dungeonCrawler.createRoomCrawler(location, direction, age, maxAge, generation, defaultWidth, size);\n    }\n    buildSmallerTunnel(frontFree, dungeonCrawler, right) {\n        const test = this.location.plus(this.direction.multiply(frontFree + 1));\n        const cell = dungeonCrawler.getMap(test);\n        if (this.contains(cell, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN)) {\n            if (!this.buildTunnel(frontFree, 0)) {\n                console.error(\"openAhead, failed to join, frontFree = \" + frontFree);\n            }\n            return false;\n        }\n        let offset = 0;\n        for (let i = 1; i <= this.tunnelWidth; i++) {\n            const testP = this.location.plus(this.direction.multiply(frontFree + 1)).plus(right.multiply(i));\n            const cellP = dungeonCrawler.getMap(testP);\n            if (this.contains(cellP, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN)) {\n                offset = i;\n                break;\n            }\n            const testM = this.location.plus(this.direction.multiply(frontFree + 1)).minus(right.multiply(i));\n            const cellM = dungeonCrawler.getMap(testM);\n            if (this.contains(cellM, TunnelerCellType.OPEN, TunnelerCellType.GUARANTEED_OPEN, TunnelerCellType.INSIDE_TUNNEL_OPEN, TunnelerCellType.INSIDE_ANTEROOM_OPEN)) {\n                offset = -i;\n                break;\n            }\n        }\n        console.assert(offset !== 0);\n        for (let i = 1; i <= frontFree; i++) {\n            const point = this.location.plus(this.direction.multiply(i)).plus(right.multiply(offset));\n            dungeonCrawler.setMap(point, TunnelerCellType.INSIDE_TUNNEL_OPEN);\n        }\n        return false;\n    }\n    roomGeneration() {\n        let diceRoll = this.rng.int % 100;\n        let roomGeneration = this.generation;\n        let summedProbability = 0;\n        for (let i = 0; i <= 10; i++) {\n            summedProbability = summedProbability + this.getChildDelayProbabilityForGenerationRoomCrawlers(i);\n            if (diceRoll < summedProbability) {\n                roomGeneration = this.generation + i;\n                break;\n            }\n        }\n        return roomGeneration;\n    }\n    sidewaysBranchingRoomSizes() {\n        let sizeSideways;\n        let sizeBranching;\n        const probabilityMediumSideways = this.getRoomSizeProbabilitySideways(this.tunnelWidth, RoomSize.MEDIUM);\n        const probabilitySmallSideways = this.getRoomSizeProbabilitySideways(this.tunnelWidth, RoomSize.SMALL);\n        const probabilityMediumBranching = this.getRoomSizeProbabilityBranching(this.tunnelWidth, RoomSize.MEDIUM);\n        const probSmallBranching = this.getRoomSizeProbabilityBranching(this.tunnelWidth, RoomSize.SMALL);\n        let diceRoll = this.rng.int % 100;\n        if (diceRoll < probabilitySmallSideways)\n            sizeSideways = RoomSize.SMALL;\n        else if (diceRoll < (probabilitySmallSideways + probabilityMediumSideways))\n            sizeSideways = RoomSize.MEDIUM;\n        else\n            sizeSideways = RoomSize.LARGE;\n        if (diceRoll < probSmallBranching)\n            sizeBranching = RoomSize.SMALL;\n        else if (diceRoll < (probSmallBranching + probabilityMediumBranching))\n            sizeBranching = RoomSize.MEDIUM;\n        else\n            sizeBranching = RoomSize.LARGE;\n        return [sizeSideways, sizeBranching];\n    }\n    isChangeDirection() {\n        return (this.rng.int % 100) < this.changeDirectionProbability;\n    }\n    isSpawn(changeDirection) {\n        if (changeDirection && ((this.rng.int % 100) < this.turnDoubleSpawnProbability)) {\n            return true;\n        }\n        else if (!changeDirection && ((this.rng.int % 100) < this.straightDoubleSpawnProbability)) {\n            return true;\n        }\n        return false;\n    }\n    isSpawnRoom(doSpawn) {\n        return doSpawn && ((this.rng.int % 100) > this.config.patience);\n    }\n    buildAnteroom(length, width) {\n        if ((length < 3) || (width < 1)) {\n            console.error(\"Anteroom must be at least 3x3\");\n            return false;\n        }\n        let [frontFree] = this.frontFree(this.location, this.direction, width + 1, width + 1);\n        if (frontFree <= length) {\n            return false;\n        }\n        const right = this.rightDirection();\n        for (let directionLength = 1; directionLength <= length; directionLength++) {\n            for (let side = -width; side <= width; side++) {\n                const current = this.location.plus(this.direction.multiply(directionLength)).plus(right.multiply(side));\n                this.dungeonCrawler.setMap(current, TunnelerCellType.INSIDE_ANTEROOM_OPEN);\n            }\n        }\n        if ((width >= 3) && (length >= 7) && this.config.columnsInTunnels) {\n            let directionLength = 2;\n            this.placeColumns(width, directionLength, right);\n        }\n        return true;\n    }\n    buildTunnel(length, width) {\n        if ((length < 1) || (width < 0)) {\n            console.error(\"Trying to build zero size tunnel with length = \" + length + \"; width =  \" + width);\n            return false;\n        }\n        let [frontFree] = this.frontFree(this.location, this.direction, width + 1, width + 1);\n        if (frontFree < length) {\n            return false;\n        }\n        const right = this.rightDirection();\n        for (let directionLength = 1; directionLength <= length; directionLength++) {\n            for (let side = -width; side <= width; side++) {\n                const current = this.location.plus(this.direction.multiply(directionLength)).plus(right.multiply(side));\n                this.dungeonCrawler.setMap(current, TunnelerCellType.INSIDE_TUNNEL_OPEN);\n            }\n        }\n        if ((width >= 3) && (length >= 7) && this.config.columnsInTunnels) {\n            const numCols = Math.floor((length - 1) / 6);\n            console.assert(numCols > 0);\n            for (let i = 0; i < numCols; i++) {\n                let directionLength = 2 + i * 3;\n                this.placeColumns(width, directionLength, right);\n            }\n        }\n        return true;\n    }\n    placeColumns(width, directionLength, right) {\n        let side = -width + 1;\n        let point = this.location.plus(this.direction.multiply(directionLength)).plus(right.multiply(side));\n        this.dungeonCrawler.setMap(point, TunnelerCellType.COLUMN);\n        side = width - 1;\n        point = this.location.plus(this.direction.multiply(directionLength)).plus(right.multiply(side));\n        this.dungeonCrawler.setMap(point, TunnelerCellType.COLUMN);\n        directionLength = directionLength - 1;\n        side = -width + 1;\n        point = this.location.plus(this.direction.multiply(directionLength)).plus(right.multiply(side));\n        this.dungeonCrawler.setMap(point, TunnelerCellType.COLUMN);\n        side = width - 1;\n        point = this.location.plus(this.direction.multiply(directionLength)).plus(right.multiply(side));\n        this.dungeonCrawler.setMap(point, TunnelerCellType.COLUMN);\n    }\n    getChildDelayProbabilityForGenerationRoomCrawlers(generation) {\n        if ((0 <= generation) && (generation <= 10)) {\n            return this.config.childDelayProbabilityForGenerationRoomCrawlers[generation];\n        }\n        else {\n            return 0;\n        }\n    }\n    getChildDelayProbabilityForGenerationTunnelCrawlers(generation) {\n        if ((0 <= generation) && (generation <= 10)) {\n            return this.config.childDelayProbabilityForGenerationTunnelCrawlers[generation];\n        }\n        else {\n            return 0;\n        }\n    }\n    getAnteroomProbability(tunnelWidth) {\n        if (tunnelWidth >= this.config.anteroomProbability.length) {\n            return 100;\n        }\n        else {\n            return this.config.anteroomProbability[tunnelWidth];\n        }\n    }\n    getSizeUpProbability(generation) {\n        if (generation >= this.config.sizeUpProbability.length) {\n            return this.config.sizeUpProbability[this.config.sizeUpProbability.length - 1];\n        }\n        else {\n            return this.config.sizeUpProbability[generation];\n        }\n    }\n    getSizeDownProbability(generation) {\n        if (generation >= this.config.sizeDownProbability.length) {\n            return this.config.sizeDownProbability[this.config.sizeDownProbability.length - 1];\n        }\n        else {\n            return this.config.sizeDownProbability[generation];\n        }\n    }\n    getMaxAgeTunnelCrawlers(generation) {\n        if (generation >= this.config.maxAgesTunnelCrawlers.length) {\n            return this.config.maxAgesTunnelCrawlers[this.config.maxAgesTunnelCrawlers.length - 1];\n        }\n        else {\n            return this.config.maxAgesTunnelCrawlers[generation];\n        }\n    }\n    getRoomSizeProbabilitySideways(tunnelWidth, size) {\n        if (tunnelWidth >= this.config.roomSizeProbabilitySidewaysRooms.length) {\n            if (RoomSize.LARGE === size) {\n                return 100;\n            }\n            else {\n                return 0;\n            }\n        }\n        else {\n            switch (size) {\n                case RoomSize.LARGE:\n                    return (this.config.roomSizeProbabilitySidewaysRooms[tunnelWidth][2]);\n                case RoomSize.MEDIUM:\n                    return (this.config.roomSizeProbabilitySidewaysRooms[tunnelWidth][1]);\n                case RoomSize.SMALL:\n                    return (this.config.roomSizeProbabilitySidewaysRooms[tunnelWidth][0]);\n            }\n        }\n    }\n    getRoomSizeProbabilityBranching(tunnelWidth, size) {\n        if (tunnelWidth >= this.config.roomSizeProbabilityBranching.length) {\n            if (RoomSize.LARGE === size) {\n                return 100;\n            }\n            else {\n                return 0;\n            }\n        }\n        else {\n            switch (size) {\n                case RoomSize.LARGE:\n                    return (this.config.roomSizeProbabilityBranching[tunnelWidth][2]);\n                case RoomSize.MEDIUM:\n                    return (this.config.roomSizeProbabilityBranching[tunnelWidth][1]);\n                case RoomSize.SMALL:\n                    return (this.config.roomSizeProbabilityBranching[tunnelWidth][0]);\n            }\n        }\n    }\n    mutateOptions() {\n        return {\n            straightDoubleSpawnProbability: this.dungeonCrawler.mutate(this.straightDoubleSpawnProbability),\n            turnDoubleSpawnProbability: this.dungeonCrawler.mutate(this.turnDoubleSpawnProbability),\n            changeDirectionProbability: this.dungeonCrawler.mutate(this.changeDirectionProbability),\n            makeRoomsRightProbability: this.dungeonCrawler.mutate(this.makeRoomsRightProbability),\n            makeRoomsLeftProbability: this.dungeonCrawler.mutate(this.makeRoomsLeftProbability),\n            joinPreference: this.dungeonCrawler.mutate(this.joinPreference),\n        };\n    }\n}\n\n// CONCATENATED MODULE: ./src/tunneler/room.crawler.ts\n\n\nclass room_crawler_RoomCrawler extends crawler_Crawler {\n    constructor(rng, dungeonCrawler, location, direction, age, maxAge, generation, defaultWidth, size) {\n        super(rng, dungeonCrawler, location, direction, age, maxAge, generation);\n        this.defaultWidth = defaultWidth;\n        this.size = size;\n    }\n    stepAhead() {\n        if (!this.dungeonCrawler.isMoreRoomsDungeon(this.size)) {\n            return false;\n        }\n        if (this.generation !== this.dungeonCrawler.activeGeneration) {\n            console.assert(this.generation > this.dungeonCrawler.activeGeneration);\n            return true;\n        }\n        this.age++;\n        if (this.age >= this.maxAge)\n            return false;\n        else if (this.age < 0)\n            return true;\n        const right = this.rightDirection();\n        let defaultWidth = this.defaultWidth;\n        const minSize = this.getMinRoomSize(this.size);\n        const maxSize = this.getMaxRoomSize(this.size);\n        let leftFree;\n        let rightFree;\n        let frontFree;\n        do {\n            [frontFree, leftFree, rightFree] = this.frontFree(this.location, this.direction, defaultWidth + 1, defaultWidth + 1);\n            let length = frontFree - 2;\n            let width = leftFree + rightFree - 1;\n            if (length < 2) {\n                break;\n            }\n            if (width / length < this.config.roomAspectRatio) {\n                length = Math.floor(width / this.config.roomAspectRatio);\n                if (width / length < this.config.roomAspectRatio) {\n                    console.error(\"length = \" + length + \", width = \" + width + \", but width/length should be >= \" + this.config.roomAspectRatio);\n                }\n            }\n            if (length / width < this.config.roomAspectRatio) {\n                width = Math.floor(length / this.config.roomAspectRatio);\n                if (length / width < this.config.roomAspectRatio) {\n                    console.error(\"length = \" + length + \", width = \" + width + \", but length/width should be >= \" + this.config.roomAspectRatio);\n                }\n            }\n            if (width / length < this.config.roomAspectRatio) {\n                console.error(\"The Emperor suggests you make your roomAspectRatio in the design file smaller...\");\n                return false;\n            }\n            while (length * width > maxSize) {\n                if (length > width)\n                    length--;\n                else if (width > length)\n                    width--;\n                else if ((this.rng.int % 100) < 50)\n                    length--;\n                else\n                    width--;\n            }\n            console.assert(length * width <= maxSize);\n            if (length * width >= minSize) {\n                const room = new Room();\n                if (leftFree <= rightFree) {\n                    if ((2 * leftFree - 1) > width) {\n                        this.attachRoom(room, right, length, (width >> 1) - width + 1, width >> 2);\n                    }\n                    else {\n                        this.attachRoom(room, right, length, -leftFree + 1, -leftFree + width);\n                    }\n                    if (this.direction.x === 0) {\n                        this.dungeonCrawler.setMap(this.location.plus(this.direction), TunnelerCellType.V_DOOR);\n                    }\n                    else {\n                        console.assert(this.direction.y === 0);\n                        this.dungeonCrawler.setMap(this.location.plus(this.direction), TunnelerCellType.H_DOOR);\n                    }\n                }\n                else {\n                    if ((2 * rightFree - 1) > width) {\n                        this.attachRoom(room, right, length, -(width >> 1), -(width >> 1) + width - 1);\n                    }\n                    else {\n                        this.attachRoom(room, right, length, rightFree - width, rightFree - 1);\n                    }\n                    if (this.direction.x === 0) {\n                        this.dungeonCrawler.setMap(this.location.plus(this.direction), TunnelerCellType.V_DOOR);\n                    }\n                    else {\n                        console.assert(this.direction.y === 0);\n                        this.dungeonCrawler.setMap(this.location.plus(this.direction), TunnelerCellType.H_DOOR);\n                    }\n                }\n                this.dungeonCrawler.builtRoomDungeon(this.size);\n                room.inDungeon = true;\n                this.dungeonCrawler.addRoom(room);\n                return false;\n            }\n            else {\n                defaultWidth++;\n            }\n        } while ((frontFree - 2) >= ((2 * defaultWidth + 1) * this.config.roomAspectRatio));\n        return false;\n    }\n    attachRoom(room, right, length, from, to) {\n        for (let direction = 1; direction <= length; direction++) {\n            for (let sideDistance = from; sideDistance <= to; sideDistance++) {\n                const point = this.location.plus(this.direction.multiply(direction + 1)).plus(right.multiply(sideDistance));\n                this.dungeonCrawler.setMap(point, TunnelerCellType.INSIDE_ROOM_OPEN);\n                room.inside.push(point);\n            }\n        }\n    }\n    getMinRoomSize(size) {\n        switch (size) {\n            case RoomSize.SMALL:\n                return this.config.minRoomSize;\n            case RoomSize.MEDIUM:\n                return this.config.mediumRoomSize;\n            case RoomSize.LARGE:\n                return this.config.largeRoomSize;\n        }\n    }\n    getMaxRoomSize(size) {\n        switch (size) {\n            case RoomSize.SMALL:\n                return (this.config.mediumRoomSize - 1);\n            case RoomSize.MEDIUM:\n                return (this.config.largeRoomSize - 1);\n            case RoomSize.LARGE:\n                return (this.config.maxRoomSize - 1);\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/tunneler/dungeon.crawler.ts\n\n\n\n\nclass dungeon_crawler_DungeonCrawler {\n    constructor(config, rng) {\n        this.rooms = [];\n        this.mapFlagsDirections = [];\n        this.crawlers = [];\n        this.activeGeneration = 0;\n        this.currSmallRoomsLabyrinth = 0;\n        this.currMediumRoomsLabyrinth = 0;\n        this.currLargeRoomsLabyrinth = 0;\n        this.currSmallRoomsDungeon = 0;\n        this.currMediumRoomsDungeon = 0;\n        this.currLargeRoomsDungeon = 0;\n        this.rng = rng;\n        this.config = config;\n        console.assert(config.childDelayProbabilityForGenerationCrawlers.length === 11);\n        console.assert(config.childDelayProbabilityForGenerationRoomCrawlers.length === 11);\n        console.assert(config.roomAspectRatio >= 0 && config.roomAspectRatio <= 1, \"roomAspectRatio must be a double between 0 and 1\");\n        console.assert(config.genSpeedUpOnAnteroom >= 1, \"Please use genSpeedUpOnAnteroom >= 1; parameter reset to 1\");\n        console.assert(!config.crawlersInAnterooms || (config.crawlersInAnterooms && config.crawlersInTunnels), \"when you allow Crawlers in Anterooms, you must also allow them in Tunnels\");\n        this.map = [];\n        for (let i = 0; i < this.config.width * this.config.height; i++) {\n            this.map[i] = this.config.background;\n            this.mapFlagsDirections[i] = false;\n        }\n        for (let i = 0; i < 4; i++) {\n            this.crawlers[i] = null;\n        }\n        this.setRect(0, 0, this.config.width - 1, 0, TunnelerCellType.GUARANTEED_CLOSED);\n        this.setRect(0, 0, 0, this.config.height - 1, TunnelerCellType.GUARANTEED_CLOSED);\n        this.setRect(this.config.width - 1, 0, this.config.width - 1, this.config.height - 1, TunnelerCellType.GUARANTEED_CLOSED);\n        this.setRect(0, this.config.height - 1, this.config.width - 1, this.config.height - 1, TunnelerCellType.GUARANTEED_CLOSED);\n        for (const des of this.config.design) {\n            this.setRectFill(des);\n        }\n        for (const entry of this.config.openings) {\n            switch (entry) {\n                case model_Direction.NORTH:\n                    this.setRect(0, Math.floor(this.config.height / 2) - 1, 2, Math.floor(this.config.height / 2) + 1, TunnelerCellType.GUARANTEED_OPEN);\n                    break;\n                case model_Direction.WEST:\n                    this.setRect(Math.floor(this.config.width / 2) - 1, 0, Math.floor(this.config.width / 2) + 1, 2, TunnelerCellType.GUARANTEED_OPEN);\n                    break;\n                case model_Direction.EAST:\n                    this.setRect(Math.floor(this.config.width / 2) - 1, this.config.height - 3, Math.floor(this.config.width / 2) + 1, this.config.height - 1, TunnelerCellType.GUARANTEED_OPEN);\n                    break;\n                case model_Direction.SOUTH:\n                    this.setRect(this.config.width - 3, Math.floor(this.config.height / 2) - 1, this.config.width - 1, Math.floor(this.config.height / 2) + 1, TunnelerCellType.GUARANTEED_OPEN);\n                    break;\n                case model_Direction.NORTH_WEST:\n                    this.setRect(0, 0, 2, 2, TunnelerCellType.GUARANTEED_OPEN);\n                    break;\n                case model_Direction.NORTH_EAST:\n                    this.setRect(0, this.config.height - 3, 2, this.config.height - 1, TunnelerCellType.GUARANTEED_OPEN);\n                    break;\n                case model_Direction.SOUTH_WEST:\n                    this.setRect(this.config.width - 3, 0, this.config.width - 1, 2, TunnelerCellType.GUARANTEED_OPEN);\n                    break;\n                case model_Direction.SOUTH_EAST:\n                    this.setRect(this.config.width - 3, this.config.height - 3, this.config.width - 1, this.config.height - 1, TunnelerCellType.GUARANTEED_OPEN);\n                    break;\n                default:\n                    console.assert(false);\n                    break;\n            }\n        }\n        const spawnRandomWallCrawler = (location, direction, generation) => {\n            this.createWallCrawler(location, direction, 0, this.getMaxAgeCrawlers(generation), generation, direction, this.getStepLength(generation), 1, this.getCorridorWidth(generation), this.mutate2(config.randCrawler.straightSingleSpawnProbability), this.mutate2(config.randCrawler.straightDoubleSpawnProbability), this.mutate2(config.randCrawler.turnSingleSpawnProbability), this.mutate2(config.randCrawler.turnDoubleSpawnProbability), this.mutate2(config.randCrawler.changeDirectionProbability));\n        };\n        for (let generation = 0; generation < config.randCrawler.perGeneration.length; generation++) {\n            let crawlersPer1000Squares = config.randCrawler.perGeneration[generation];\n            if (crawlersPer1000Squares > 0) {\n                let crawlersPerTopBottomWall = Math.floor((this.config.height * crawlersPer1000Squares) / 1000);\n                if (crawlersPerTopBottomWall === 0) {\n                    if (this.rng.int % 1000 < (this.config.height * crawlersPer1000Squares))\n                        crawlersPerTopBottomWall = 1;\n                }\n                let yIndex = 0;\n                for (let ind = 0; ind < crawlersPerTopBottomWall; ind++) {\n                    yIndex = 2 + this.rng.int % (this.config.height - 4);\n                    spawnRandomWallCrawler(new Point(0, yIndex), Point.SOUTH, generation);\n                    yIndex = 2 + this.rng.int % (this.config.height - 4);\n                    spawnRandomWallCrawler(new Point(this.config.width - 1, yIndex), Point.NORTH, generation);\n                }\n                let crawlersPerLeftRightWall = Math.floor((this.config.width * crawlersPer1000Squares) / 1000);\n                if (crawlersPerLeftRightWall === 0) {\n                    if (this.rng.int % 1000 < (this.config.width * crawlersPer1000Squares))\n                        crawlersPerLeftRightWall = 1;\n                }\n                let xIndex = 0;\n                for (let i = 0; i < crawlersPerLeftRightWall; i++) {\n                    xIndex = 2 + this.rng.int % (this.config.width - 4);\n                    spawnRandomWallCrawler(new Point(xIndex, 0), Point.EAST, generation);\n                    xIndex = 2 + this.rng.int % (this.config.width - 4);\n                    spawnRandomWallCrawler(new Point(xIndex, this.config.height - 1), Point.EAST, generation);\n                }\n            }\n        }\n        for (const cd of config.crawlers) {\n            this.createWallCrawler(cd.location, cd.direction, -cd.age, cd.maxAge, cd.generation, cd.intendedDirection, cd.stepLength, cd.opening, cd.corridorWidth, cd.straightSingleSpawnProbability, cd.straightDoubleSpawnProbability, cd.turnSingleSpawnProbability, cd.turnDoubleSpawnProbability, cd.changeDirectionProbability);\n        }\n        for (let [first, second] of config.crawlerPairs) {\n            let firstIsOpen = true;\n            if (this.rng.boolean)\n                firstIsOpen = false;\n            this.createWallCrawler(first.location, first.direction, -first.age, first.maxAge, first.generation, first.intendedDirection, first.stepLength, (firstIsOpen ? 1 : 0), first.corridorWidth, first.straightSingleSpawnProbability, first.straightDoubleSpawnProbability, first.turnSingleSpawnProbability, first.turnDoubleSpawnProbability, first.changeDirectionProbability);\n            this.setMap(first.location, TunnelerCellType.CLOSED);\n            this.createWallCrawler(second.location, second.direction, -second.age, second.maxAge, second.generation, second.intendedDirection, second.stepLength, (firstIsOpen ? 1 : 0), second.corridorWidth, second.straightSingleSpawnProbability, second.straightDoubleSpawnProbability, second.turnSingleSpawnProbability, second.turnDoubleSpawnProbability, second.changeDirectionProbability);\n            this.setMap(second.location, TunnelerCellType.CLOSED);\n        }\n        for (let td of config.tunnelCrawlers) {\n            this.createTunnelCrawler(td.location, td.direction, -td.age, td.maxAge, td.generation, td.intendedDirection, td.stepLength, td.tunnelWidth, td.straightDoubleSpawnProbability, td.turnDoubleSpawnProbability, td.changeDirectionProbability, td.makeRoomsRightProbability, td.makeRoomsLeftProbability, td.joinPreference);\n        }\n    }\n    isOpen(pos) {\n        let type = this.getMap(pos);\n        return (type === TunnelerCellType.OPEN) ||\n            (type === TunnelerCellType.NON_JOIN_OPEN) ||\n            (type === TunnelerCellType.INSIDE_TUNNEL_OPEN) ||\n            (type === TunnelerCellType.INSIDE_ANTEROOM_OPEN) ||\n            (type === TunnelerCellType.GUARANTEED_OPEN) ||\n            (type === TunnelerCellType.NON_JOIN_GUARANTEED_OPEN);\n    }\n    static isActive(pos, Active) {\n        for (let i of Active) {\n            if ((pos.x === i.x) && (pos.y === i.y))\n                return true;\n        }\n        return false;\n    }\n    setMap(point, data) {\n        const x = point.x;\n        const y = point.y;\n        console.assert(data !== undefined);\n        console.assert((x < this.config.width) && (y < this.config.height) && (x >= 0) && (y >= 0));\n        this.map[x * this.config.height + y] = data;\n    }\n    getMap(point) {\n        const x = point.x;\n        const y = point.y;\n        console.assert((x < this.config.width) && (y < this.config.height) && (x >= 0) && (y >= 0));\n        return this.map[x * this.config.height + y];\n    }\n    isMapOpen(point) {\n        switch (this.getMap(point)) {\n            case TunnelerCellType.OPEN:\n            case TunnelerCellType.GUARANTEED_OPEN:\n            case TunnelerCellType.NON_JOIN_OPEN:\n            case TunnelerCellType.NON_JOIN_GUARANTEED_OPEN:\n            case TunnelerCellType.INSIDE_ROOM_OPEN:\n            case TunnelerCellType.INSIDE_TUNNEL_OPEN:\n            case TunnelerCellType.INSIDE_ANTEROOM_OPEN:\n            case TunnelerCellType.H_DOOR:\n            case TunnelerCellType.V_DOOR:\n                return true;\n            default:\n                return false;\n        }\n    }\n    isMoreRoomsLabyrinth(size = null) {\n        if (size !== null) {\n            switch (size) {\n                case RoomSize.SMALL:\n                    return (this.config.numSmallRoomsInLabyrinth > this.currSmallRoomsLabyrinth);\n                case RoomSize.MEDIUM:\n                    return (this.config.numMediumRoomsInLabyrinth > this.currMediumRoomsLabyrinth);\n                case RoomSize.LARGE:\n                    return (this.config.numLargeRoomsInLabyrinth > this.currLargeRoomsLabyrinth);\n            }\n        }\n        else {\n            return (this.isMoreRoomsLabyrinth(RoomSize.SMALL) || this.isMoreRoomsLabyrinth(RoomSize.MEDIUM) || this.isMoreRoomsLabyrinth(RoomSize.LARGE));\n        }\n    }\n    isMoreRoomsDungeon(size) {\n        if (size !== null) {\n            switch (size) {\n                case RoomSize.SMALL:\n                    return (this.config.numSmallRoomsInDungeon > this.currSmallRoomsDungeon);\n                case RoomSize.MEDIUM:\n                    return (this.config.numMediumRoomsInDungeon > this.currMediumRoomsDungeon);\n                case RoomSize.LARGE:\n                    return (this.config.numLargeRoomsInDungeon > this.currLargeRoomsDungeon);\n            }\n        }\n        else {\n            return (this.isMoreRoomsDungeon(RoomSize.SMALL) || this.isMoreRoomsDungeon(RoomSize.MEDIUM) || this.isMoreRoomsDungeon(RoomSize.LARGE));\n        }\n    }\n    builtRoomDungeon(size) {\n        if (RoomSize.SMALL === size)\n            this.currSmallRoomsDungeon++;\n        else if (RoomSize.MEDIUM === size)\n            this.currMediumRoomsDungeon++;\n        else if (RoomSize.LARGE === size)\n            this.currLargeRoomsDungeon++;\n    }\n    getStepLength(generation) {\n        if (generation >= this.config.stepLengths.length)\n            return this.config.stepLengths[this.config.stepLengths.length - 1];\n        else\n            return this.config.stepLengths[generation];\n    }\n    getCorridorWidth(generation) {\n        if (generation >= this.config.corridorWidths.length)\n            return this.config.corridorWidths[this.config.corridorWidths.length - 1];\n        else\n            return this.config.corridorWidths[generation];\n    }\n    getMaxAgeCrawlers(generation) {\n        if (generation >= this.config.maxAgesCrawlers.length)\n            return this.config.maxAgesCrawlers[this.config.maxAgesCrawlers.length - 1];\n        else\n            return this.config.maxAgesCrawlers[generation];\n    }\n    addRoom(r) {\n        this.rooms.push(r);\n    }\n    isChecked(pos) {\n        console.assert((pos.x < this.config.width) && (pos.y < this.config.height) && (pos.x >= 0) && (pos.y >= 0));\n        return this.mapFlagsDirections[pos.x * this.config.height + pos.y];\n    }\n    static isCheckedList(pos, checked) {\n        for (let i = 0; i < checked.length; i++) {\n            if ((pos.x === checked[i].x) && (pos.y === checked[i].y))\n                return true;\n        }\n        return false;\n    }\n    setChecked(pos) {\n        console.assert((pos.x < this.config.width) && (pos.y < this.config.height) && (pos.x >= 0) && (pos.y >= 0));\n        this.mapFlagsDirections[pos.x * this.config.height + pos.y] = true;\n    }\n    setRectFill(rect) {\n        this.setRect(rect.startX, rect.startY, rect.endX, rect.endY, rect.type);\n    }\n    setRect(startX, startY, endX, endY, data) {\n        if ((endX < startX) || (endY < startY)) {\n            console.error(`Refuse to set incorrectly specified rectangle; sX = ${startX} sY=${startY} eX=${endX} endY=${endY}`);\n            return;\n        }\n        else {\n            for (let x = startX; x <= endX; x++)\n                for (let y = startY; y <= endY; y++)\n                    this.setMap({ x: x, y: y }, data);\n        }\n    }\n    createWallCrawler(location, direction, age, maxAge, generation, intendedDirection, stepLength, opening, corridorWidth, straightSingleSpawnProbability, straightDoubleSpawnProbability, turnSingleSpawnProbability, turnDoubleSpawnProbability, changeDirectionProbability) {\n        let crawler = new wall_crawler_WallCrawler(this.rng, this, Point.from(location), Point.from(direction), age, maxAge, generation, Point.from(intendedDirection), stepLength, opening, corridorWidth, straightSingleSpawnProbability, straightDoubleSpawnProbability, turnSingleSpawnProbability, turnDoubleSpawnProbability, changeDirectionProbability);\n        for (let i = 0; i < this.crawlers.length; i++) {\n            if (this.crawlers[i] === null) {\n                this.crawlers[i] = crawler;\n                return;\n            }\n        }\n        this.crawlers.push(crawler);\n    }\n    createTunnelCrawler(location, direction, age, maxAge, generation, intendedDirection, stepLength, tunnelWidth, straightDoubleSpawnProbability, turnDoubleSpawnProbability, changeDirectionProbability, makeRoomsRightProbability, makeRoomsLeftProbability, joinPreference) {\n        let crawler = new tunnel_crawler_TunnelCrawler(this.rng, this, Point.from(location), Point.from(direction), age, maxAge, generation, Point.from(intendedDirection), stepLength, tunnelWidth, straightDoubleSpawnProbability, turnDoubleSpawnProbability, changeDirectionProbability, makeRoomsRightProbability, makeRoomsLeftProbability, joinPreference);\n        for (let i = 0; i < this.crawlers.length; i++) {\n            if (this.crawlers[i] === null) {\n                this.crawlers[i] = crawler;\n                return;\n            }\n        }\n        this.crawlers.push(crawler);\n    }\n    createRoomCrawler(location, direction, age, maxAge, generation, defaultWidth, size) {\n        const crawler = new room_crawler_RoomCrawler(this.rng, this, Point.from(location), Point.from(direction), age, maxAge, generation, defaultWidth, size);\n        for (let i = 0; i < this.crawlers.length; i++) {\n            if (this.crawlers[i] === null) {\n                this.crawlers[i] = crawler;\n                return;\n            }\n        }\n        this.crawlers.push(crawler);\n    }\n    mutate(input) {\n        let output = input - this.config.mutator + (this.rng.int % (2 * this.config.mutator + 1));\n        if (output < 0)\n            return 0;\n        else\n            return output;\n    }\n    mutate2(input) {\n        if (input <= 50) {\n            if (input < 0)\n                return 0;\n            else\n                return (this.rng.int % (2 * input + 1));\n        }\n        else {\n            if (input > 100)\n                return 100;\n            else\n                return (2 * input - 100 + this.rng.int % (200 - 2 * input + 1));\n        }\n    }\n    createSeedCrawlersInTunnels() {\n        let numberFound = 0;\n        let tries = 0;\n        new wall_crawler_WallCrawler(this.rng, this, new Point(2, 2), Point.SOUTH, 0, 1, 0, Point.SOUTH, 1, 0, 1, 0, 0, 0, 0, 0);\n        while ((numberFound < this.config.seedCrawlersInTunnels) && (tries < this.config.width * this.config.height)) {\n            tries++;\n            let startX = 1 + this.rng.int % (this.config.width - 4);\n            let startY = 1 + this.rng.int % (this.config.height - 4);\n            let test = new Point(startX, startY);\n            if ((this.rng.int % 100) < 50)\n                startX = 0;\n            else\n                startY = 0;\n            if (startX === 0) {\n                if ((this.rng.int % 100) < 50)\n                    startY = -1;\n                else\n                    startY = 1;\n            }\n            else {\n                console.assert(startY === 0);\n                if ((this.rng.int % 100) < 50)\n                    startX = -1;\n                else\n                    startX = 1;\n            }\n            let direction = new Point(startX, startY);\n            let orthogonal;\n            if (direction.x === 0) {\n                orthogonal = new Point(direction.y, 0);\n            }\n            else if (direction.y === 0) {\n                orthogonal = new Point(0, -direction.x);\n            }\n            else {\n                throw \"illegal direction\";\n            }\n            let notFound = true;\n            while (notFound) {\n                test = test.plus(direction);\n                if ((test.x < 2) || (test.y < 2) || (test.x > this.config.width - 3) || (test.y > this.config.height - 3)) {\n                    break;\n                }\n                if (this.getMap(test) !== TunnelerCellType.INSIDE_TUNNEL_OPEN)\n                    continue;\n                if ((this.getMap(test.plus(direction)) !== TunnelerCellType.INSIDE_TUNNEL_OPEN) || (this.getMap(test.minus(direction)) !== TunnelerCellType.INSIDE_TUNNEL_OPEN) ||\n                    (this.getMap(test.plus(orthogonal)) !== TunnelerCellType.INSIDE_TUNNEL_OPEN) || (this.getMap(test.minus(orthogonal)) !== TunnelerCellType.INSIDE_TUNNEL_OPEN) ||\n                    (this.getMap(test.plus(direction).plus(orthogonal)) !== TunnelerCellType.INSIDE_TUNNEL_OPEN) || (this.getMap(test.minus(direction).plus(orthogonal)) !== TunnelerCellType.INSIDE_TUNNEL_OPEN) ||\n                    (this.getMap(test.plus(direction).minus(orthogonal)) !== TunnelerCellType.INSIDE_TUNNEL_OPEN) || (this.getMap(test.minus(direction).minus(orthogonal)) !== TunnelerCellType.INSIDE_TUNNEL_OPEN))\n                    continue;\n                this.setMap(test, TunnelerCellType.CLOSED);\n                this.createWallCrawler(test, direction, 0, this.config.tunnelCrawlerStats.maxAge, this.activeGeneration + 1, direction, this.config.tunnelCrawlerStats.stepLength, 1, 1, this.config.tunnelCrawlerStats.straightSingleSpawnProbability, this.config.tunnelCrawlerStats.straightDoubleSpawnProbability, this.config.tunnelCrawlerStats.turnSingleSpawnProbability, this.config.tunnelCrawlerStats.turnDoubleSpawnProbability, this.config.tunnelCrawlerStats.changeDirectionProbability);\n                this.createWallCrawler(test, orthogonal, 0, this.config.tunnelCrawlerStats.maxAge, this.activeGeneration + 1, direction, this.config.tunnelCrawlerStats.stepLength, 1, 1, this.config.tunnelCrawlerStats.straightSingleSpawnProbability, this.config.tunnelCrawlerStats.straightDoubleSpawnProbability, this.config.tunnelCrawlerStats.turnSingleSpawnProbability, this.config.tunnelCrawlerStats.turnDoubleSpawnProbability, this.config.tunnelCrawlerStats.changeDirectionProbability);\n                this.createWallCrawler(test, orthogonal.negative, 0, this.config.tunnelCrawlerStats.maxAge, this.activeGeneration + 1, direction, this.config.tunnelCrawlerStats.stepLength, 1, 1, this.config.tunnelCrawlerStats.straightSingleSpawnProbability, this.config.tunnelCrawlerStats.straightDoubleSpawnProbability, this.config.tunnelCrawlerStats.turnSingleSpawnProbability, this.config.tunnelCrawlerStats.turnDoubleSpawnProbability, this.config.tunnelCrawlerStats.changeDirectionProbability);\n                if ((this.rng.int % 100) < this.config.tunnelCrawlerClosedProbability)\n                    this.createWallCrawler(test, direction.negative, 0, this.config.tunnelCrawlerStats.maxAge, this.activeGeneration + 1, direction, this.config.tunnelCrawlerStats.stepLength, 0, 1, this.config.tunnelCrawlerStats.straightSingleSpawnProbability, this.config.tunnelCrawlerStats.straightDoubleSpawnProbability, this.config.tunnelCrawlerStats.turnSingleSpawnProbability, this.config.tunnelCrawlerStats.turnDoubleSpawnProbability, this.config.tunnelCrawlerStats.changeDirectionProbability);\n                else\n                    this.createWallCrawler(test, direction.negative, 0, this.config.tunnelCrawlerStats.maxAge, this.activeGeneration + 1, direction, this.config.tunnelCrawlerStats.stepLength, 1, 1, this.config.tunnelCrawlerStats.straightSingleSpawnProbability, this.config.tunnelCrawlerStats.straightDoubleSpawnProbability, this.config.tunnelCrawlerStats.turnSingleSpawnProbability, this.config.tunnelCrawlerStats.turnDoubleSpawnProbability, this.config.tunnelCrawlerStats.changeDirectionProbability);\n                notFound = false;\n                numberFound++;\n            }\n        }\n    }\n    makeIteration() {\n        for (let i = 0; i < this.crawlers.length; i++) {\n            if (null !== this.crawlers[i]) {\n                if (!this.crawlers[i].stepAhead()) {\n                    this.crawlers[i] = null;\n                }\n            }\n        }\n        return false;\n    }\n    advanceGeneration() {\n        let isCrawlerExists = false;\n        let highestNegativeAge = 0;\n        for (let i = 0; i < this.crawlers.length; i++) {\n            if (null !== this.crawlers[i]) {\n                isCrawlerExists = true;\n                if (this.crawlers[i].generation === this.activeGeneration) {\n                    let a = this.crawlers[i].age;\n                    if (a >= 0)\n                        return true;\n                    else if ((highestNegativeAge === 0) || (a > highestNegativeAge))\n                        highestNegativeAge = a;\n                }\n            }\n        }\n        if (highestNegativeAge === 0) {\n            this.activeGeneration++;\n            return isCrawlerExists;\n        }\n        else {\n            console.assert(highestNegativeAge < 0);\n            for (let i = 0; i < this.crawlers.length; i++) {\n                if (null !== this.crawlers[i]) {\n                    if (this.crawlers[i].generation === this.activeGeneration)\n                        this.crawlers[i].age -= highestNegativeAge;\n                }\n            }\n            return isCrawlerExists;\n        }\n    }\n    createRoom(rect) {\n        if ((this.config.width < 10) || (this.config.height < 10))\n            return false;\n        if ((rect.endX - rect.startX) <= 5)\n            return false;\n        if ((rect.endY - rect.startY) <= 5)\n            return false;\n        let startX = rect.startX + 1 + this.rng.int % (rect.endX - rect.startX - 3);\n        let startY = rect.startY + 1 + this.rng.int % (rect.endY - rect.startY - 3);\n        let start = new Point(startX, startY);\n        if (!this.isOpen(start))\n            return false;\n        if (this.isChecked(start))\n            return false;\n        let maxRS = this.config.maxRoomSize;\n        if (!this.isMoreRoomsLabyrinth(RoomSize.LARGE))\n            maxRS = this.config.largeRoomSize;\n        if (!this.isMoreRoomsLabyrinth(RoomSize.LARGE) && !this.isMoreRoomsLabyrinth(RoomSize.MEDIUM))\n            maxRS = this.config.mediumRoomSize;\n        if (!this.isMoreRoomsLabyrinth())\n            return false;\n        let stillFindingMultiples = true;\n        let RoomSquaresChecked = [];\n        let RoomSquaresActive = [];\n        let ActiveFoundThisTurn = [];\n        RoomSquaresActive.push(start);\n        let numberFound;\n        while (stillFindingMultiples) {\n            stillFindingMultiples = false;\n            for (let actIt = 0; actIt < RoomSquaresActive.length;) {\n                let Curr = RoomSquaresActive[actIt];\n                numberFound = 0;\n                if (this.isOpen(Curr.plus(Point.NORTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.NORTH), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(Curr.plus(Point.SOUTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.SOUTH), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(Curr.plus(Point.EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.EAST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.EAST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(Curr.plus(Point.WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.WEST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.WEST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(Curr.plus(Point.NORTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.NORTH_EAST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_EAST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(Curr.plus(Point.NORTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.NORTH_WEST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_WEST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(Curr.plus(Point.SOUTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.SOUTH_EAST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_EAST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(Curr.plus(Point.SOUTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.SOUTH_WEST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_WEST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (numberFound > 2) {\n                    stillFindingMultiples = true;\n                    if (this.isOpen(Curr.plus(Point.NORTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.NORTH), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.NORTH));\n                    if (this.isOpen(Curr.plus(Point.SOUTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.SOUTH), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.SOUTH));\n                    if (this.isOpen(Curr.plus(Point.EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.EAST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.EAST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.EAST));\n                    if (this.isOpen(Curr.plus(Point.WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.WEST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.WEST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.WEST));\n                    if (this.isOpen(Curr.plus(Point.NORTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.NORTH_EAST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_EAST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.NORTH_EAST));\n                    if (this.isOpen(Curr.plus(Point.NORTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.NORTH_WEST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_WEST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.NORTH_WEST));\n                    if (this.isOpen(Curr.plus(Point.SOUTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.SOUTH_EAST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_EAST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.SOUTH_EAST));\n                    if (this.isOpen(Curr.plus(Point.SOUTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.SOUTH_WEST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_WEST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.SOUTH_WEST));\n                    if (!dungeon_crawler_DungeonCrawler.isCheckedList(Curr, RoomSquaresChecked)) {\n                        RoomSquaresChecked.push(Curr);\n                        this.setChecked(Curr);\n                    }\n                    RoomSquaresActive.splice(actIt, 1);\n                    actIt++;\n                }\n                else if (numberFound === 2) {\n                    let found = 0;\n                    if (this.isOpen(Curr.plus(Point.NORTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.NORTH), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH), ActiveFoundThisTurn)) {\n                        ActiveFoundThisTurn.push(Curr.plus(Point.NORTH));\n                        found++;\n                    }\n                    if (this.isOpen(Curr.plus(Point.SOUTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.SOUTH), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH), ActiveFoundThisTurn)) {\n                        ActiveFoundThisTurn.push(Curr.plus(Point.SOUTH));\n                        found++;\n                    }\n                    if (this.isOpen(Curr.plus(Point.EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.EAST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.EAST), ActiveFoundThisTurn)) {\n                        ActiveFoundThisTurn.push(Curr.plus(Point.EAST));\n                        found++;\n                    }\n                    if (this.isOpen(Curr.plus(Point.WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.WEST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.WEST), ActiveFoundThisTurn)) {\n                        ActiveFoundThisTurn.push(Curr.plus(Point.WEST));\n                        found++;\n                    }\n                    if (found === 1) {\n                        actIt++;\n                        continue;\n                    }\n                    if (this.isOpen(Curr.plus(Point.NORTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.NORTH_EAST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_EAST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.NORTH_EAST));\n                    if (this.isOpen(Curr.plus(Point.NORTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.NORTH_WEST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.NORTH_WEST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.NORTH_WEST));\n                    if (this.isOpen(Curr.plus(Point.SOUTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.SOUTH_EAST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_EAST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.SOUTH_EAST));\n                    if (this.isOpen(Curr.plus(Point.SOUTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(Curr.plus(Point.SOUTH_WEST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(Curr.plus(Point.SOUTH_WEST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(Curr.plus(Point.SOUTH_WEST));\n                    if (!dungeon_crawler_DungeonCrawler.isCheckedList(Curr, RoomSquaresChecked)) {\n                        RoomSquaresChecked.push(Curr);\n                        this.setChecked(Curr);\n                    }\n                    RoomSquaresActive.splice(actIt, 1);\n                    actIt++;\n                }\n                else if (numberFound ==\n                    1) {\n                    actIt++;\n                }\n                else {\n                    console.assert(numberFound === 0);\n                    if (!dungeon_crawler_DungeonCrawler.isCheckedList(Curr, RoomSquaresChecked)) {\n                        RoomSquaresChecked.push(Curr);\n                        this.setChecked(Curr);\n                    }\n                    RoomSquaresActive.splice(actIt, 1);\n                    actIt++;\n                }\n                if (RoomSquaresChecked.length > maxRS)\n                    return false;\n            }\n            for (let Curr of ActiveFoundThisTurn) {\n                if ((this.getMap(Curr) === TunnelerCellType.GUARANTEED_OPEN) || (this.getMap(Curr) === TunnelerCellType.NON_JOIN_GUARANTEED_OPEN))\n                    return false;\n                if (!dungeon_crawler_DungeonCrawler.isCheckedList(Curr, RoomSquaresChecked) && !dungeon_crawler_DungeonCrawler.isActive(Curr, RoomSquaresActive))\n                    RoomSquaresActive.push(Curr);\n            }\n            ActiveFoundThisTurn.splice(0, ActiveFoundThisTurn.length);\n        }\n        let proceeding = true;\n        let squaresFindingMultiples = 0;\n        let curr = Point.ZERO;\n        while (proceeding) {\n            squaresFindingMultiples = 0;\n            proceeding = false;\n            for (let actIt = 0; actIt < RoomSquaresActive.length;) {\n                curr = RoomSquaresActive[actIt];\n                numberFound = 0;\n                if (this.isOpen(curr.plus(Point.NORTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.NORTH), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(curr.plus(Point.SOUTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.SOUTH), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(curr.plus(Point.EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.EAST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.EAST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(curr.plus(Point.WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.WEST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.WEST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(curr.plus(Point.NORTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.NORTH_EAST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH_EAST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(curr.plus(Point.NORTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.NORTH_WEST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH_WEST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(curr.plus(Point.SOUTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.SOUTH_EAST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH_EAST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (this.isOpen(curr.plus(Point.SOUTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.SOUTH_WEST), RoomSquaresChecked) &&\n                    !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH_WEST), ActiveFoundThisTurn))\n                    numberFound++;\n                if (numberFound > 1) {\n                    squaresFindingMultiples++;\n                    actIt++;\n                }\n                else if (numberFound === 1) {\n                    proceeding = true;\n                    if (this.isOpen(curr.plus(Point.NORTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.NORTH), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(curr.plus(Point.NORTH));\n                    if (this.isOpen(curr.plus(Point.SOUTH)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.SOUTH), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(curr.plus(Point.SOUTH));\n                    if (this.isOpen(curr.plus(Point.EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.EAST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.EAST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(curr.plus(Point.EAST));\n                    if (this.isOpen(curr.plus(Point.WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.WEST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.WEST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(curr.plus(Point.WEST));\n                    if (this.isOpen(curr.plus(Point.NORTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.NORTH_EAST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH_EAST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(curr.plus(Point.NORTH_EAST));\n                    if (this.isOpen(curr.plus(Point.NORTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.NORTH_WEST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.NORTH_WEST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(curr.plus(Point.NORTH_WEST));\n                    if (this.isOpen(curr.plus(Point.SOUTH_EAST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.SOUTH_EAST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH_EAST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH_EAST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(curr.plus(Point.SOUTH_EAST));\n                    if (this.isOpen(curr.plus(Point.SOUTH_WEST)) && !dungeon_crawler_DungeonCrawler.isCheckedList(curr.plus(Point.SOUTH_WEST), RoomSquaresChecked) &&\n                        !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH_WEST), RoomSquaresActive) && !dungeon_crawler_DungeonCrawler.isActive(curr.plus(Point.SOUTH_WEST), ActiveFoundThisTurn))\n                        ActiveFoundThisTurn.push(curr.plus(Point.SOUTH_WEST));\n                    if (!dungeon_crawler_DungeonCrawler.isCheckedList(curr, RoomSquaresChecked)) {\n                        RoomSquaresChecked.push(curr);\n                        this.setChecked(curr);\n                    }\n                    RoomSquaresActive.splice(actIt, 1);\n                }\n                else {\n                    console.assert(numberFound === 0);\n                    if (!dungeon_crawler_DungeonCrawler.isCheckedList(curr, RoomSquaresChecked)) {\n                        RoomSquaresChecked.push(curr);\n                        this.setChecked(curr);\n                    }\n                    RoomSquaresActive.splice(actIt, 1);\n                }\n            }\n            for (curr of ActiveFoundThisTurn) {\n                if ((this.getMap(curr) === TunnelerCellType.GUARANTEED_OPEN) || (this.getMap(curr) === TunnelerCellType.NON_JOIN_GUARANTEED_OPEN))\n                    return false;\n                if (!dungeon_crawler_DungeonCrawler.isCheckedList(curr, RoomSquaresChecked) && !dungeon_crawler_DungeonCrawler.isActive(curr, RoomSquaresActive))\n                    RoomSquaresActive.push(curr);\n            }\n            ActiveFoundThisTurn.splice(0, ActiveFoundThisTurn.length);\n        }\n        if (squaresFindingMultiples > 1)\n            return false;\n        else if (squaresFindingMultiples === 0) {\n            console.assert(RoomSquaresChecked.length > 0);\n            console.log(\"FILLING CLOSED ROOM\");\n            for (let i = 0; i !== RoomSquaresChecked.length; i++) {\n                console.assert((this.getMap(RoomSquaresChecked[i]) === TunnelerCellType.OPEN) || (this.getMap(RoomSquaresChecked[i]) === TunnelerCellType.NON_JOIN_OPEN) ||\n                    (this.getMap(RoomSquaresChecked[i]) === TunnelerCellType.INSIDE_TUNNEL_OPEN) || (this.getMap(RoomSquaresChecked[i]) === TunnelerCellType.INSIDE_ANTEROOM_OPEN));\n                this.setMap(RoomSquaresChecked[i], TunnelerCellType.CLOSED);\n            }\n        }\n        else {\n            console.assert(squaresFindingMultiples === 1);\n            if (RoomSquaresChecked.length < this.config.minRoomSize)\n                return false;\n            let diffX = false;\n            let diffY = false;\n            for (let i = 0; i !== RoomSquaresChecked.length; i++) {\n                if (RoomSquaresChecked[i].x !== RoomSquaresChecked[0].x)\n                    diffX = true;\n                if (RoomSquaresChecked[i].y !== RoomSquaresChecked[0].y)\n                    diffY = true;\n            }\n            if (!diffX || !diffY)\n                return false;\n            if (this.getMap(curr.plus(Point.WEST)) === TunnelerCellType.V_DOOR || this.getMap(curr.plus(Point.EAST)) === TunnelerCellType.V_DOOR ||\n                this.getMap(curr.plus(Point.WEST)) === TunnelerCellType.H_DOOR || this.getMap(curr.plus(Point.EAST)) === TunnelerCellType.H_DOOR ||\n                this.getMap(curr.plus(Point.NORTH)) === TunnelerCellType.V_DOOR || this.getMap(curr.plus(Point.SOUTH)) === TunnelerCellType.V_DOOR ||\n                this.getMap(curr.plus(Point.NORTH)) === TunnelerCellType.H_DOOR || this.getMap(curr.plus(Point.SOUTH)) === TunnelerCellType.H_DOOR)\n                return false;\n            if (RoomSquaresChecked.length < this.config.mediumRoomSize)\n                if (!this.isMoreRoomsLabyrinth(RoomSize.SMALL))\n                    return false;\n                else\n                    this.currSmallRoomsLabyrinth++;\n            else if (RoomSquaresChecked.length < this.config.largeRoomSize)\n                if (!this.isMoreRoomsLabyrinth(RoomSize.MEDIUM))\n                    return false;\n                else\n                    this.currMediumRoomsLabyrinth++;\n            else if (RoomSquaresChecked.length < this.config.maxRoomSize)\n                if (!this.isMoreRoomsLabyrinth(RoomSize.LARGE))\n                    return false;\n                else\n                    this.currLargeRoomsLabyrinth++;\n            else\n                return false;\n            console.assert(RoomSquaresActive.length === 1);\n            curr = RoomSquaresActive[0];\n            if (this.isOpen(curr.plus(Point.NORTH))) {\n                console.assert(this.isOpen(curr.plus(Point.SOUTH)));\n                this.setMap(curr, TunnelerCellType.H_DOOR);\n            }\n            else if (this.isOpen(curr.plus(Point.WEST))) {\n                console.assert(this.isOpen(curr.plus(Point.EAST)));\n                this.setMap(curr, TunnelerCellType.V_DOOR);\n            }\n            let newRoom = new Room();\n            for (let i = 0; i !== RoomSquaresChecked.length; i++) {\n                console.assert((this.getMap(RoomSquaresChecked[i]) === TunnelerCellType.OPEN) || (this.getMap(RoomSquaresChecked[i]) === TunnelerCellType.NON_JOIN_OPEN) ||\n                    (this.getMap(RoomSquaresChecked[i]) === TunnelerCellType.INSIDE_TUNNEL_OPEN) || (this.getMap(RoomSquaresChecked[i]) === TunnelerCellType.INSIDE_ANTEROOM_OPEN));\n                this.setMap(RoomSquaresChecked[i], TunnelerCellType.INSIDE_ROOM_OPEN);\n                newRoom.inside.push(RoomSquaresChecked[i]);\n            }\n            newRoom.inDungeon = false;\n            this.rooms.push(newRoom);\n        }\n        return true;\n    }\n    generate() {\n        while (true) {\n            if (this.activeGeneration === this.config.tunnelCrawlerGeneration)\n                this.createSeedCrawlersInTunnels();\n            while (this.makeIteration()) {\n            }\n            if (!this.advanceGeneration())\n                break;\n        }\n        if ((this.config.tunnelCrawlerGeneration < 0) || (this.activeGeneration < this.config.tunnelCrawlerGeneration)) {\n            this.createSeedCrawlersInTunnels();\n            while (true) {\n                while (this.makeIteration()) {\n                }\n                if (!this.advanceGeneration())\n                    break;\n            }\n        }\n        let counter = 0;\n        let number = 0;\n        if (this.config.background === TunnelerCellType.OPEN) {\n            let rect = new FillRect(0, 0, this.config.width, this.config.height, this.config.background);\n            counter = 0;\n            number = this.config.width * this.config.height;\n            while (this.isMoreRoomsLabyrinth()) {\n                if (this.createRoom(rect)) {\n                }\n                else\n                    counter++;\n                if (counter > number)\n                    break;\n            }\n        }\n        for (let rect of this.config.design) {\n            if (rect.type !== TunnelerCellType.OPEN)\n                continue;\n            counter = 0;\n            number = (rect.endX - rect.startX) * (rect.endY - rect.startY);\n            while (this.isMoreRoomsLabyrinth()) {\n                if (this.createRoom(rect)) {\n                }\n                else\n                    counter++;\n                if (counter > number)\n                    break;\n            }\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/wfc/even.simple.tiled.ts\nvar even_simple_tiled_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nvar even_simple_tiled_Direction;\n(function (Direction) {\n    Direction[Direction[\"RIGHT\"] = 2] = \"RIGHT\";\n    Direction[Direction[\"DOWN\"] = 1] = \"DOWN\";\n})(even_simple_tiled_Direction || (even_simple_tiled_Direction = {}));\nvar CellType;\n(function (CellType) {\n    CellType[CellType[\"EMPTY\"] = 0] = \"EMPTY\";\n    CellType[CellType[\"FLOOR\"] = 1] = \"FLOOR\";\n    CellType[CellType[\"FLOOR_WALL_TOP\"] = 2] = \"FLOOR_WALL_TOP\";\n    CellType[CellType[\"WALL_MID\"] = 3] = \"WALL_MID\";\n    CellType[CellType[\"WALL_TOP\"] = 4] = \"WALL_TOP\";\n    CellType[CellType[\"WALL_SIDE\"] = 5] = \"WALL_SIDE\";\n})(CellType || (CellType = {}));\nclass even_simple_tiled_TilesetRulesBuilder {\n    constructor() {\n        this.tilesIndex = Indexer.identity();\n        this.cellsIndex = Indexer.array();\n        this.rightIndex = Indexer.array();\n        this.downIndex = Indexer.array();\n    }\n    addCell(floor, wall, type) {\n        const floorId = floor ? this.tilesIndex.index(floor) : -1;\n        const wallId = wall ? this.tilesIndex.index(wall) : -1;\n        return this.cellsIndex.index([floorId, wallId, type]);\n    }\n    addRuleRight(first, next) {\n        this.rightIndex.index([first, next]);\n    }\n    addRuleDown(first, next) {\n        this.downIndex.index([first, next]);\n    }\n    build() {\n        return {\n            size: 16,\n            tiles: this.tilesIndex.values,\n            cells: this.cellsIndex.values,\n            right: this.rightIndex.values,\n            down: this.downIndex.values,\n        };\n    }\n}\nclass even_simple_tiled_EvenSimpleTiledModel extends model_Model {\n    constructor(resources, tileset, rng, width, height, constraints) {\n        super(rng, width, height);\n        this.app = null;\n        this.resources = resources;\n        this.weights = [];\n        this.tileset = tileset;\n        this.constraints = constraints;\n        this.T = tileset.cells.length;\n        for (let i = 0; i < this.T; i++) {\n            this.weights[i] = 1;\n        }\n        const tmpPropagator = [];\n        for (let direction = 0; direction < 4; direction++) {\n            tmpPropagator[direction] = [];\n            for (let cell1 = 0; cell1 < this.T; cell1++) {\n                tmpPropagator[direction][cell1] = [];\n                for (let cell2 = 0; cell2 < this.T; cell2++) {\n                    tmpPropagator[direction][cell1][cell2] = false;\n                }\n            }\n        }\n        for (let [first, next] of tileset.right) {\n            const opposite = model_Model.opposite[even_simple_tiled_Direction.RIGHT];\n            tmpPropagator[even_simple_tiled_Direction.RIGHT][first][next] = true;\n            tmpPropagator[opposite][next][first] = true;\n        }\n        for (let [first, next] of tileset.down) {\n            const opposite = model_Model.opposite[even_simple_tiled_Direction.DOWN];\n            tmpPropagator[even_simple_tiled_Direction.DOWN][first][next] = true;\n            tmpPropagator[opposite][next][first] = true;\n        }\n        this.propagator = [];\n        for (let direction = 0; direction < 4; direction++) {\n            this.propagator[direction] = [];\n            for (let cell1 = 0; cell1 < this.T; cell1++) {\n                this.propagator[direction][cell1] = [];\n                for (let cell2 = 0; cell2 < this.T; cell2++) {\n                    if (tmpPropagator[direction][cell1][cell2]) {\n                        this.propagator[direction][cell1].push(cell2);\n                    }\n                }\n            }\n        }\n    }\n    onBoundary(x, y) {\n        return !this.periodic && (x < 0 || y < 0 || x >= this.FMX || y >= this.FMY);\n    }\n    clear() {\n        super.clear();\n        for (let constraint of this.constraints) {\n            constraint.onClear();\n            this.propagate();\n        }\n    }\n    backtrackConstraint(index, pattern) {\n        for (let constraint of this.constraints) {\n            constraint.onBacktrack(index, pattern);\n        }\n    }\n    banConstraint(index, pattern) {\n        for (let constraint of this.constraints) {\n            constraint.onBan(index, pattern);\n        }\n    }\n    initConstraint() {\n        for (let constraint of this.constraints) {\n            constraint.init(this);\n            if (this.status != Resolution.Undecided) {\n                if (this.debug)\n                    console.warn(\"failed init constraint\", this.status);\n                return;\n            }\n        }\n    }\n    stepConstraint() {\n        for (let constraint of this.constraints) {\n            constraint.check();\n            if (this.status != Resolution.Undecided) {\n                if (this.debug)\n                    console.warn(\"failed step constraint check\");\n                return;\n            }\n            this.propagate();\n            if (this.status != Resolution.Undecided) {\n                if (this.debug)\n                    console.warn(\"failed step constraint propagate\");\n                return;\n            }\n        }\n        this.deferredConstraintsStep = false;\n    }\n    testObserved(i) {\n        let x = i % this.FMX, y = Math.floor(i / this.FMX);\n        if (!this.onBoundary(x, y)) {\n            const patterns = this.wave[i].filter(v => v).length;\n            console.assert(patterns === 1, `wave ${i} pattern count ${patterns}`);\n        }\n    }\n    graphics(markup) {\n        const scale = 1;\n        const tilesize = this.tileset.size;\n        console.log(\"tilesize\", tilesize, this.tileset, this.tileset.size);\n        if (this.app == null) {\n            this.app = new external_PIXI_[\"Application\"]({\n                width: this.FMX * tilesize * scale,\n                height: this.FMY * tilesize * scale,\n                resolution: 1,\n                antialias: false,\n                autoStart: false,\n                sharedTicker: false,\n                sharedLoader: false\n            });\n            document.body.appendChild(this.app.view);\n        }\n        const app = this.app;\n        this.app.stage.removeChildren();\n        const container = new external_PIXI_[\"Container\"]();\n        container.scale.set(scale, scale);\n        app.stage.addChild(container);\n        if (this.observed != null) {\n            for (let x = 0; x < this.FMX; x++) {\n                for (let y = 0; y < this.FMY; y++) {\n                    let [floor, wall] = this.tileset.cells[this.observed[x + y * this.FMX]];\n                    if (floor >= 0) {\n                        const sprite = this.resources.sprite(this.tileset.tiles[floor]);\n                        sprite.position.set(x * tilesize, y * tilesize);\n                        sprite.zIndex = 1;\n                        container.addChild(sprite);\n                    }\n                    if (wall >= 0) {\n                        const sprite = this.resources.sprite(this.tileset.tiles[wall]);\n                        sprite.position.set(x * tilesize, y * tilesize);\n                        sprite.zIndex = 2;\n                        container.addChild(sprite);\n                    }\n                }\n            }\n        }\n        else {\n            for (let x = 0; x < this.FMX; x++) {\n                for (let y = 0; y < this.FMY; y++) {\n                    let a = this.wave[x + y * this.FMX];\n                    let weights_sum = 0;\n                    for (let t = 0; t < this.T; t++) {\n                        if (a[t]) {\n                            weights_sum += this.weights[t];\n                        }\n                    }\n                    const alpha = 1 / weights_sum;\n                    for (let t = 0; t < this.T; t++) {\n                        if (a[t]) {\n                            const [floor, wall] = this.tileset.cells[t];\n                            const tiles = (floor >= 0 ? 1 : 0) + (wall >= 0 ? 1 : 0);\n                            if (floor >= 0) {\n                                const sprite = this.resources.sprite(this.tileset.tiles[floor]);\n                                sprite.position.set(x * tilesize, y * tilesize);\n                                sprite.zIndex = 1;\n                                sprite.alpha = alpha * (1 / tiles) * this.weights[t];\n                                container.addChild(sprite);\n                            }\n                            if (wall >= 0) {\n                                const sprite = this.resources.sprite(this.tileset.tiles[wall]);\n                                sprite.position.set(x * tilesize, y * tilesize);\n                                sprite.zIndex = 2;\n                                sprite.alpha = alpha * (1 / tiles) * this.weights[t];\n                                container.addChild(sprite);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        const graphics = new external_PIXI_[\"Graphics\"]();\n        container.addChild(graphics);\n        graphics.lineStyle(1, 0xFF0000);\n        for (let i of markup) {\n            let x = i % this.FMX, y = Math.floor(i / this.FMX);\n            graphics.drawRect(x * tilesize, y * tilesize, tilesize, tilesize);\n        }\n        app.render();\n        const canvas = app.view;\n        console.log('%c ', `\n      font-size: 1px;\n      padding: ${canvas.height / 2}px ${canvas.width / 2}px;\n      background: no-repeat url(${canvas.toDataURL('image/png')});\n      background-size: ${canvas.width}px ${canvas.height}px;\n    `);\n    }\n}\nclass BorderConstraint {\n    constructor(isBorderCell) {\n        this.model = null;\n        this.isBorderCell = isBorderCell;\n    }\n    init(model) {\n        this.model = model;\n    }\n    onClear() {\n        console.log(\"on clear\");\n        const model = this.model;\n        const indices = model.FMX * model.FMY;\n        for (let i = 0; i < indices; i++) {\n            let x = i % model.FMX, y = Math.floor(i / model.FMX);\n            if (x === 0 || x === model.FMX - 1 || y === 0 || y === model.FMY - 1) {\n                for (let t = 0; t < model.T; t++) {\n                    if (model.wave[i][t] && !this.isBorderCell[t]) {\n                        model.ban(i, t);\n                    }\n                }\n            }\n        }\n    }\n    onBan(_index, _pattern) {\n    }\n    onBacktrack(_index, _pattern) {\n    }\n    check() {\n        return true;\n    }\n}\nclass even_simple_tiled_PathConstraint {\n    constructor(isPathCell) {\n        this.model = null;\n        this.graph = null;\n        this.couldBePath = [];\n        this.mustBePath = [];\n        this.refresh = [];\n        this.refreshQueue = [];\n        this.isPathCell = isPathCell;\n    }\n    init(model) {\n        this.model = model;\n        const indices = model.FMX * model.FMY;\n        this.couldBePath = model_buffer(indices, false);\n        this.mustBePath = model_buffer(indices, false);\n        this.refresh = model_buffer(indices, true);\n        this.refreshQueue = [];\n    }\n    onClear() {\n        let indices = this.model.FMX * this.model.FMY;\n        this.couldBePath = model_buffer(indices, false);\n        this.mustBePath = model_buffer(indices, false);\n        this.refresh = model_buffer(indices, true);\n        this.refreshQueue = [];\n        for (let i = 0; i < indices; i++) {\n            this.refreshQueue.push(i);\n        }\n        this.refreshAll();\n        this.graph = this.createGraph();\n    }\n    onBacktrack(index, _pattern) {\n        this.addRefresh(index);\n    }\n    onBan(index, _pattern) {\n        this.addRefresh(index);\n    }\n    addRefresh(index) {\n        if (!this.refresh[index]) {\n            const FMX = this.model.FMX;\n            const FMY = this.model.FMY;\n            let x = index % FMX, y = Math.floor(index / FMX);\n            this.refresh[index] = true;\n            this.refreshQueue.push(index);\n            for (let direction = 0; direction < 4; direction++) {\n                let dx = model_Model.DX[direction], dy = model_Model.DY[direction];\n                let sx = x + dx, sy = y + dy;\n                if (this.model.onBoundary(sx, sy)) {\n                    continue;\n                }\n                if (sx < 0)\n                    sx += FMX;\n                else if (sx >= FMX)\n                    sx -= FMX;\n                if (sy < 0)\n                    sy += FMY;\n                else if (sy >= FMY)\n                    sy -= FMY;\n                let s = sx + sy * FMX;\n                if (!this.refresh[s]) {\n                    this.refresh[s] = true;\n                    this.refreshQueue.push(s);\n                }\n            }\n        }\n    }\n    refreshAll() {\n        const model = this.model;\n        const T = model.T;\n        while (this.refreshQueue.length > 0) {\n            const i = this.refreshQueue.pop();\n            this.refresh[i] = false;\n            let pathCount = 0;\n            let totalCount = 0;\n            for (let t = 0; t < T; t++) {\n                if (model.wave[i][t]) {\n                    totalCount++;\n                    if (this.isPathCell[t]) {\n                        pathCount++;\n                    }\n                }\n            }\n            this.couldBePath[i] = pathCount > 0;\n            this.mustBePath[i] = pathCount > 0 && totalCount === pathCount;\n        }\n    }\n    check() {\n        while (true) {\n            this.refreshAll();\n            let isArticulation = this.getArticulationPoints();\n            if (isArticulation == null) {\n                if (this.model.debug)\n                    console.error(\"no articulation\");\n                this.model.status = Resolution.Contradiction;\n                return;\n            }\n            if (this.applyArticulationPoints(isArticulation)) {\n                if (this.model.debug) {\n                    console.log(\"articulation\");\n                    let markup = isArticulation\n                        .map((v, i) => [v, i])\n                        .filter(a => a[0])\n                        .map(a => a[1]);\n                    this.model.graphics(markup);\n                    console.log(\"continue articulation loop\");\n                }\n            }\n            else {\n                break;\n            }\n        }\n    }\n    applyArticulationPoints(isArticulation) {\n        const model = this.model;\n        const FMX = model.FMX;\n        const FMY = model.FMY;\n        let indices = FMX * FMY;\n        let changed = false;\n        for (let i = 0; i < indices; i++) {\n            if (isArticulation[i] && !this.mustBePath[i]) {\n                if (model.debug)\n                    console.log(\"articulation\", i);\n                let x = i % model.FMX, y = Math.floor(i / model.FMX);\n                if (model.debug)\n                    console.log(\"x, y, i\", x, y, i);\n                for (let t = 0; t < model.T; t++) {\n                    if (model.wave[i][t]) {\n                        if (this.isPathCell[t]) {\n                            if (model.debug)\n                                console.log(\"ban not path\", i, t);\n                            model.ban(i, t);\n                            changed = true;\n                        }\n                    }\n                }\n            }\n        }\n        return changed;\n    }\n    getArticulationPoints() {\n        const walkable = this.couldBePath;\n        const relevant = this.mustBePath;\n        const model = this.model;\n        const graph = this.graph;\n        const indices = walkable.length;\n        const low = model_buffer(indices, 0);\n        let num = 1;\n        const dfsNum = model_buffer(indices, 0);\n        const markup = [];\n        const isArticulation = model_buffer(indices, false);\n        function cutVertex(initialU) {\n            const stack = [];\n            stack.push(new CutVertexFrame(initialU));\n            let childRelevantSubtree = false;\n            let childCount = 0;\n            while (true) {\n                const frameIndex = stack.length - 1;\n                const frame = stack[frameIndex];\n                const u = frame.u;\n                let switchState = frame.state;\n                let loop;\n                do {\n                    loop = false;\n                    switch (switchState) {\n                        case 0: {\n                            let isRelevant = relevant != null && relevant[u];\n                            if (isRelevant) {\n                                isArticulation[u] = true;\n                            }\n                            frame.isRelevantSubtree = isRelevant;\n                            low[u] = dfsNum[u] = num++;\n                            markup.push(u);\n                            switchState = 1;\n                            loop = true;\n                            break;\n                        }\n                        case 1: {\n                            let neighbours = graph.neighbours[u];\n                            let neighbourIndex = frame.neighbourIndex;\n                            if (neighbourIndex >= neighbours.length) {\n                                switchState = 3;\n                                loop = true;\n                                break;\n                            }\n                            let v = neighbours[neighbourIndex];\n                            if (!walkable[v]) {\n                                frame.neighbourIndex = neighbourIndex + 1;\n                                switchState = 1;\n                                loop = true;\n                                break;\n                            }\n                            let unvisited = dfsNum[v] === 0;\n                            if (unvisited) {\n                                stack.push(new CutVertexFrame(v));\n                                frame.state = 2;\n                                switchState = 2;\n                                stack[frameIndex] = frame;\n                                break;\n                            }\n                            else {\n                                low[u] = Math.min(low[u], dfsNum[v]);\n                            }\n                            frame.neighbourIndex = neighbourIndex + 1;\n                            switchState = 1;\n                            loop = true;\n                            break;\n                        }\n                        case 2: {\n                            let neighbours = graph.neighbours[u];\n                            let neighbourIndex = frame.neighbourIndex;\n                            let v = neighbours[neighbourIndex];\n                            if (frameIndex == 0) {\n                                childCount++;\n                            }\n                            if (childRelevantSubtree) {\n                                frame.isRelevantSubtree = true;\n                            }\n                            if (low[v] >= dfsNum[u]) {\n                                if (relevant == null || childRelevantSubtree) {\n                                    isArticulation[u] = true;\n                                }\n                            }\n                            low[u] = Math.min(low[u], low[v]);\n                            frame.neighbourIndex = neighbourIndex + 1;\n                            switchState = 1;\n                            loop = true;\n                            break;\n                        }\n                        case 3: {\n                            if (frameIndex == 0) {\n                                return childCount;\n                            }\n                            else {\n                                childRelevantSubtree = frame.isRelevantSubtree;\n                                stack.splice(frameIndex, 1);\n                                break;\n                            }\n                        }\n                    }\n                } while (loop);\n            }\n        }\n        for (let i = 0; i < indices; i++) {\n            if (!walkable[i])\n                continue;\n            if (!relevant[i])\n                continue;\n            if (dfsNum[i] != 0)\n                continue;\n            cutVertex(i);\n            break;\n        }\n        for (let i = 0; i < indices; i++) {\n            if (relevant[i] && dfsNum[i] == 0) {\n                if (model.debug) {\n                    console.warn(\"walkable:\");\n                    let markupW = walkable\n                        .map((v, i) => [v, i])\n                        .filter(a => a[0])\n                        .map(a => a[1]);\n                    model.graphics(markupW);\n                    console.warn(\"visited\");\n                    model.graphics(markup);\n                    const w = model.FMX;\n                    let x = i % w, y = Math.floor(i / w);\n                    console.error(`not visited relevant point i=${i} x=${x} y=${y}`);\n                    console.warn('graph neighbours', graph.neighbours[i]);\n                    model.graphics([i]);\n                }\n                return null;\n            }\n        }\n        for (let i = 0; i < indices; i++) {\n            if (!walkable[i])\n                continue;\n            if (relevant[i])\n                continue;\n            if (dfsNum[i] != 0)\n                continue;\n            if (isArticulation[i])\n                continue;\n            let childCount = cutVertex(i);\n            isArticulation[i] = childCount > 1;\n        }\n        return isArticulation;\n    }\n    createGraph() {\n        const model = this.model;\n        let nodeCount = model.FMX * model.FMY;\n        let neighbours = [];\n        for (let i = 0; i < nodeCount; i++) {\n            neighbours[i] = [];\n            let x = i % model.FMX, y = Math.floor(i / model.FMX);\n            for (let direction = 0; direction < 4; direction++) {\n                let dx = model_Model.DX[direction], dy = model_Model.DY[direction];\n                let sx = x + dx, sy = y + dy;\n                if (!model.periodic && (sx >= model.FMX || sy >= model.FMY || sx < 0 || sy < 0)) {\n                    continue;\n                }\n                if (sx < 0)\n                    sx += model.FMX;\n                else if (sx >= model.FMX)\n                    sx -= model.FMX;\n                if (sy < 0)\n                    sy += model.FMY;\n                else if (sy >= model.FMY)\n                    sy -= model.FMY;\n                let s = sx + sy * model.FMX;\n                neighbours[i].push(s);\n            }\n        }\n        return {\n            nodeCount: nodeCount,\n            neighbours: neighbours,\n        };\n    }\n}\nclass CutVertexFrame {\n    constructor(u) {\n        this.state = 0;\n        this.neighbourIndex = 0;\n        this.isRelevantSubtree = false;\n        this.u = u;\n    }\n}\nclass even_simple_tiled_RoomConstraint {\n    constructor(isRoomCell, denyOther, tunneling) {\n        this.isRoomCell = [];\n        this.model = null;\n        this.isRoomCell = isRoomCell;\n        this.denyOther = denyOther;\n        this.tunnelingOptions = tunneling;\n    }\n    init(model) {\n        this.model = model;\n    }\n    onClear() {\n        const model = this.model;\n        const tunneling = new tunneling_TunnelingAlgorithm(model.rng, model.FMX, model.FMY, this.tunnelingOptions);\n        tunneling.generate();\n        const isRoom = model_buffer(model.FMX * model.FMY, false);\n        for (const room of tunneling.rooms) {\n            for (let y = room.y; y < room.y + room.h; y++) {\n                for (let x = room.x; x < room.x + room.w; x++) {\n                    isRoom[x + y * model.FMX] = true;\n                }\n            }\n        }\n        for (let i = 0; i < isRoom.length; i++) {\n            for (let t = 0; t < model.T; t++) {\n                if (isRoom[i]) {\n                    if (!this.isRoomCell[t]) {\n                        model.ban(i, t);\n                    }\n                }\n                else if (this.denyOther) {\n                    if (this.isRoomCell[t]) {\n                        model.ban(i, t);\n                    }\n                }\n            }\n        }\n    }\n    check() {\n    }\n    onBacktrack(_index, _pattern) {\n    }\n    onBan(_index, _pattern) {\n    }\n}\nclass even_simple_tiled_DungeonCrawlerConstraint {\n    constructor(config) {\n        this.model = null;\n        this.config = config;\n    }\n    init(model) {\n        this.model = model;\n    }\n    onClear() {\n        const model = this.model;\n        console.time(\"crawler\");\n        const crawler = new dungeon_crawler_DungeonCrawler(this.config, model.rng);\n        crawler.generate();\n        console.timeEnd(\"crawler\");\n        console.time(\"crawler constraint\");\n        const isOpen = model_buffer(model.FMX * model.FMY, false);\n        for (let y = 0; y < crawler.config.height; y++) {\n            for (let x = 0; x < crawler.config.width; x++) {\n                const i = x + y * model.FMX;\n                isOpen[i] = crawler.isMapOpen({ x: x, y: y });\n            }\n        }\n        function onlyFloorAround(i) {\n            let x = i % model.FMX, y = Math.floor(i / model.FMX);\n            for (let dy = 0; dy <= 1; dy++) {\n                for (let dx = -1; dx <= 1; dx++) {\n                    if (dx !== 0 || dy !== 0) {\n                        let sx = x + dx;\n                        let sy = y + dy;\n                        if (model.onBoundary(sx, sy))\n                            continue;\n                        if (!isOpen[sx + sy * model.FMX]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n        function hasFloorAround(i, h = 2) {\n            let x = i % model.FMX, y = Math.floor(i / model.FMX);\n            for (let dy = -1; dy <= h; dy++) {\n                for (let dx = -1; dx <= 1; dx++) {\n                    if (dx !== 0 || dy !== 0) {\n                        let sx = x + dx;\n                        let sy = y + dy;\n                        if (model.onBoundary(sx, sy))\n                            continue;\n                        if (isOpen[sx + sy * model.FMX]) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        function checkOpen(i, dx, dy) {\n            let x = i % model.FMX, y = Math.floor(i / model.FMX);\n            let sx = x + dx;\n            let sy = y + dy;\n            if (model.onBoundary(sx, sy))\n                return null;\n            return isOpen[sx + sy * model.FMX];\n        }\n        for (let i = 0; i < isOpen.length; i++) {\n            const possibleTypes = model_buffer(6, false);\n            const bottom = checkOpen(i, 0, 1);\n            if (isOpen[i]) {\n                possibleTypes[CellType.EMPTY] = false;\n                possibleTypes[CellType.FLOOR] = true;\n                if (!onlyFloorAround(i)) {\n                    possibleTypes[CellType.FLOOR_WALL_TOP] = true;\n                }\n            }\n            else {\n                if (hasFloorAround(i)) {\n                    const top = checkOpen(i, 0, -1);\n                    possibleTypes[CellType.EMPTY] = !(top === true || bottom === true);\n                    possibleTypes[CellType.WALL_MID] = top === true || bottom === true;\n                    possibleTypes[CellType.WALL_TOP] = true;\n                    possibleTypes[CellType.WALL_SIDE] = true;\n                }\n                else {\n                    possibleTypes[CellType.EMPTY] = true;\n                }\n            }\n            for (let t = 0; t < model.T; t++) {\n                const type = model.tileset.cells[t][2];\n                if (!possibleTypes[type]) {\n                    model.ban(i, t);\n                }\n            }\n        }\n        console.timeEnd(\"crawler constraint\");\n    }\n    check() {\n    }\n    onBacktrack(_index, _pattern) {\n    }\n    onBan(_index, _pattern) {\n    }\n}\nclass even_simple_tiled_EvenSimpleTiledModelTest {\n    static test(resources) {\n        return even_simple_tiled_awaiter(this, void 0, void 0, function* () {\n            const loader = new external_PIXI_[\"Loader\"]();\n            loader.add(\"village.rules.json\");\n            yield new Promise((resolve) => loader.load(() => resolve()));\n            const tileset = loader.resources[\"village.rules.json\"].data;\n            console.log(\"tileset\", tileset);\n            const filter = (regex) => {\n                const tiles = tileset.tiles.map(t => !!t.match(regex));\n                return tileset.cells.map(cell => {\n                    const [f, w] = cell;\n                    return f >= 0 && tiles[f] && w === -1;\n                });\n            };\n            const borderCells = filter(/^grass_\\d+\\.png$/);\n            const pathCells = filter(/^road_\\d+\\.png$/);\n            const roomCells = filter(/^wood_floor_\\d+\\.png$/);\n            console.log(\"borderCells\", borderCells);\n            console.log(\"pathCells\", pathCells);\n            console.log(\"roomCells\", roomCells);\n            const model = new even_simple_tiled_EvenSimpleTiledModel(resources, tileset, new RNG(), 50, 50, [\n                new BorderConstraint(borderCells),\n                new even_simple_tiled_RoomConstraint(roomCells, true, {\n                    room_max_w: 7,\n                    room_max_h: 5,\n                    max_corr_dist: 20,\n                    min_corr_dist_x: 5,\n                    min_corr_dist_y: 10,\n                }),\n                new even_simple_tiled_PathConstraint(pathCells),\n            ]);\n            console.time(\"model loop run\");\n            let state;\n            while (true) {\n                console.time(\"model run\");\n                state = yield model.run(10000);\n                console.timeEnd(\"model run\");\n                if (state !== Resolution.Decided) {\n                    console.error(\"failed run model\");\n                }\n                else {\n                    console.log(\"success run model\");\n                    break;\n                }\n            }\n            console.timeEnd(\"model loop run\");\n            console.log(\"model\", model);\n            model.graphics([]);\n        });\n    }\n}\n\n// CONCATENATED MODULE: ./src/wfc/dungeon.generator.ts\nvar dungeon_generator_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nclass dungeon_generator_HybridDungeonGenerator extends dungeon_generator_BaseDungeonGenerator {\n    constructor(controller) {\n        super(controller);\n        this.model = null;\n    }\n    get percent() {\n        var _a;\n        return ((_a = this.model) === null || _a === void 0 ? void 0 : _a.percent) || 0;\n    }\n    generate(options) {\n        return dungeon_generator_awaiter(this, void 0, void 0, function* () {\n            const tileset = this.controller.app.loader.resources['dungeon.rules.4.json'].data;\n            const config = this.controller.app.loader.resources['dungeon.design.json'].data;\n            const hero = options.hero;\n            let seed;\n            if (hero.dungeonSeeds.has(options.level)) {\n                seed = hero.dungeonSeeds.get(options.level);\n                console.log(`dungeon level ${options.level} exists seed: ${seed}`);\n            }\n            else {\n                seed = this.controller.rng.nextInt();\n                console.log(`dungeon level ${options.level} new seed: ${seed}`);\n                hero.dungeonSeeds.set(options.level, seed);\n            }\n            const rng = new RNG(seed);\n            yield yields(10);\n            const crawler = new even_simple_tiled_DungeonCrawlerConstraint(config);\n            this.model = new even_simple_tiled_EvenSimpleTiledModel(this.resources, tileset, rng, config.width, config.height, [crawler]);\n            console.time(\"model loop run\");\n            let state;\n            while (true) {\n                console.time(\"model run\");\n                state = yield this.model.run(10000);\n                console.timeEnd(\"model run\");\n                if (state !== Resolution.Decided) {\n                    console.error(\"failed run model\");\n                }\n                else {\n                    console.log(\"success run model\");\n                    break;\n                }\n                yield yields();\n            }\n            console.timeEnd(\"model loop run\");\n            const dungeon = this.createDungeon(rng, seed, options.level, this.model.FMX, this.model.FMY);\n            const observed = this.model.observed;\n            for (let y = 0; y < this.model.FMY; y++) {\n                for (let x = 0; x < this.model.FMX; x++) {\n                    const i = x + y * this.model.FMX;\n                    const [floor, wall] = tileset.cells[observed[i]];\n                    if (floor >= 0) {\n                        dungeon.cell(x, y).floorName = tileset.tiles[floor];\n                    }\n                    if (wall >= 0) {\n                        dungeon.cell(x, y).wallName = tileset.tiles[wall];\n                    }\n                }\n            }\n            yield yields();\n            this.replaceFloorRandomly(rng, dungeon);\n            yield yields();\n            this.replaceWallRandomly(rng, dungeon);\n            const heroAI = this.placeHero(rng, dungeon, options.hero);\n            yield yields();\n            this.placeLadder(rng, dungeon, heroAI);\n            yield yields();\n            const is_bonfire = options.level % 5 === 1;\n            if (is_bonfire) {\n                this.placeBonfire(rng, dungeon, heroAI);\n                yield yields();\n            }\n            this.placeNpc(rng, dungeon, heroAI);\n            yield yields();\n            this.placeMonsters(rng, dungeon, heroAI);\n            yield yields();\n            const is_boss = options.level % 5 === 0;\n            if (is_boss) {\n                this.placeBoss(rng, dungeon, heroAI);\n                yield yields();\n            }\n            this.placeDrop(rng, dungeon);\n            yield yields();\n            dungeon.light.loadMap();\n            yield yields();\n            return dungeon;\n        });\n    }\n}\n\n// CONCATENATED MODULE: ./src/generate.scene.ts\n\n\n\nclass generate_scene_GenerateDungeonScene {\n    constructor(controller, options) {\n        this.title = null;\n        this.controller = controller;\n        this.generator = new dungeon_generator_HybridDungeonGenerator(this.controller);\n        this.promise = this.generator.generate(options);\n        this.promise.then((dungeon) => this.controller.dungeon(options.hero, dungeon));\n        this.progressBar = new external_PIXI_[\"Graphics\"]();\n    }\n    init() {\n        this.renderTitle();\n        this.renderProgressBar();\n        this.controller.app.ticker.add(this.update, this);\n    }\n    destroy() {\n        var _a, _b;\n        this.controller.app.ticker.remove(this.update, this);\n        (_a = this.title) === null || _a === void 0 ? void 0 : _a.destroy();\n        (_b = this.progressBar) === null || _b === void 0 ? void 0 : _b.destroy();\n    }\n    pause() {\n    }\n    resume() {\n    }\n    renderTitle() {\n        this.title = new external_PIXI_[\"BitmapText\"](\"ROGUELIKE DUNGEON\", { font: { name: 'alagard', size: 64 } });\n        this.title.anchor = new external_PIXI_[\"Point\"](0.5, 0);\n        this.title.position.set(this.controller.app.screen.width >> 1, 64);\n        this.controller.stage.addChild(this.title);\n    }\n    renderProgressBar() {\n        this.progressBar = new external_PIXI_[\"Graphics\"]();\n        this.controller.stage.addChild(this.progressBar);\n    }\n    update() {\n        const c_w = this.controller.app.screen.width;\n        const c_h = this.controller.app.screen.height;\n        const margin = 40;\n        const h = 60;\n        const border = 4;\n        const w = c_w - margin - margin;\n        const w_p = Math.floor((w - border - border) * this.generator.percent / 100);\n        this.progressBar.clear();\n        this.progressBar.beginFill(ui[\"Colors\"].uiBackground, 0.3);\n        this.progressBar.drawRect(margin, c_h - margin - h - border - border, w, h);\n        this.progressBar.endFill();\n        this.progressBar.beginFill(ui[\"Colors\"].uiSelected, 0.3);\n        this.progressBar.drawRect(margin + border, c_h - margin - h - border, w_p, h - border - border);\n        this.progressBar.endFill();\n    }\n}\n\n// CONCATENATED MODULE: ./src/dungeon.scene.ts\n\n\n\nclass dungeon_scene_DungeonScene {\n    constructor(controller, hero, dungeon) {\n        this.controller = controller;\n        this.dungeon = dungeon;\n        this.titleView = new dungeon_map_DungeonTitle();\n        this.inventoryView = new inventory[\"BeltInventoryView\"](hero.inventory.belt);\n        this.healthView = new hero_HeroStateView(hero, { fixedHPSize: false });\n    }\n    init() {\n        const c_w = this.controller.app.screen.width;\n        const c_h = this.controller.app.screen.height;\n        this.titleView.position.set(c_w >> 1, 16);\n        this.titleView.zIndex = 10;\n        this.controller.stage.addChild(this.titleView);\n        const i_w = this.inventoryView.width;\n        this.inventoryView.position.set((c_w >> 1) - (i_w >> 1), c_h - (32 + 4 + 16));\n        this.inventoryView.zIndex = 11;\n        this.controller.stage.addChild(this.inventoryView);\n        this.healthView.position.set(16, 16);\n        this.healthView.zIndex = 12;\n        this.controller.stage.addChild(this.healthView);\n        this.titleView.level = this.dungeon.level;\n        this.dungeon.container.zIndex = 0;\n        this.controller.stage.addChild(this.dungeon.container);\n        this.dungeon.light.layer.zIndex = 1;\n        this.controller.stage.addChild(this.dungeon.light.layer);\n        this.dungeon.lighting.zIndex = 2;\n        this.dungeon.lighting.alpha = 0.8;\n        this.controller.stage.addChild(this.dungeon.lighting);\n        this.controller.stage.sortChildren();\n        this.dungeon.ticker.start();\n    }\n    destroy() {\n        this.titleView.destroy();\n        this.healthView.destroy();\n        this.inventoryView.destroy();\n        this.dungeon.destroy();\n        this.controller.stage.removeChildren();\n    }\n    pause() {\n        this.dungeon.ticker.stop();\n    }\n    resume() {\n        this.dungeon.ticker.start();\n    }\n}\n\n// CONCATENATED MODULE: ./src/keybind.scene.ts\n\nclass keybind_scene_KeyBindScene {\n    constructor(controller) {\n        this.controller = controller;\n    }\n    init() {\n        this.renderTitle();\n        this.renderHelp();\n        this.controller.app.ticker.add(this.handleInput, this);\n    }\n    destroy() {\n        this.controller.app.ticker.remove(this.handleInput, this);\n        this.controller.stage.removeChildren();\n    }\n    pause() {\n    }\n    resume() {\n    }\n    renderTitle() {\n        let title = new external_PIXI_[\"BitmapText\"](\"ROGUELIKE DUNGEON\", { font: { name: 'alagard', size: 64 } });\n        title.anchor = new external_PIXI_[\"Point\"](0.5, 0);\n        title.position.set(this.controller.app.screen.width >> 1, 64);\n        this.controller.stage.addChild(title);\n    }\n    renderHelp() {\n        const bindings = [\n            \"WASD - top, left, bottom, right\",\n            \"F - action\",\n            \"Q - drop weapon\",\n            \"I - inventory\",\n            \"1 ... 0 - belt\",\n            \"\",\n            \"PRESS F TO CONTINUE\",\n        ];\n        for (let i = 0; i < bindings.length; i++) {\n            const text = bindings[i];\n            if (text.length > 0) {\n                const line = new external_PIXI_[\"BitmapText\"](text, { font: { name: 'alagard', size: 32 } });\n                line.position.set(40, 200 + i * 30);\n                this.controller.stage.addChild(line);\n            }\n        }\n    }\n    handleInput() {\n        if (this.controller.joystick.hit.once()) {\n            this.controller.selectHero();\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/select.hero.scene.ts\n\n\n\n\nconst select_hero_scene_margin = 40;\nconst title_h = 32;\nconst tile_w = 16;\nconst tile_h = 28;\nclass select_hero_scene_SelectHeroScene {\n    constructor(controller) {\n        this.heroes = [];\n        this.controller = controller;\n        this.selectable = new ui[\"SelectableGrid\"](controller.joystick);\n    }\n    init() {\n        this.renderTitle();\n        this.renderHeroes();\n        this.controller.app.ticker.add(this.selectable.handleInput, this.selectable);\n    }\n    destroy() {\n        this.controller.app.ticker.remove(this.selectable.handleInput, this.selectable);\n        this.heroes.forEach(h => h.destroy());\n        this.controller.stage.removeChildren();\n    }\n    pause() {\n    }\n    resume() {\n    }\n    renderTitle() {\n        let title = new external_PIXI_[\"BitmapText\"](\"ROGUELIKE DUNGEON\", { font: { name: 'alagard', size: 64 } });\n        title.anchor = new external_PIXI_[\"Point\"](0.5, 0);\n        title.position.set(this.controller.app.screen.width >> 1, 64);\n        this.controller.stage.addChild(title);\n    }\n    renderHeroes() {\n        const c_w = this.controller.app.screen.width;\n        const c_h = this.controller.app.screen.height;\n        const total = heroCharacterNames.length;\n        const rect_w = Math.floor((c_w - select_hero_scene_margin * (total + 1)) / total);\n        const sprite_w = rect_w - (select_hero_scene_margin << 1);\n        const scale = sprite_w / tile_w;\n        const sprite_h = Math.floor(tile_h * scale);\n        const rect_h = sprite_h + title_h + select_hero_scene_margin * 3;\n        for (let i = 0; i < total; i++) {\n            const heroName = heroCharacterNames[i];\n            const d_x = select_hero_scene_margin * (i + 1) + rect_w * i;\n            const d_y = (c_h >> 1) - (rect_h >> 1);\n            const view = new select_hero_scene_SelectHeroView(rect_w, rect_h, heroName, this.controller.resources);\n            view.position.set(d_x, d_y);\n            this.heroes.push(view);\n            this.controller.stage.addChild(view);\n            this.selectable.set(i, 0, view, () => this.select(heroName));\n        }\n        this.selectable.reset();\n    }\n    select(name) {\n        const hero = hero_Hero.load(name, this.controller.persistent);\n        const weapon = new src_drop[\"Weapon\"](this.controller.resources, src_drop[\"weapons\"].knife);\n        hero.inventory.equipment.weapon.set(weapon);\n        this.controller.generateDungeon({\n            level: 1,\n            hero: hero\n        });\n    }\n}\nclass select_hero_scene_SelectHeroView extends external_PIXI_[\"Container\"] {\n    constructor(width, height, heroName, resources) {\n        super();\n        this.isSelected = false;\n        this.selectedBg = new external_PIXI_[\"Graphics\"]()\n            .beginFill(ui[\"Colors\"].uiSelected)\n            .drawRect(0, 0, width, height)\n            .endFill();\n        this.notSelectedBg = new external_PIXI_[\"Graphics\"]()\n            .beginFill(ui[\"Colors\"].uiNotSelected)\n            .drawRect(0, 0, width, height)\n            .endFill();\n        this.title = new external_PIXI_[\"BitmapText\"](heroName, { font: { name: 'alagard', size: title_h } });\n        this.title.anchor = 0.5;\n        this.title.position.set(width >> 1, select_hero_scene_margin);\n        const sprite_w = width - (select_hero_scene_margin << 1);\n        const scale = sprite_w / tile_w;\n        const sprite_h = Math.floor(tile_h * scale);\n        this.sprite = resources.animated(heroName + \"_idle\");\n        this.sprite.animationSpeed = 0.2;\n        this.sprite.width = sprite_w;\n        this.sprite.height = sprite_h;\n        this.sprite.position.set(select_hero_scene_margin, select_hero_scene_margin + select_hero_scene_margin + title_h);\n        this.addChild(this.selectedBg, this.notSelectedBg, this.title, this.sprite);\n        this.selected = false;\n    }\n    get selected() {\n        return this.isSelected;\n    }\n    set selected(selected) {\n        this.isSelected = selected;\n        if (selected) {\n            this.selectedBg.visible = true;\n            this.notSelectedBg.visible = false;\n            this.title.visible = true;\n            this.sprite.gotoAndPlay(0);\n        }\n        else {\n            this.selectedBg.visible = false;\n            this.notSelectedBg.visible = true;\n            this.title.visible = false;\n            this.sprite.gotoAndStop(0);\n        }\n    }\n    destroy() {\n        super.destroy();\n        this.selectedBg.destroy();\n        this.notSelectedBg.destroy();\n        this.title.destroy();\n        this.sprite.destroy();\n    }\n}\n\n// CONCATENATED MODULE: ./src/update.hero.scene.ts\n\n\n\n\nclass update_hero_scene_UpdateHeroScene {\n    constructor(controller, options) {\n        this.title = null;\n        this.sprite = null;\n        this.spriteBg = null;\n        this.state = null;\n        this.inventory = null;\n        this.buttons = [];\n        this.controller = controller;\n        this.hero = options.hero;\n        this.options = options;\n        this.selectable = new ui[\"SelectableGrid\"](controller.joystick);\n    }\n    init() {\n        const layout = new ui[\"Layout\"]();\n        this.renderTitle(layout);\n        this.renderState(layout);\n        this.renderIcon(layout);\n        this.renderContinue(layout);\n        layout.reset();\n        layout.offset(256 + ui[\"Sizes\"].uiMargin, 0);\n        layout.commit();\n        this.renderIncreaseHealth(layout);\n        layout.reset();\n        layout.offset(24 + ui[\"Sizes\"].uiMargin * 2, 0);\n        layout.commit();\n        this.renderInventory(layout);\n        this.selectable.reset();\n        this.controller.app.ticker.add(this.handleInput, this);\n    }\n    destroy() {\n        var _a, _b, _c, _d, _e;\n        this.controller.app.ticker.remove(this.handleInput, this);\n        (_a = this.title) === null || _a === void 0 ? void 0 : _a.destroy();\n        (_b = this.sprite) === null || _b === void 0 ? void 0 : _b.destroy();\n        (_c = this.spriteBg) === null || _c === void 0 ? void 0 : _c.destroy();\n        (_d = this.state) === null || _d === void 0 ? void 0 : _d.destroy();\n        (_e = this.inventory) === null || _e === void 0 ? void 0 : _e.destroy();\n        for (let button of this.buttons) {\n            button.destroy();\n        }\n        this.sprite = null;\n        this.spriteBg = null;\n        this.title = null;\n        this.state = null;\n        this.inventory = null;\n        this.buttons.splice(0, 1000);\n    }\n    pause() {\n    }\n    resume() {\n    }\n    renderTitle(layout) {\n        this.title = new external_PIXI_[\"BitmapText\"](\"ROGUELIKE DUNGEON\", { font: { name: 'alagard', size: 64 } });\n        this.title.anchor = new external_PIXI_[\"Point\"](0.5, 0);\n        this.title.position.set(this.controller.app.screen.width >> 1, 64);\n        this.controller.stage.addChild(this.title);\n        layout.offset(0, 128 + ui[\"Sizes\"].uiMargin);\n        layout.commit();\n    }\n    renderState(layout) {\n        layout.offset(ui[\"Sizes\"].uiMargin, 0);\n        layout.commit();\n        this.state = new hero_HeroStateView(this.hero, { fixedHPSize: true });\n        this.state.position.set(layout.x, layout.y);\n        this.controller.stage.addChild(this.state);\n        layout.offset(0, this.state.getBounds().height);\n    }\n    renderIcon(layout) {\n        this.sprite = this.controller.resources.animated(this.hero.name + \"_idle\");\n        this.sprite.play();\n        this.sprite.animationSpeed = 0.2;\n        const w = this.sprite.width;\n        const h = this.sprite.height;\n        this.sprite.width = 256 - (ui[\"Sizes\"].uiMargin << 1);\n        const scale = this.sprite.width / w;\n        this.sprite.height = Math.floor(scale * h);\n        const trimmed_h = Math.floor(scale * this.sprite.texture.trim.height);\n        const offset_y = this.sprite.height - trimmed_h;\n        layout.offset(0, ui[\"Sizes\"].uiMargin);\n        this.sprite.position.set(layout.x + ui[\"Sizes\"].uiMargin, layout.y + ui[\"Sizes\"].uiMargin - offset_y);\n        this.spriteBg = new external_PIXI_[\"Graphics\"]()\n            .beginFill(ui[\"Colors\"].uiBackground)\n            .drawRect(0, 0, 256, trimmed_h + (ui[\"Sizes\"].uiMargin << 1))\n            .endFill();\n        this.spriteBg.position.set(layout.x, layout.y);\n        this.controller.stage.addChild(this.spriteBg, this.sprite);\n        layout.offset(0, trimmed_h + (ui[\"Sizes\"].uiMargin << 1));\n    }\n    renderIncreaseHealth(layout) {\n        const button = new ui[\"Button\"]({\n            label: \"+\",\n            width: 24,\n            height: 24\n        });\n        button.position.set(layout.x, layout.y);\n        this.selectable.set(1, 0, button, () => this.hero.increaseHealth());\n        this.selectable.merge(1, 0, 1, 12);\n        this.buttons.push(button);\n        this.controller.stage.addChild(button);\n        layout.offset(0, 24);\n    }\n    renderContinue(layout) {\n        layout.offset(0, ui[\"Sizes\"].uiMargin);\n        const button = new ui[\"Button\"]({\n            label: \"Continue ...\",\n            width: 256,\n            height: 32,\n        });\n        button.position.set(layout.x, layout.y);\n        this.selectable.set(0, 0, button, () => this.controller.generateDungeon(this.options));\n        this.selectable.merge(0, 0, 1, 12);\n        this.buttons.push(button);\n        this.controller.stage.addChild(button);\n        layout.offset(0, 32);\n    }\n    renderInventory(layout) {\n        const controller = new inventory[\"DefaultInventoryActionsController\"](this.hero.inventory);\n        this.inventory = new inventory[\"InventoryView\"](this.hero.inventory, controller, this.selectable, 2);\n        this.inventory.position.set(layout.x, layout.y);\n        this.controller.stage.addChild(this.inventory);\n    }\n    handleInput() {\n        this.selectable.handleInput();\n    }\n}\n\n// EXTERNAL MODULE: ./src/inventory.modal.ts\nvar inventory_modal = __webpack_require__(\"./src/inventory.modal.ts\");\n\n// CONCATENATED MODULE: ./src/persistent.state.ts\nclass StoragePersistentStore {\n    constructor(storage, prefix) {\n        this.transaction = new Map();\n        this.storage = storage;\n        this.prefix = prefix;\n    }\n    clear() {\n        for (let key of Object.keys(this.storage)) {\n            if (key.startsWith(this.prefix)) {\n                this.storage.removeItem(key);\n            }\n        }\n        this.transaction.clear();\n    }\n    load(key) {\n        const value = this.storage.getItem(this.key(key));\n        if (value !== null) {\n            return JSON.parse(value);\n        }\n        else {\n            return null;\n        }\n    }\n    save(key, value) {\n        this.transaction.set(key, value);\n        this.storage.setItem(this.key(key), JSON.stringify(value));\n    }\n    commit() {\n        for (let [key, value] of this.transaction) {\n            this.storage.setItem(this.key(key), JSON.stringify(value));\n        }\n        this.transaction.clear();\n    }\n    key(key) {\n        return [this.prefix, key].join();\n    }\n}\nfunction isLocalhost() {\n    return location.hostname === \"localhost\" ||\n        location.hostname === \"0.0.0.0\" ||\n        location.hostname === \"127.0.0.1\";\n}\nclass SessionPersistentState {\n    constructor() {\n        const storage = isLocalhost() ? sessionStorage : localStorage;\n        this.global = new StoragePersistentStore(storage, \"global.\");\n        this.session = new StoragePersistentStore(storage, \"session.\");\n    }\n}\n\n// CONCATENATED MODULE: ./src/expression.ts\nvar TokenizerStates;\n(function (TokenizerStates) {\n    TokenizerStates[TokenizerStates[\"Started\"] = 1] = \"Started\";\n    TokenizerStates[TokenizerStates[\"ParsingNumber\"] = 2] = \"ParsingNumber\";\n    TokenizerStates[TokenizerStates[\"ParsingStringStarted\"] = 3] = \"ParsingStringStarted\";\n    TokenizerStates[TokenizerStates[\"ParsingString\"] = 4] = \"ParsingString\";\n    TokenizerStates[TokenizerStates[\"ParsingStringFinished\"] = 5] = \"ParsingStringFinished\";\n    TokenizerStates[TokenizerStates[\"ParsingFunction\"] = 6] = \"ParsingFunction\";\n    TokenizerStates[TokenizerStates[\"Finished\"] = 7] = \"Finished\";\n    TokenizerStates[TokenizerStates[\"ParsingContext\"] = 8] = \"ParsingContext\";\n    TokenizerStates[TokenizerStates[\"ParsingBracket\"] = 9] = \"ParsingBracket\";\n    TokenizerStates[TokenizerStates[\"Error\"] = 10] = \"Error\";\n})(TokenizerStates || (TokenizerStates = {}));\nvar KnownStringComponents;\n(function (KnownStringComponents) {\n    KnownStringComponents[KnownStringComponents[\"Delimiter\"] = 1] = \"Delimiter\";\n    KnownStringComponents[KnownStringComponents[\"Digit\"] = 2] = \"Digit\";\n    KnownStringComponents[KnownStringComponents[\"Bracket\"] = 3] = \"Bracket\";\n    KnownStringComponents[KnownStringComponents[\"Other\"] = 4] = \"Other\";\n    KnownStringComponents[KnownStringComponents[\"ContextBracket\"] = 5] = \"ContextBracket\";\n    KnownStringComponents[KnownStringComponents[\"Quote\"] = 6] = \"Quote\";\n})(KnownStringComponents || (KnownStringComponents = {}));\nconst tokenStateMachine = {\n    [TokenizerStates.Started]: {\n        [KnownStringComponents.Delimiter]: TokenizerStates.Started,\n        [KnownStringComponents.Digit]: TokenizerStates.ParsingNumber,\n        [KnownStringComponents.Bracket]: TokenizerStates.ParsingBracket,\n        [KnownStringComponents.Other]: TokenizerStates.ParsingFunction,\n        [KnownStringComponents.ContextBracket]: TokenizerStates.ParsingContext,\n        [KnownStringComponents.Quote]: TokenizerStates.ParsingStringStarted\n    },\n    [TokenizerStates.ParsingNumber]: {\n        [KnownStringComponents.Delimiter]: TokenizerStates.Finished,\n        [KnownStringComponents.Digit]: TokenizerStates.ParsingNumber,\n        [KnownStringComponents.Bracket]: TokenizerStates.Finished,\n        [KnownStringComponents.Other]: TokenizerStates.Finished,\n        [KnownStringComponents.ContextBracket]: TokenizerStates.Error,\n        [KnownStringComponents.Quote]: TokenizerStates.Error\n    },\n    [TokenizerStates.ParsingFunction]: {\n        [KnownStringComponents.Delimiter]: TokenizerStates.Finished,\n        [KnownStringComponents.Digit]: TokenizerStates.ParsingFunction,\n        [KnownStringComponents.Bracket]: TokenizerStates.Finished,\n        [KnownStringComponents.Other]: TokenizerStates.ParsingFunction,\n        [KnownStringComponents.ContextBracket]: TokenizerStates.Error,\n        [KnownStringComponents.Quote]: TokenizerStates.Error\n    },\n    [TokenizerStates.ParsingContext]: {\n        [KnownStringComponents.Delimiter]: TokenizerStates.Finished,\n        [KnownStringComponents.Digit]: TokenizerStates.ParsingContext,\n        [KnownStringComponents.Bracket]: TokenizerStates.Finished,\n        [KnownStringComponents.Other]: TokenizerStates.ParsingContext,\n        [KnownStringComponents.ContextBracket]: TokenizerStates.ParsingContext,\n        [KnownStringComponents.Quote]: TokenizerStates.Error\n    },\n    [TokenizerStates.ParsingBracket]: {\n        [KnownStringComponents.Delimiter]: TokenizerStates.Finished,\n        [KnownStringComponents.Digit]: TokenizerStates.Finished,\n        [KnownStringComponents.Bracket]: TokenizerStates.Finished,\n        [KnownStringComponents.Other]: TokenizerStates.Finished,\n        [KnownStringComponents.ContextBracket]: TokenizerStates.Finished,\n        [KnownStringComponents.Quote]: TokenizerStates.Finished\n    },\n    [TokenizerStates.ParsingStringStarted]: {\n        [KnownStringComponents.Delimiter]: TokenizerStates.ParsingString,\n        [KnownStringComponents.Digit]: TokenizerStates.ParsingString,\n        [KnownStringComponents.Bracket]: TokenizerStates.ParsingString,\n        [KnownStringComponents.Other]: TokenizerStates.ParsingString,\n        [KnownStringComponents.ContextBracket]: TokenizerStates.ParsingString,\n        [KnownStringComponents.Quote]: TokenizerStates.Finished\n    },\n    [TokenizerStates.ParsingString]: {\n        [KnownStringComponents.Delimiter]: TokenizerStates.ParsingString,\n        [KnownStringComponents.Digit]: TokenizerStates.ParsingString,\n        [KnownStringComponents.Bracket]: TokenizerStates.ParsingString,\n        [KnownStringComponents.Other]: TokenizerStates.ParsingString,\n        [KnownStringComponents.ContextBracket]: TokenizerStates.ParsingString,\n        [KnownStringComponents.Quote]: TokenizerStates.ParsingStringFinished\n    },\n    [TokenizerStates.ParsingStringFinished]: {\n        [KnownStringComponents.Delimiter]: TokenizerStates.Finished,\n        [KnownStringComponents.Digit]: TokenizerStates.Finished,\n        [KnownStringComponents.Bracket]: TokenizerStates.Finished,\n        [KnownStringComponents.Other]: TokenizerStates.Finished,\n        [KnownStringComponents.ContextBracket]: TokenizerStates.Finished,\n        [KnownStringComponents.Quote]: TokenizerStates.Finished\n    }\n};\nclass Expression {\n    constructor() {\n        this.operations = {\n            \"+\": {\n                priority: 0,\n                variable: false,\n                apply: (a, b) => a + b\n            },\n            \"-\": {\n                priority: 0,\n                variable: false,\n                apply: (a, b) => a - b\n            },\n            \"*\": {\n                priority: 1,\n                variable: false,\n                apply: (a, b) => a * b\n            },\n            \"/\": {\n                priority: 1,\n                variable: false,\n                apply: (a, b) => a / b\n            },\n            \"%\": {\n                priority: 1,\n                variable: false,\n                apply: (a, b) => a % b\n            },\n            or: {\n                priority: 0,\n                variable: false,\n                apply: (a, b) => a || b\n            },\n            and: {\n                priority: 1,\n                variable: false,\n                apply: (a, b) => a && b\n            },\n            \"!\": {\n                priority: 2,\n                variable: false,\n                apply: (a) => !a\n            },\n            true: {\n                priority: 100,\n                variable: false,\n                apply: () => true\n            },\n            false: {\n                priority: 100,\n                variable: false,\n                apply: () => false\n            },\n            $$getContextValue: {\n                priority: 100,\n                variable: false,\n                apply: (contextPropertyName, context) => {\n                    let propertyName = contextPropertyName.substring(1, contextPropertyName.length - 1);\n                    return context[propertyName];\n                }\n            }\n        };\n        this.context = {};\n    }\n    static classifySymbol(symbol) {\n        if (Expression.delimiters.indexOf(symbol) !== -1) {\n            return KnownStringComponents.Delimiter;\n        }\n        else if (Expression.brackets.indexOf(symbol) !== -1) {\n            return KnownStringComponents.Bracket;\n        }\n        else if (Expression.digits.indexOf(symbol) !== -1) {\n            return KnownStringComponents.Digit;\n        }\n        else if (Expression.contextBrackets.indexOf(symbol) !== -1) {\n            return KnownStringComponents.ContextBracket;\n        }\n        else if (Expression.quotes.indexOf(symbol) !== -1) {\n            return KnownStringComponents.Quote;\n        }\n        else {\n            return KnownStringComponents.Other;\n        }\n    }\n    isOfMoreOrEqualPriority(currentOp, otherOp) {\n        return (this.operations[currentOp].priority <= this.operations[otherOp].priority);\n    }\n    scanToken(str, start) {\n        let state = TokenizerStates.Started;\n        let workingState = TokenizerStates.Error;\n        let tokenString = \"\";\n        let i = start;\n        while (i < str.length &&\n            (state !== TokenizerStates.Finished && state !== TokenizerStates.Error)) {\n            let symbolClass = Expression.classifySymbol(str[i]);\n            state = tokenStateMachine[state][symbolClass];\n            if (state === TokenizerStates.ParsingFunction &&\n                this.operations[tokenString] !== undefined) {\n                state = TokenizerStates.Finished;\n            }\n            if (state === TokenizerStates.ParsingFunction ||\n                state === TokenizerStates.ParsingNumber ||\n                state === TokenizerStates.ParsingBracket ||\n                state === TokenizerStates.ParsingContext ||\n                state === TokenizerStates.ParsingString) {\n                workingState = state;\n                tokenString += str[i++];\n            }\n            else if (state === TokenizerStates.Started ||\n                state === TokenizerStates.ParsingStringStarted ||\n                state === TokenizerStates.ParsingStringFinished) {\n                i++;\n            }\n        }\n        if (tokenString === \"\") {\n            workingState = TokenizerStates.Error;\n        }\n        return {\n            workingState,\n            tokenString,\n            pos: i\n        };\n    }\n    convertToRPN(tokens) {\n        let stack = [];\n        let rpn = [];\n        let currToken;\n        let j = 0;\n        for (let i = 0; i < tokens.length; i++) {\n            if (tokens[i].type === \"n\") {\n                rpn[j++] = tokens[i];\n                continue;\n            }\n            if (tokens[i].type === \"(\") {\n                stack.push(tokens[i]);\n                continue;\n            }\n            if (tokens[i].type === \")\") {\n                do {\n                    currToken = stack.pop();\n                    rpn[j++] = currToken;\n                } while (rpn[j - 1].type !== \"(\");\n                j--;\n                continue;\n            }\n            if (Object.keys(this.operations).indexOf(tokens[i].type) !== -1) {\n                if (stack.length > 0) {\n                    do {\n                        currToken = stack.pop();\n                        rpn[j++] = currToken;\n                    } while (stack.length > 0 &&\n                        Expression.brackets.indexOf(rpn[j - 1].type) === -1 &&\n                        this.isOfMoreOrEqualPriority(tokens[i].type, rpn[j - 1].type));\n                    if (Expression.brackets.indexOf(rpn[j - 1].type) !== -1 ||\n                        !this.isOfMoreOrEqualPriority(tokens[i].type, rpn[j - 1].type)) {\n                        stack.push(currToken);\n                        j--;\n                    }\n                }\n                stack.push(tokens[i]);\n            }\n        }\n        while (stack.length > 0) {\n            currToken = stack.pop();\n            rpn[j++] = currToken;\n        }\n        return rpn;\n    }\n    calculateRPN(rpn) {\n        var _a;\n        let operands = [];\n        if (rpn.length === 0) {\n            return null;\n        }\n        for (let i = 0; i < rpn.length; i++) {\n            if (rpn[i].type === \"n\") {\n                operands.push(rpn[i]);\n            }\n            else {\n                let op = this.operations[rpn[i].type];\n                let func = op.apply;\n                let len = op.variable ? operands.length : func.length;\n                let args = operands.splice(operands.length - len).map(op => op.value);\n                let result = func.apply(null, args);\n                operands.push({ type: \"n\", value: result });\n            }\n        }\n        return ((_a = operands.shift()) === null || _a === void 0 ? void 0 : _a.value) || null;\n    }\n    tokenize(expression) {\n        const tokens = [];\n        for (let i = 0; i < expression.length;) {\n            let tokenCandidate = this.scanToken(expression, i);\n            if (tokenCandidate.workingState !== TokenizerStates.Error) {\n                if (tokenCandidate.workingState === TokenizerStates.ParsingNumber) {\n                    tokens.push({\n                        type: \"n\",\n                        value: tokenCandidate.tokenString.indexOf(\".\") !== -1\n                            ? parseFloat(tokenCandidate.tokenString)\n                            : parseInt(tokenCandidate.tokenString)\n                    });\n                }\n                else if (tokenCandidate.workingState === TokenizerStates.ParsingContext) {\n                    tokens.push({\n                        type: \"$$getContextValue\",\n                        value: null\n                    });\n                    tokens.push({\n                        type: \"n\",\n                        value: tokenCandidate.tokenString\n                    });\n                    tokens.push({\n                        type: \"n\",\n                        value: this.context\n                    });\n                }\n                else if (tokenCandidate.workingState === TokenizerStates.ParsingString) {\n                    tokens.push({\n                        type: \"n\",\n                        value: tokenCandidate.tokenString\n                    });\n                }\n                else {\n                    tokens.push({\n                        type: tokenCandidate.tokenString,\n                        value: null\n                    });\n                }\n            }\n            i = tokenCandidate.pos;\n        }\n        return tokens;\n    }\n    register(name, priority, variable, apply) {\n        this.operations[name] = { priority: priority, variable: variable, apply: apply };\n    }\n    evaluate(expression, context = {}) {\n        this.context = context;\n        const tokens = this.tokenize(expression);\n        const rpn = this.convertToRPN(tokens);\n        return this.calculateRPN(rpn);\n    }\n}\nExpression.digits = \"0123456789.\";\nExpression.brackets = \"()\";\nExpression.contextBrackets = \"{}\";\nExpression.delimiters = \" ,\\r\\r\\n\";\nExpression.quotes = \"\\'\\\"\";\n\n// CONCATENATED MODULE: ./src/template.ts\nclass Template {\n    constructor() {\n        this.context = {};\n    }\n    add(key, value) {\n        this.context[key] = value;\n    }\n    render(template) {\n        return template.replace(/{{([^}]+)}}/g, (_match, token) => {\n            let sub = token.split('.');\n            if (sub.length >= 1) {\n                let value = this.context;\n                while (sub.length > 0) {\n                    const [next] = sub.splice(0, 1);\n                    value = value[next];\n                }\n                return value || null;\n            }\n            return token;\n        });\n    }\n}\n\n// CONCATENATED MODULE: ./src/dialog.ts\n\n\n\n\n\nclass DialogManager {\n    constructor(controller) {\n        this.controller = controller;\n        this.config = controller.app.loader.resources['dialogs.json'].data;\n    }\n    dialog(hero, npc) {\n        const config = this.config[npc.name] || this.config[\"default\"];\n        return new dialog_Dialog(this.controller, hero, npc, config);\n    }\n}\nclass dialog_Dialog {\n    constructor(controller, hero, npc, config) {\n        this._question = new observable[\"EventPublisher\"]();\n        this.controller = controller;\n        this.hero = hero;\n        this.npc = npc;\n        this._config = config;\n        this._expression = new Expression();\n        this._expression.register(\"goto\", 100, true, this.goto.bind(this));\n        this._expression.register(\"exit\", 100, false, this.exit.bind(this));\n        this._expression.register(\"context\", 100, false, this.context.bind(this));\n        this._expression.register(\"hasSkill\", 100, false, this.hasSkill.bind(this));\n        this._expression.register(\"skill\", 100, false, this.skill.bind(this));\n        this._template = new Template();\n        this._template.add(\"hero\", this.hero);\n        this._template.add(\"npc\", this.npc);\n    }\n    get question() {\n        return this._question;\n    }\n    start() {\n        this.goto(...this._config.start);\n    }\n    hasSkill(id) {\n        return this.npc.hasSkill(id);\n    }\n    skill(id) {\n        var _a;\n        (_a = this.npc.getSkill(id)) === null || _a === void 0 ? void 0 : _a.use(this.hero);\n    }\n    exit() {\n        this.controller.closeModal();\n    }\n    context(key, value) {\n        if (value === undefined) {\n            return this.npc.getContext(key);\n        }\n        else {\n            this.npc.setContext(key, value);\n            return null;\n        }\n    }\n    goto(...ids) {\n        for (let id of ids) {\n            const config = this._config.questions[id];\n            if (this.check(config.conditions || [])) {\n                const text = this._template.render(config.text);\n                const question = new DialogQuestion(this, text);\n                for (let answer of config.answers) {\n                    if (this.check(answer.conditions)) {\n                        const text = this._template.render(answer.text);\n                        question.add(text, answer.commands);\n                    }\n                }\n                this._question.send(question);\n                return;\n            }\n        }\n    }\n    check(conditions) {\n        if (conditions) {\n            for (let rule of conditions) {\n                if (!this.evaluate(rule)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    evaluate(command) {\n        return this._expression.evaluate(command);\n    }\n}\nclass DialogQuestion {\n    constructor(dialog, text) {\n        this.answers = [];\n        this.dialog = dialog;\n        this.text = text;\n    }\n    add(text, commands) {\n        this.answers.push(new DialogAnswer(this.dialog, text, commands));\n    }\n}\nclass DialogAnswer {\n    constructor(dialog, text, commands) {\n        this.dialog = dialog;\n        this.text = text;\n        this.commands = commands;\n    }\n    action() {\n        for (let command of this.commands) {\n            this.dialog.evaluate(command);\n        }\n    }\n}\nclass dialog_DialogModalScene {\n    constructor(controller, dialog) {\n        this.container = null;\n        this.background = null;\n        this.selectable = null;\n        this._width = 0;\n        this._layout = new ui[\"Layout\"]();\n        this._question = null;\n        this._answers = [];\n        this.controller = controller;\n        this.dialog = dialog;\n    }\n    init() {\n        this.background = new external_PIXI_[\"Graphics\"]();\n        this.selectable = new ui[\"SelectableGrid\"](this.controller.joystick);\n        const width = 600;\n        const height = 400;\n        this.background.beginFill(0x000000).drawRect(0, 0, width, height).endFill();\n        this.background.zIndex = 0;\n        this.container = new external_PIXI_[\"Container\"]();\n        this.container.addChild(this.background);\n        this.container.sortChildren();\n        this.container.position.set((this.controller.app.screen.width >> 1) - (width >> 1), (this.controller.app.screen.height >> 1) - (height >> 1));\n        const layout = this._layout;\n        layout.offset(ui[\"Sizes\"].uiMargin, ui[\"Sizes\"].uiMargin);\n        const icon = this.controller.resources.animated(this.dialog.npc.name + \"_idle\");\n        icon.animationSpeed = 0.2;\n        icon.play();\n        icon.width = icon.width * 4;\n        icon.height = icon.height * 4;\n        icon.position.set(layout.x + ui[\"Sizes\"].uiBorder, layout.y + ui[\"Sizes\"].uiBorder);\n        const iconBg = new external_PIXI_[\"Graphics\"]();\n        iconBg.beginFill(ui[\"Colors\"].uiBackground)\n            .drawRect(layout.x, layout.y, icon.width + ui[\"Sizes\"].uiBorder * 2, icon.height + ui[\"Sizes\"].uiBorder * 2)\n            .endFill();\n        layout.reset();\n        layout.offset(icon.width, 0);\n        layout.offset(ui[\"Sizes\"].uiMargin, 0);\n        layout.offset(ui[\"Sizes\"].uiBorder * 2, 0);\n        layout.commit();\n        this._width = width - layout.x;\n        this.container.addChild(iconBg, icon);\n        this.controller.stage.addChild(this.container);\n        this.controller.app.ticker.add(this.handleInput, this);\n        this.dialog.question.subscribe(this.onQuestion, this);\n        this.dialog.start();\n    }\n    destroy() {\n        var _a, _b;\n        this.dialog.question.unsubscribe(this.onQuestion, this);\n        this.controller.app.ticker.remove(this.handleInput, this);\n        (_a = this.container) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.container = null;\n        (_b = this.background) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.background = null;\n        this.selectable = null;\n    }\n    onQuestion(question) {\n        var _a;\n        (_a = this._question) === null || _a === void 0 ? void 0 : _a.destroy();\n        for (let i = 0; i < this._answers.length; i++) {\n            let answer = this._answers[i];\n            answer.destroy();\n            this.selectable.remove(0, i);\n        }\n        this.selectable.reset();\n        this._answers = [];\n        const width = this._width - ui[\"Sizes\"].uiMargin * 2;\n        const layout = this._layout;\n        layout.reset();\n        layout.offset(ui[\"Sizes\"].uiMargin, ui[\"Sizes\"].uiMargin);\n        this._question = new dialog_DialogQuestionView(question, width);\n        this._question.position.set(layout.x, layout.y);\n        this.container.addChild(this._question);\n        layout.offset(0, this._question.height);\n        layout.offset(0, ui[\"Sizes\"].uiMargin);\n        for (let i = 0; i < question.answers.length; i++) {\n            let answer = question.answers[i];\n            const view = new dialog_DialogAnswerView(answer, width);\n            this.selectable.set(0, i, view, answer.action.bind(answer));\n            view.position.set(layout.x, layout.y);\n            layout.offset(0, view.height);\n            layout.offset(0, ui[\"Sizes\"].uiMargin);\n            this._answers.push(view);\n            this.container.addChild(view);\n        }\n        this.selectable.reset();\n    }\n    handleInput() {\n        var _a;\n        (_a = this.selectable) === null || _a === void 0 ? void 0 : _a.handleInput();\n    }\n}\nclass dialog_DialogQuestionView extends external_PIXI_[\"Container\"] {\n    constructor(question, width) {\n        super();\n        this._text = new external_PIXI_[\"BitmapText\"](question.text, { font: { name: \"alagard\", size: 16 } });\n        this._text.maxWidth = width - ui[\"Sizes\"].uiBorder * 2;\n        this._text.calculateBounds();\n        this._text.position.set(ui[\"Sizes\"].uiBorder, ui[\"Sizes\"].uiBorder);\n        const height = this._text.height + ui[\"Sizes\"].uiBorder * 2;\n        this._background = new external_PIXI_[\"Graphics\"]();\n        this._background\n            .clear()\n            .beginFill(ui[\"Colors\"].uiBackground, 0.3)\n            .drawRect(0, 0, width, height)\n            .endFill();\n        this.addChild(this._background, this._text);\n    }\n}\nclass dialog_DialogAnswerView extends external_PIXI_[\"Container\"] {\n    constructor(answer, width) {\n        super();\n        this._selected = false;\n        this._background = new external_PIXI_[\"Graphics\"]();\n        this._text = new external_PIXI_[\"BitmapText\"](answer.text, { font: { name: \"alagard\", size: 16 } });\n        this._text.maxWidth = width - ui[\"Sizes\"].uiBorder * 2;\n        this._text.calculateBounds();\n        this._text.position.set(ui[\"Sizes\"].uiBorder, ui[\"Sizes\"].uiBorder);\n        this._width = width;\n        this._height = this._text.height + ui[\"Sizes\"].uiBorder * 2;\n        this.selected = false;\n        this.addChild(this._background, this._text);\n    }\n    get selected() {\n        return this._selected;\n    }\n    set selected(selected) {\n        this._selected = selected;\n        this._background\n            .clear()\n            .beginFill(selected ? ui[\"Colors\"].uiSelected : ui[\"Colors\"].uiNotSelected)\n            .drawRect(0, 0, this._width, this._height)\n            .endFill();\n    }\n}\n\n// CONCATENATED MODULE: ./src/scene.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass scene_SceneController {\n    constructor(resources, app, stage) {\n        this.mainScene = null;\n        this.modalScene = null;\n        this.persistent = new SessionPersistentState();\n        this.rng = new RNG();\n        this.joystick = new Joystick();\n        this.resources = resources;\n        this.app = app;\n        this.stage = stage;\n        this.dialogs = new DialogManager(this);\n        this.app.ticker.add(this.persistent.global.commit, this.persistent.global, external_PIXI_[\"UPDATE_PRIORITY\"].LOW);\n        this.app.ticker.add(this.persistent.session.commit, this.persistent.session, external_PIXI_[\"UPDATE_PRIORITY\"].LOW);\n    }\n    set scene(scene) {\n        var _a;\n        (_a = this.mainScene) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.joystick.reset();\n        this.mainScene = scene;\n        this.mainScene.init();\n    }\n    keyBind() {\n        this.scene = new keybind_scene_KeyBindScene(this);\n    }\n    selectHero() {\n        this.scene = new select_hero_scene_SelectHeroScene(this);\n    }\n    updateHero(hero, level) {\n        this.scene = new update_hero_scene_UpdateHeroScene(this, {\n            level: level,\n            hero: hero\n        });\n    }\n    dead() {\n        this.scene = new dead_scene_YouDeadScene(this);\n    }\n    generateDungeon(options) {\n        this.scene = new generate_scene_GenerateDungeonScene(this, options);\n    }\n    dungeon(hero, dungeon) {\n        this.scene = new dungeon_scene_DungeonScene(this, hero, dungeon);\n    }\n    modal(scene) {\n        var _a;\n        external_PIXI_[\"sound\"].play('text');\n        (_a = this.mainScene) === null || _a === void 0 ? void 0 : _a.pause();\n        this.joystick.reset();\n        this.modalScene = scene;\n        this.modalScene.init();\n    }\n    closeModal() {\n        var _a, _b;\n        (_a = this.modalScene) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.joystick.reset();\n        (_b = this.mainScene) === null || _b === void 0 ? void 0 : _b.resume();\n    }\n    showInventory(hero, npc) {\n        this.modal(new inventory_modal[\"InventoryModalScene\"](this, hero, npc || null));\n    }\n    showDialog(hero, npc) {\n        const dialog = this.dialogs.dialog(hero, npc);\n        this.modal(new dialog_DialogModalScene(this, dialog));\n    }\n    showBonfire(hero) {\n        this.modal(new dungeon_bonfire_DungeonBonfireDialogModal(this, hero));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NlbmUudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcm5nLnRzPzgyNDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2lucHV0LnRzP2M1NDIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlYWQuc2NlbmUudHM/ZGQ4YiIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhZG93LmNhc3Rlci50cz9iNTBmIiwid2VicGFjazovLy8uL3NyYy9kdW5nZW9uLmxpZ2h0LnRzPzE1ZTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2R1bmdlb24ubWFwLnRzPzNjMjMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhdGhmaW5kaW5nLnRzP2ZjMGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJhY3Rlci50cz9iODM3Iiwid2VicGFjazovLy8uL3NyYy9iYXIudmlldy50cz80NTI0Iiwid2VicGFjazovLy8uL3NyYy9tb25zdGVyLnRzP2JmMmIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlcm8udHM/MWMxNSIsIndlYnBhY2s6Ly8vLi9zcmMvdGlueS5tb25zdGVyLnRzPzY4MjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Jvc3MubW9uc3Rlci50cz80ZjQyIiwid2VicGFjazovLy8uL3NyYy9ucGMudHM/NDVjYSIsIndlYnBhY2s6Ly8vLi9zcmMvZHVuZ2Vvbi5ib25maXJlLnRzPzg4YjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2R1bmdlb24uZ2VuZXJhdG9yLnRzP2VlYWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmN1cmVuY3kudHM/OTMwNiIsIndlYnBhY2s6Ly8vLi9zcmMvd2ZjL21vZGVsLnRzP2NlZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dlb21ldHJ5LnRzPzgzN2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL3R1bm5lbGluZy50cz81MmQ0Iiwid2VicGFjazovLy8uL3NyYy9pbmRleGVyLnRzP2M4OTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3R1bm5lbGVyL21vZGVsLnRzPzdkY2UiLCJ3ZWJwYWNrOi8vLy4vc3JjL3R1bm5lbGVyL2NyYXdsZXIudHM/OWU5NiIsIndlYnBhY2s6Ly8vLi9zcmMvdHVubmVsZXIvd2FsbC5jcmF3bGVyLnRzP2E4NDUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3R1bm5lbGVyL3R1bm5lbC5jcmF3bGVyLnRzPzcwMzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL3R1bm5lbGVyL3Jvb20uY3Jhd2xlci50cz8xM2RjIiwid2VicGFjazovLy8uL3NyYy90dW5uZWxlci9kdW5nZW9uLmNyYXdsZXIudHM/MDQxOSIsIndlYnBhY2s6Ly8vLi9zcmMvd2ZjL2V2ZW4uc2ltcGxlLnRpbGVkLnRzP2ZhMGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3dmYy9kdW5nZW9uLmdlbmVyYXRvci50cz8yM2RkIiwid2VicGFjazovLy8uL3NyYy9nZW5lcmF0ZS5zY2VuZS50cz80MTI5Iiwid2VicGFjazovLy8uL3NyYy9kdW5nZW9uLnNjZW5lLnRzPzU3YzIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2tleWJpbmQuc2NlbmUudHM/YTczMCIsIndlYnBhY2s6Ly8vLi9zcmMvc2VsZWN0Lmhlcm8uc2NlbmUudHM/Y2UyYiIsIndlYnBhY2s6Ly8vLi9zcmMvdXBkYXRlLmhlcm8uc2NlbmUudHM/NzhiZiIsIndlYnBhY2s6Ly8vLi9zcmMvcGVyc2lzdGVudC5zdGF0ZS50cz81OWQ4Iiwid2VicGFjazovLy8uL3NyYy9leHByZXNzaW9uLnRzPzQ1MzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RlbXBsYXRlLnRzPzJiNTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RpYWxvZy50cz8yNDQ2Iiwid2VicGFjazovLy8uL3NyYy9zY2VuZS50cz9mNzg1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG0gPSAweDgwMDAwMDAwO1xuY29uc3QgYSA9IDExMDM1MTUyNDU7XG5jb25zdCBjID0gMTIzNDU7XG5leHBvcnQgY2xhc3MgUk5HIHtcbiAgICBjb25zdHJ1Y3RvcihzZWVkID0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc2VlZCA/IHNlZWQgOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobSAtIDEpKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZWVkXCIsIHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBnZXQgYm9vbGVhbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEludCgpICUgMSAhPSAwO1xuICAgIH1cbiAgICBnZXQgaW50KCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gKGEgKiB0aGlzLnN0YXRlICsgYykgJSBtO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgICB9XG4gICAgZ2V0IGZsb2F0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQgLyAobSAtIDEpO1xuICAgIH1cbiAgICBuZXh0SW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQ7XG4gICAgfVxuICAgIG5leHRGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvYXQ7XG4gICAgfVxuICAgIG5leHRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlU2l6ZSA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBjb25zdCByYW5kb21VbmRlcjEgPSB0aGlzLm5leHRJbnQoKSAvIG07XG4gICAgICAgIHJldHVybiBzdGFydCArIE1hdGguZmxvb3IocmFuZG9tVW5kZXIxICogcmFuZ2VTaXplKTtcbiAgICB9XG4gICAgY2hvaWNlKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnJheVt0aGlzLm5leHRSYW5nZSgwLCBhcnJheS5sZW5ndGgpXTtcbiAgICB9XG4gICAgbmV4dE5vcm1hbChtaW4sIG1heCwgc2tldykge1xuICAgICAgICBsZXQgdSA9IDAsIHYgPSAwO1xuICAgICAgICB3aGlsZSAodSA9PT0gMClcbiAgICAgICAgICAgIHUgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB3aGlsZSAodiA9PT0gMClcbiAgICAgICAgICAgIHYgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICBsZXQgbnVtID0gTWF0aC5zcXJ0KC0yLjAgKiBNYXRoLmxvZyh1KSkgKiBNYXRoLmNvcygyLjAgKiBNYXRoLlBJICogdik7XG4gICAgICAgIG51bSA9IG51bSAvIDEwLjAgKyAwLjU7XG4gICAgICAgIGlmIChudW0gPiAxIHx8IG51bSA8IDApXG4gICAgICAgICAgICBudW0gPSB0aGlzLm5leHROb3JtYWwobWluLCBtYXgsIHNrZXcpO1xuICAgICAgICBudW0gPSBNYXRoLnBvdyhudW0sIHNrZXcpO1xuICAgICAgICBudW0gKj0gbWF4IC0gbWluO1xuICAgICAgICBudW0gKz0gbWluO1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbn1cbiIsInZhciBLZXlCaW5kU3RhdGU7XG4oZnVuY3Rpb24gKEtleUJpbmRTdGF0ZSkge1xuICAgIEtleUJpbmRTdGF0ZVtLZXlCaW5kU3RhdGVbXCJBd2FpdFwiXSA9IDFdID0gXCJBd2FpdFwiO1xuICAgIEtleUJpbmRTdGF0ZVtLZXlCaW5kU3RhdGVbXCJQcmVzc2VkXCJdID0gMl0gPSBcIlByZXNzZWRcIjtcbn0pKEtleUJpbmRTdGF0ZSB8fCAoS2V5QmluZFN0YXRlID0ge30pKTtcbmV4cG9ydCBjbGFzcyBLZXlCaW5kIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBLZXlCaW5kU3RhdGUuQXdhaXQ7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9jZXNzZWQgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgdHJpZ2dlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcmVkO1xuICAgIH1cbiAgICBvbmNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Byb2Nlc3NlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChlLmNvZGUgPT09IHRoaXMuY29kZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IEtleUJpbmRTdGF0ZS5Bd2FpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEtleUJpbmRTdGF0ZS5QcmVzc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGtleXVwKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gdGhpcy5jb2RlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gS2V5QmluZFN0YXRlLlByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gS2V5QmluZFN0YXRlLkF3YWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSm95c3RpY2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1vdmVVcCA9IG5ldyBLZXlCaW5kKCdLZXlXJyk7XG4gICAgICAgIHRoaXMubW92ZUxlZnQgPSBuZXcgS2V5QmluZCgnS2V5QScpO1xuICAgICAgICB0aGlzLm1vdmVEb3duID0gbmV3IEtleUJpbmQoJ0tleVMnKTtcbiAgICAgICAgdGhpcy5tb3ZlUmlnaHQgPSBuZXcgS2V5QmluZCgnS2V5RCcpO1xuICAgICAgICB0aGlzLmhpdCA9IG5ldyBLZXlCaW5kKCdLZXlGJyk7XG4gICAgICAgIHRoaXMuZHJvcCA9IG5ldyBLZXlCaW5kKCdLZXlRJyk7XG4gICAgICAgIHRoaXMuaW52ZW50b3J5ID0gbmV3IEtleUJpbmQoJ0tleUknKTtcbiAgICAgICAgdGhpcy5kaWdpdDEgPSBuZXcgS2V5QmluZCgnRGlnaXQxJyk7XG4gICAgICAgIHRoaXMuZGlnaXQyID0gbmV3IEtleUJpbmQoJ0RpZ2l0MicpO1xuICAgICAgICB0aGlzLmRpZ2l0MyA9IG5ldyBLZXlCaW5kKCdEaWdpdDMnKTtcbiAgICAgICAgdGhpcy5kaWdpdDQgPSBuZXcgS2V5QmluZCgnRGlnaXQ0Jyk7XG4gICAgICAgIHRoaXMuZGlnaXQ1ID0gbmV3IEtleUJpbmQoJ0RpZ2l0NScpO1xuICAgICAgICB0aGlzLmRpZ2l0NiA9IG5ldyBLZXlCaW5kKCdEaWdpdDYnKTtcbiAgICAgICAgdGhpcy5kaWdpdDcgPSBuZXcgS2V5QmluZCgnRGlnaXQ3Jyk7XG4gICAgICAgIHRoaXMuZGlnaXQ4ID0gbmV3IEtleUJpbmQoJ0RpZ2l0OCcpO1xuICAgICAgICB0aGlzLmRpZ2l0OSA9IG5ldyBLZXlCaW5kKCdEaWdpdDknKTtcbiAgICAgICAgdGhpcy5kaWdpdDAgPSBuZXcgS2V5QmluZCgnRGlnaXQwJyk7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIEtleUJpbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3ZhbHVlLmNvZGVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMua2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmtleXVwLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBkaWdpdChudW0pIHtcbiAgICAgICAgc3dpdGNoIChudW0pIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaWdpdDE7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlnaXQyO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpZ2l0MztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaWdpdDQ7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlnaXQ1O1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpZ2l0NjtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaWdpdDc7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlnaXQ4O1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpZ2l0OTtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaWdpdDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZm9yIChjb25zdCBjb2RlIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuYmluZGluZ3MpKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmJpbmRpbmdzW2NvZGVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmJpbmRpbmdzW2UuY29kZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5rZXlkb3duKGUpO1xuICAgIH1cbiAgICBrZXl1cChlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5iaW5kaW5nc1tlLmNvZGVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eua2V5dXAoZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgUElYSSBmcm9tICdwaXhpLmpzJztcbmV4cG9ydCBjbGFzcyBZb3VEZWFkU2NlbmUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUaXRsZSgpO1xuICAgICAgICB0aGlzLnJlbmRlckhlbHAoKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFwcC50aWNrZXIuYWRkKHRoaXMuaGFuZGxlSW5wdXQsIHRoaXMpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5oYW5kbGVJbnB1dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5yZW1vdmVDaGlsZHJlbigpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgIH1cbiAgICByZW5kZXJUaXRsZSgpIHtcbiAgICAgICAgbGV0IHRpdGxlID0gbmV3IFBJWEkuQml0bWFwVGV4dChcIlJPR1VFTElLRSBEVU5HRU9OXCIsIHsgZm9udDogeyBuYW1lOiAnYWxhZ2FyZCcsIHNpemU6IDY0IH0gfSk7XG4gICAgICAgIHRpdGxlLmFuY2hvciA9IG5ldyBQSVhJLlBvaW50KDAuNSwgMCk7XG4gICAgICAgIHRpdGxlLnBvc2l0aW9uLnNldCh0aGlzLmNvbnRyb2xsZXIuYXBwLnNjcmVlbi53aWR0aCA+PiAxLCA2NCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZCh0aXRsZSk7XG4gICAgICAgIGxldCB5b3VEZWFkID0gbmV3IFBJWEkuQml0bWFwVGV4dChcIllPVSBERUFEXCIsIHsgZm9udDogeyBuYW1lOiBcImFsYWdhcmRcIiwgc2l6ZTogMTI4IH0sIHRpbnQ6IDB4RkYwMDAwIH0pO1xuICAgICAgICB5b3VEZWFkLmFuY2hvciA9IDAuNTtcbiAgICAgICAgeW91RGVhZC5wb3NpdGlvbi5zZXQodGhpcy5jb250cm9sbGVyLmFwcC5zY3JlZW4ud2lkdGggPj4gMSwgMjU2KTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnN0YWdlLmFkZENoaWxkKHlvdURlYWQpO1xuICAgIH1cbiAgICByZW5kZXJIZWxwKCkge1xuICAgICAgICBjb25zdCBsaW5lID0gbmV3IFBJWEkuQml0bWFwVGV4dChcIlBSRVNTIEYgVE8gUkVTVEFSVFwiLCB7IGZvbnQ6IHsgbmFtZTogXCJhbGFnYXJkXCIsIHNpemU6IDMyIH0gfSk7XG4gICAgICAgIGxpbmUuYW5jaG9yID0gMC41O1xuICAgICAgICBsaW5lLnBvc2l0aW9uLnNldCh0aGlzLmNvbnRyb2xsZXIuYXBwLnNjcmVlbi53aWR0aCA+PiAxLCB0aGlzLmNvbnRyb2xsZXIuYXBwLnNjcmVlbi5oZWlnaHQgLSA2NCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZChsaW5lKTtcbiAgICB9XG4gICAgaGFuZGxlSW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZXIuam95c3RpY2suaGl0Lm9uY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLnNlbGVjdEhlcm8oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSAncGl4aS5qcyc7XG5jb25zdCBUSUxFX1NJWkUgPSAxNjtcbmV4cG9ydCBjbGFzcyBFbmRQb2ludCB7XG4gICAgY29uc3RydWN0b3IocG9pbnQsIHNlZ21lbnQpIHtcbiAgICAgICAgdGhpcy5iZWdpbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFuZ2xlID0gMC4wO1xuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxufVxuZXhwb3J0IHZhciBTZWdtZW50VHlwZTtcbihmdW5jdGlvbiAoU2VnbWVudFR5cGUpIHtcbiAgICBTZWdtZW50VHlwZVtTZWdtZW50VHlwZVtcIk5PUk1BTFwiXSA9IDBdID0gXCJOT1JNQUxcIjtcbiAgICBTZWdtZW50VHlwZVtTZWdtZW50VHlwZVtcIlRPUFwiXSA9IDFdID0gXCJUT1BcIjtcbn0pKFNlZ21lbnRUeXBlIHx8IChTZWdtZW50VHlwZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgU2VnbWVudCB7XG4gICAgY29uc3RydWN0b3IocDEsIHAyLCB0eXBlKSB7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLnAxID0gbmV3IEVuZFBvaW50KHAxLCB0aGlzKTtcbiAgICAgICAgdGhpcy5wMiA9IG5ldyBFbmRQb2ludChwMiwgdGhpcyk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBwMSA9IHRoaXMucDEucG9pbnQ7XG4gICAgICAgIGNvbnN0IHAyID0gdGhpcy5wMi5wb2ludDtcbiAgICAgICAgcmV0dXJuIGBbJHtwMS54fToke3AxLnl9IC0gJHtwMi54fToke3AyLnl9XWA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNoYWRvd0Nhc3RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbmRwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5saWdodCA9IG5ldyBQSVhJLlBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLm1heERpc3RhbmNlID0gNTAwO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgICAgIHRoaXMuZW5kcG9pbnRzID0gW107XG4gICAgICAgIHRoaXMubGlnaHQgPSBuZXcgUElYSS5Qb2ludCgwLjAsIDAuMCk7XG4gICAgfVxuICAgIGFkZFNlZ21lbnQoeDEsIHkxLCB4MiwgeTIsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgcDEgPSBuZXcgUElYSS5Qb2ludCh4MSwgeTEpO1xuICAgICAgICBjb25zdCBwMiA9IG5ldyBQSVhJLlBvaW50KHgyLCB5Mik7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBuZXcgU2VnbWVudChwMSwgcDIsIHR5cGUpO1xuICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRzLnB1c2goc2VnbWVudC5wMSk7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRzLnB1c2goc2VnbWVudC5wMik7XG4gICAgfVxuICAgIHN0YXRpYyBkZWR1cGxpY2F0ZWQocXVldWUpIHtcbiAgICAgICAgY29uc3QgZGVkdXBsaWNhdGVkID0gW107XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBkdXBsaWNhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBxdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICBsZXQgc2FtZVR5cGUgPSBzZWdtZW50LnR5cGUgPT09IG5leHQudHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgZXF1YWwgPSBzZWdtZW50LnAxLnBvaW50LmVxdWFscyhuZXh0LnAxLnBvaW50KSAmJiBzZWdtZW50LnAyLnBvaW50LmVxdWFscyhuZXh0LnAyLnBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoc2FtZVR5cGUgJiYgZXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZHVwbGljYXRlcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZHVwbGljYXRlZC5wdXNoKHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWR1cGxpY2F0ZWQ7XG4gICAgfVxuICAgIHN0YXRpYyBjb25uZWN0ZWQoc2VnbWVudHMpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBsZXQgaGFzX3AxID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaGFzX3AyID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT0gaSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IHRlc3QgPSBzZWdtZW50c1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5wMS5wb2ludC5lcXVhbHModGVzdC5wMS5wb2ludCkgJiYgc2VnbWVudC5wMi5wb2ludC5lcXVhbHModGVzdC5wMi5wb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICghaGFzX3AxICYmIChzZWdtZW50LnAxLnBvaW50LmVxdWFscyh0ZXN0LnAxLnBvaW50KSB8fCBzZWdtZW50LnAxLnBvaW50LmVxdWFscyh0ZXN0LnAyLnBvaW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzX3AxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNfcDIgJiYgKHNlZ21lbnQucDIucG9pbnQuZXF1YWxzKHRlc3QucDEucG9pbnQpIHx8IHNlZ21lbnQucDIucG9pbnQuZXF1YWxzKHRlc3QucDIucG9pbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNfcDIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzX3AxICYmIGhhc19wMikge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWQucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0ZWQ7XG4gICAgfVxuICAgIHN0YXRpYyBmaWx0ZXJlZChzZWdtZW50cykge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFtdO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtcbiAgICAgICAgICAgIFswLCAxMiwgMCwgMTZdLFxuICAgICAgICAgICAgWzUsIDEyLCA1LCAxNl0sXG4gICAgICAgICAgICBbMCwgMTIsIDUsIDEyXSxcbiAgICAgICAgICAgIFswLCAwLCA1LCAwXSxcbiAgICAgICAgICAgIFsxMSwgMTIsIDExLCAxNl0sXG4gICAgICAgICAgICBbMTEsIDEyLCAxNiwgMTJdLFxuICAgICAgICAgICAgWzExLCAwLCAxNiwgMF0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGlzUGFydCA9IChzZWdtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzX3gxID0gc2VnbWVudC5wMS5wb2ludC54ICUgMTY7XG4gICAgICAgICAgICBjb25zdCBzX3kxID0gc2VnbWVudC5wMS5wb2ludC55ICUgMTY7XG4gICAgICAgICAgICBjb25zdCBzX3gyID0gc2VnbWVudC5wMi5wb2ludC54IC0gc2VnbWVudC5wMS5wb2ludC54ICsgc194MTtcbiAgICAgICAgICAgIGNvbnN0IHNfeTIgPSBzZWdtZW50LnAyLnBvaW50LnkgLSBzZWdtZW50LnAxLnBvaW50LnkgKyBzX3kxO1xuICAgICAgICAgICAgZm9yIChsZXQgW3gxLCB5MSwgeDIsIHkyXSBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgIGlmICh4MSA9PT0gc194MSAmJiB5MSA9PT0gc195MSAmJiB4MiA9PT0gc194MiAmJiB5MiA9PT0gc195Mikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICAgICAgaWYgKGlzUGFydChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gW3NlZ21lbnRdO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW3NlZ21lbnQucDEucG9pbnQsIHNlZ21lbnQucDIucG9pbnRdO1xuICAgICAgICAgICAgY29uc3QgY291bnRzID0gWzEsIDFdO1xuICAgICAgICAgICAgY29uc3Qgam9pbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjsgdCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoam9pbnMuaW5kZXhPZihpKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAxID0gbmV4dC5wMS5wb2ludDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcDIgPSBuZXh0LnAyLnBvaW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzX3AxID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNfcDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwID0gcG9pbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuZXF1YWxzKHAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc19wMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRzW2pdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwLmVxdWFscyhwMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNfcDIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50c1tqXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNfcDEgfHwgaGFzX3AyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2lucy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNfcDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc19wMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudHMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudHMubGVuZ3RoID09PSA0ICYmIGNvdW50cy5ldmVyeShjID0+IGMgPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbV95ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHJlY3RbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnAxLnBvaW50LnkgPT09IHMucDIucG9pbnQueSAmJiBzLnAxLnBvaW50LnkgPiBib3R0b21feSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbV95ID0gcy5wMS5wb2ludC55O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgb2Ygam9pbnMucmV2ZXJzZSgpKVxuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmVjdC5zcGxpY2UoYm90dG9tLCAxKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKC4uLnJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZShxdWV1ZSkge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICBsZXQgcGFpciA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBxdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QudHlwZSA9PT0gbmV4dC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdC5wMi5wb2ludC5lcXVhbHMobmV4dC5wMS5wb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXIgPSBbZmlyc3QsIG5leHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dC5wMi5wb2ludC5lcXVhbHMoZmlyc3QucDEucG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyID0gW25leHQsIGZpcnN0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhaXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYSwgYl0gPSBwYWlyO1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobmV3IFNlZ21lbnQoYS5wMS5wb2ludCwgYi5wMi5wb2ludCwgYS50eXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChmaXJzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgb3B0aW1pemUoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBvcHRpbWl6ZTogc2VnbWVudHM9JHt0aGlzLnNlZ21lbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgY29uc3QgZGVkdXBsaWNhdGVkID0gU2hhZG93Q2FzdGVyLmRlZHVwbGljYXRlZChbLi4udGhpcy5zZWdtZW50c10pO1xuICAgICAgICBjb25zb2xlLmxvZyhgb3B0aW1pemU6IGRlZHVwbGljYXRlZD0ke2RlZHVwbGljYXRlZC5sZW5ndGh9YCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RlZCA9IFNoYWRvd0Nhc3Rlci5jb25uZWN0ZWQoZGVkdXBsaWNhdGVkKTtcbiAgICAgICAgY29uc29sZS5sb2coYG9wdGltaXplOiBjb25uZWN0ZWQ9JHtjb25uZWN0ZWQubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFNoYWRvd0Nhc3Rlci5maWx0ZXJlZChjb25uZWN0ZWQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgb3B0aW1pemU6IGZpbHRlcmVkPSR7ZmlsdGVyZWQubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBjb25uZWN0ZWQyID0gU2hhZG93Q2FzdGVyLmNvbm5lY3RlZChmaWx0ZXJlZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBvcHRpbWl6ZTogY29ubmVjdGVkID0gJHtjb25uZWN0ZWQyLmxlbmd0aH1gKTtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gW1xuICAgICAgICAgICAgLi4uU2hhZG93Q2FzdGVyLm1lcmdlKGNvbm5lY3RlZDIuZmlsdGVyKHMgPT4gcy5wMS5wb2ludC54ID09PSBzLnAyLnBvaW50LngpKSxcbiAgICAgICAgICAgIC4uLlNoYWRvd0Nhc3Rlci5tZXJnZShjb25uZWN0ZWQyLmZpbHRlcihzID0+IHMucDEucG9pbnQueSA9PT0gcy5wMi5wb2ludC55KSksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnNvbGUubG9nKGBvcHRpbWl6ZTogbWVyZ2VkPSR7bWVyZ2VkLmxlbmd0aH1gKTtcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmVuZHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgbWVyZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50cy5wdXNoKHNlZ21lbnQucDEpO1xuICAgICAgICAgICAgdGhpcy5lbmRwb2ludHMucHVzaChzZWdtZW50LnAyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRMaWdodExvY2F0aW9uKHgsIHksIG1heERpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMubGlnaHQueCA9IHg7XG4gICAgICAgIHRoaXMubGlnaHQueSA9IHk7XG4gICAgICAgIHRoaXMubWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcbiAgICAgICAgdGhpcy5lbmRwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHRoaXMuc2VnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBkeCA9IDAuNSAqIChzZWdtZW50LnAxLnBvaW50LnggKyBzZWdtZW50LnAyLnBvaW50LngpIC0geDtcbiAgICAgICAgICAgIGxldCBkeSA9IDAuNSAqIChzZWdtZW50LnAxLnBvaW50LnkgKyBzZWdtZW50LnAyLnBvaW50LnkpIC0geTtcbiAgICAgICAgICAgIHNlZ21lbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuZGlzdGFuY2UgPCBtYXhEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnQucDEuYW5nbGUgPSBNYXRoLmF0YW4yKHNlZ21lbnQucDEucG9pbnQueSAtIHksIHNlZ21lbnQucDEucG9pbnQueCAtIHgpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnQucDIuYW5nbGUgPSBNYXRoLmF0YW4yKHNlZ21lbnQucDIucG9pbnQueSAtIHksIHNlZ21lbnQucDIucG9pbnQueCAtIHgpO1xuICAgICAgICAgICAgICAgIGxldCBkQW5nbGUgPSBzZWdtZW50LnAyLmFuZ2xlIC0gc2VnbWVudC5wMS5hbmdsZTtcbiAgICAgICAgICAgICAgICBpZiAoZEFuZ2xlIDw9IC1NYXRoLlBJKSB7XG4gICAgICAgICAgICAgICAgICAgIGRBbmdsZSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRBbmdsZSA+IE1hdGguUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgZEFuZ2xlIC09IDIgKiBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWdtZW50LnAxLmJlZ2luID0gKGRBbmdsZSA+IDAuMCk7XG4gICAgICAgICAgICAgICAgc2VnbWVudC5wMi5iZWdpbiA9ICFzZWdtZW50LnAxLmJlZ2luO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzLnB1c2goc2VnbWVudC5wMSwgc2VnbWVudC5wMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRwb2ludHMuc29ydChTaGFkb3dDYXN0ZXIuY29tcGFyZSk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuYW5nbGUgPiBiLmFuZ2xlKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhLmFuZ2xlIDwgYi5hbmdsZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKCFhLmJlZ2luICYmIGIuYmVnaW4pXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEuYmVnaW4gJiYgIWIuYmVnaW4pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzdGF0aWMgbGVmdE9mKHMsIHApIHtcbiAgICAgICAgY29uc3QgY3Jvc3MgPSAocy5wMi5wb2ludC54IC0gcy5wMS5wb2ludC54KSAqIChwLnkgLSBzLnAxLnBvaW50LnkpXG4gICAgICAgICAgICAtIChzLnAyLnBvaW50LnkgLSBzLnAxLnBvaW50LnkpICogKHAueCAtIHMucDEucG9pbnQueCk7XG4gICAgICAgIHJldHVybiBjcm9zcyA8IDA7XG4gICAgfVxuICAgIHN0YXRpYyBpbnRlcnBvbGF0ZShwLCBxLCBmKSB7XG4gICAgICAgIHJldHVybiBuZXcgUElYSS5Qb2ludChwLnggKiAoMSAtIGYpICsgcS54ICogZiwgcC55ICogKDEgLSBmKSArIHEueSAqIGYpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VnbWVudEluRnJvbnRPZihhLCBiLCByZWxhdGl2ZVRvKSB7XG4gICAgICAgIGNvbnN0IEExID0gU2hhZG93Q2FzdGVyLmxlZnRPZihhLCBTaGFkb3dDYXN0ZXIuaW50ZXJwb2xhdGUoYi5wMS5wb2ludCwgYi5wMi5wb2ludCwgMC4wMSkpO1xuICAgICAgICBjb25zdCBBMiA9IFNoYWRvd0Nhc3Rlci5sZWZ0T2YoYSwgU2hhZG93Q2FzdGVyLmludGVycG9sYXRlKGIucDIucG9pbnQsIGIucDEucG9pbnQsIDAuMDEpKTtcbiAgICAgICAgY29uc3QgQTMgPSBTaGFkb3dDYXN0ZXIubGVmdE9mKGEsIHJlbGF0aXZlVG8pO1xuICAgICAgICBjb25zdCBCMSA9IFNoYWRvd0Nhc3Rlci5sZWZ0T2YoYiwgU2hhZG93Q2FzdGVyLmludGVycG9sYXRlKGEucDEucG9pbnQsIGEucDIucG9pbnQsIDAuMDEpKTtcbiAgICAgICAgY29uc3QgQjIgPSBTaGFkb3dDYXN0ZXIubGVmdE9mKGIsIFNoYWRvd0Nhc3Rlci5pbnRlcnBvbGF0ZShhLnAyLnBvaW50LCBhLnAxLnBvaW50LCAwLjAxKSk7XG4gICAgICAgIGNvbnN0IEIzID0gU2hhZG93Q2FzdGVyLmxlZnRPZihiLCByZWxhdGl2ZVRvKTtcbiAgICAgICAgaWYgKEIxID09IEIyICYmIEIyICE9IEIzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChBMSA9PSBBMiAmJiBBMiA9PSBBMylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoQTEgPT0gQTIgJiYgQTIgIT0gQTMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChCMSA9PSBCMiAmJiBCMiA9PSBCMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2VlcCgpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGNvbnN0IG9wZW4gPSBbXTtcbiAgICAgICAgbGV0IGJlZ2luQW5nbGUgPSAwLjA7XG4gICAgICAgIGZvciAobGV0IHBhc3MgPSAwOyBwYXNzIDw9IDI7IHBhc3MrKykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuZW5kcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRfb2xkID0gb3Blbi5sZW5ndGggPT09IDAgPyBudWxsIDogb3BlblswXTtcbiAgICAgICAgICAgICAgICBpZiAocC5iZWdpbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gb3BlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCAmJiBTaGFkb3dDYXN0ZXIuc2VnbWVudEluRnJvbnRPZihwLnNlZ21lbnQsIG5vZGUsIHRoaXMubGlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gb3BlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuLnB1c2gocC5zZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4uc3BsaWNlKGksIDAsIHAuc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3Blbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5baV0gPT09IHAuc2VnbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudF9uZXcgPSBvcGVuLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBvcGVuWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X29sZCAhPT0gY3VycmVudF9uZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUcmlhbmdsZShiZWdpbkFuZ2xlLCBwLmFuZ2xlLCBjdXJyZW50X29sZCwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiZWdpbkFuZ2xlID0gcC5hbmdsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgc3RhdGljIGxpbmVJbnRlcnNlY3Rpb24ocDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgY29uc3QgcyA9ICgocDQueCAtIHAzLngpICogKHAxLnkgLSBwMy55KSAtIChwNC55IC0gcDMueSkgKiAocDEueCAtIHAzLngpKVxuICAgICAgICAgICAgLyAoKHA0LnkgLSBwMy55KSAqIChwMi54IC0gcDEueCkgLSAocDQueCAtIHAzLngpICogKHAyLnkgLSBwMS55KSk7XG4gICAgICAgIHJldHVybiBuZXcgUElYSS5Qb2ludChwMS54ICsgcyAqIChwMi54IC0gcDEueCksIHAxLnkgKyBzICogKHAyLnkgLSBwMS55KSk7XG4gICAgfVxuICAgIGFkZFRyaWFuZ2xlKGFuZ2xlMSwgYW5nbGUyLCBzZWdtZW50LCBvdXRwdXQpIHtcbiAgICAgICAgY29uc3QgYW5nbGUxY29zID0gTWF0aC5jb3MoYW5nbGUxKTtcbiAgICAgICAgY29uc3QgYW5nbGUxc2luID0gTWF0aC5zaW4oYW5nbGUxKTtcbiAgICAgICAgY29uc3QgYW5nbGUyY29zID0gTWF0aC5jb3MoYW5nbGUyKTtcbiAgICAgICAgY29uc3QgYW5nbGUyc2luID0gTWF0aC5zaW4oYW5nbGUyKTtcbiAgICAgICAgbGV0IHAxID0gdGhpcy5saWdodDtcbiAgICAgICAgbGV0IHAyID0gbmV3IFBJWEkuUG9pbnQodGhpcy5saWdodC54ICsgYW5nbGUxY29zLCB0aGlzLmxpZ2h0LnkgKyBhbmdsZTFzaW4pO1xuICAgICAgICBsZXQgcDMgPSBuZXcgUElYSS5Qb2ludCgwLjAsIDAuMCk7XG4gICAgICAgIGxldCBwNCA9IG5ldyBQSVhJLlBvaW50KDAuMCwgMC4wKTtcbiAgICAgICAgaWYgKHNlZ21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcDMueCA9IHNlZ21lbnQucDEucG9pbnQueDtcbiAgICAgICAgICAgIHAzLnkgPSBzZWdtZW50LnAxLnBvaW50Lnk7XG4gICAgICAgICAgICBwNC54ID0gc2VnbWVudC5wMi5wb2ludC54O1xuICAgICAgICAgICAgcDQueSA9IHNlZ21lbnQucDIucG9pbnQueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAzLnggPSB0aGlzLmxpZ2h0LnggKyBhbmdsZTFjb3MgKiB0aGlzLm1heERpc3RhbmNlO1xuICAgICAgICAgICAgcDMueSA9IHRoaXMubGlnaHQueSArIGFuZ2xlMXNpbiAqIHRoaXMubWF4RGlzdGFuY2U7XG4gICAgICAgICAgICBwNC54ID0gdGhpcy5saWdodC54ICsgYW5nbGUyY29zICogdGhpcy5tYXhEaXN0YW5jZTtcbiAgICAgICAgICAgIHA0LnkgPSB0aGlzLmxpZ2h0LnkgKyBhbmdsZTJzaW4gKiB0aGlzLm1heERpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwQmVnaW4gPSBTaGFkb3dDYXN0ZXIubGluZUludGVyc2VjdGlvbihwMywgcDQsIHAxLCBwMik7XG4gICAgICAgIHBCZWdpbi54ID0gTWF0aC5yb3VuZChwQmVnaW4ueCk7XG4gICAgICAgIHBCZWdpbi55ID0gTWF0aC5yb3VuZChwQmVnaW4ueSk7XG4gICAgICAgIHAyLnggPSB0aGlzLmxpZ2h0LnggKyBhbmdsZTJjb3M7XG4gICAgICAgIHAyLnkgPSB0aGlzLmxpZ2h0LnkgKyBhbmdsZTJzaW47XG4gICAgICAgIGxldCBwRW5kID0gU2hhZG93Q2FzdGVyLmxpbmVJbnRlcnNlY3Rpb24ocDMsIHA0LCBwMSwgcDIpO1xuICAgICAgICBwRW5kLnggPSBNYXRoLnJvdW5kKHBFbmQueCk7XG4gICAgICAgIHBFbmQueSA9IE1hdGgucm91bmQocEVuZC55KTtcbiAgICAgICAgaWYgKHNlZ21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChzZWdtZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNlZ21lbnRUeXBlLlRPUDpcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocEJlZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gobmV3IFBJWEkuUG9pbnQocEJlZ2luLngsIHBCZWdpbi55IC0gVElMRV9TSVpFKSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG5ldyBQSVhJLlBvaW50KHBFbmQueCwgcEVuZC55IC0gVElMRV9TSVpFKSk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHBFbmQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFNlZ21lbnRUeXBlLk5PUk1BTDpcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocEJlZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocEVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2gocEJlZ2luKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHBFbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlYnVnKCkge1xuICAgICAgICBjb25zdCBzY2FsZSA9IDE7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gKDgwICogMTYpICogc2NhbGU7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9ICg4MCAqIDE2KSAqIHNjYWxlO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHNjYWxlO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogc2NhbGU7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBmb3IgKGxldCBzZWdtZW50IG9mIHRoaXMuc2VnbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc2VnbWVudC5wMS5wb2ludDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHNlZ21lbnQucDIucG9pbnQ7XG4gICAgICAgICAgICBzZWdtZW50cy5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICAgICAgICBzZWdtZW50cy5saW5lVG8oZW5kLngsIGVuZC55KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMCwwLDAuNSknO1xuICAgICAgICBjdHguc3Ryb2tlKHNlZ21lbnRzKTtcbiAgICAgICAgY29uc29sZS5sb2coJyVjICcsIGBcbiAgICAgIGZvbnQtc2l6ZTogMXB4O1xuICAgICAgcGFkZGluZzogJHtjYW52YXMuaGVpZ2h0IC8gMn1weCAke2NhbnZhcy53aWR0aCAvIDJ9cHg7XG4gICAgICBiYWNrZ3JvdW5kOiBuby1yZXBlYXQgdXJsKCR7Y2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyl9KTtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogJHtjYW52YXMud2lkdGh9cHggJHtjYW52YXMuaGVpZ2h0fXB4O1xuICAgIGApO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFNlZ21lbnRUeXBlLCBTaGFkb3dDYXN0ZXIgfSBmcm9tIFwiLi9zaGFkb3cuY2FzdGVyXCI7XG5pbXBvcnQgKiBhcyBQSVhJIGZyb20gJ3BpeGkuanMnO1xuY29uc3QgVElMRV9TSVpFID0gMTY7XG5leHBvcnQgY2xhc3MgRHVuZ2VvbkxpZ2h0IHtcbiAgICBjb25zdHJ1Y3RvcihkdW5nZW9uKSB7XG4gICAgICAgIHRoaXMubGlnaHRzID0gW107XG4gICAgICAgIHRoaXMud2FsbF90b3AgPSB7XG4gICAgICAgICAgICBkZWZhdWx0OiBbXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDEyLCB4MjogMTYsIHkyOiAxMiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDEyLCB4MjogMCwgeTI6IDE2LCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICB7IHgxOiAxNiwgeTE6IDEyLCB4MjogMTYsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdG9wOiBbXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDAsIHgyOiAxNiwgeTI6IDAsIHR5cGU6IFNlZ21lbnRUeXBlLlRPUCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxlZnQ6IFtcbiAgICAgICAgICAgICAgICB7IHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAxMiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmlnaHQ6IFtcbiAgICAgICAgICAgICAgICB7IHgxOiAxNiwgeTE6IDAsIHgyOiAxNiwgeTI6IDEyLCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBib3R0b206IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FsbF9zaWRlX2xlZnQgPSB7XG4gICAgICAgICAgICBkZWZhdWx0OiBbXG4gICAgICAgICAgICAgICAgeyB4MTogMTEsIHkxOiAwLCB4MjogMTEsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgeyB4MTogMTEsIHkxOiAwLCB4MjogMTYsIHkyOiAwLCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICB7IHgxOiAxMSwgeTE6IDE2LCB4MjogMTYsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuVE9QIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdG9wOiBbXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDAsIHgyOiAxMSwgeTI6IDAsIHR5cGU6IFNlZ21lbnRUeXBlLlRPUCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxlZnQ6IFtcbiAgICAgICAgICAgICAgICB7IHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmlnaHQ6IFtdLFxuICAgICAgICAgICAgYm90dG9tOiBbXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDE2LCB4MjogMTEsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndhbGxfc2lkZV9yaWdodCA9IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IFtcbiAgICAgICAgICAgICAgICB7IHgxOiA1LCB5MTogMCwgeDI6IDUsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDAsIHgyOiA1LCB5MjogMCwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDE2LCB4MjogNSwgeTI6IDE2LCB0eXBlOiBTZWdtZW50VHlwZS5UT1AgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0b3A6IFtcbiAgICAgICAgICAgICAgICB7IHgxOiA1LCB5MTogMCwgeDI6IDE2LCB5MjogMCwgdHlwZTogU2VnbWVudFR5cGUuVE9QIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbGVmdDogW10sXG4gICAgICAgICAgICByaWdodDogW1xuICAgICAgICAgICAgICAgIHsgeDE6IDE2LCB5MTogMCwgeDI6IDE2LCB5MjogMTYsIHR5cGU6IFNlZ21lbnRUeXBlLk5PUk1BTCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGJvdHRvbTogW1xuICAgICAgICAgICAgICAgIHsgeDE6IDUsIHkxOiAxNiwgeDI6IDE2LCB5MjogMTYsIHR5cGU6IFNlZ21lbnRUeXBlLk5PUk1BTCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53YWxsX2Nvcm5lcl9sZWZ0ID0ge1xuICAgICAgICAgICAgZGVmYXVsdDogW1xuICAgICAgICAgICAgICAgIHsgeDE6IDUsIHkxOiAwLCB4MjogNSwgeTI6IDEyLCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICB7IHgxOiA1LCB5MTogMTIsIHgyOiAxNiwgeTI6IDEyLCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICB7IHgxOiAxNiwgeTE6IDEyLCB4MjogMTYsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0b3A6IFtcbiAgICAgICAgICAgICAgICB7IHgxOiA1LCB5MTogMCwgeDI6IDE2LCB5MjogMCwgdHlwZTogU2VnbWVudFR5cGUuVE9QIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbGVmdDogW10sXG4gICAgICAgICAgICByaWdodDogW1xuICAgICAgICAgICAgICAgIHsgeDE6IDE2LCB5MTogMCwgeDI6IDE2LCB5MjogMTIsIHR5cGU6IFNlZ21lbnRUeXBlLk5PUk1BTCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGJvdHRvbTogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FsbF9jb3JuZXJfcmlnaHQgPSB7XG4gICAgICAgICAgICBkZWZhdWx0OiBbXG4gICAgICAgICAgICAgICAgeyB4MTogMTEsIHkxOiAwLCB4MjogMTEsIHkyOiAxMiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDEyLCB4MjogMTEsIHkyOiAxMiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDEyLCB4MjogMCwgeTI6IDE2LCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHRvcDogW1xuICAgICAgICAgICAgICAgIHsgeDE6IDAsIHkxOiAwLCB4MjogMTEsIHkyOiAwLCB0eXBlOiBTZWdtZW50VHlwZS5UT1AgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsZWZ0OiBbXG4gICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDAsIHgyOiAwLCB5MjogMTIsIHR5cGU6IFNlZ21lbnRUeXBlLk5PUk1BTCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJpZ2h0OiBbXSxcbiAgICAgICAgICAgIGJvdHRvbTogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2FsbF9kZWZhdWx0ID0ge1xuICAgICAgICAgICAgZGVmYXVsdDogW10sXG4gICAgICAgICAgICB0b3A6IFtcbiAgICAgICAgICAgICAgICB7IHgxOiAwLCB5MTogMCwgeDI6IDE2LCB5MjogMCwgdHlwZTogU2VnbWVudFR5cGUuVE9QIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbGVmdDogW1xuICAgICAgICAgICAgICAgIHsgeDE6IDAsIHkxOiAwLCB4MjogMCwgeTI6IDE2LCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByaWdodDogW1xuICAgICAgICAgICAgICAgIHsgeDE6IDE2LCB5MTogMCwgeDI6IDE2LCB5MjogMTYsIHR5cGU6IFNlZ21lbnRUeXBlLk5PUk1BTCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGJvdHRvbTogW1xuICAgICAgICAgICAgICAgIHsgeDE6IDAsIHkxOiAxNiwgeDI6IDE2LCB5MjogMTYsIHR5cGU6IFNlZ21lbnRUeXBlLk5PUk1BTCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICBcIndhbGxfdG9wX21pZC5wbmdcIjogdGhpcy53YWxsX3RvcCxcbiAgICAgICAgICAgIFwid2FsbF9zaWRlX2Zyb250X2xlZnQucG5nXCI6IHRoaXMud2FsbF9zaWRlX2xlZnQsXG4gICAgICAgICAgICBcIndhbGxfc2lkZV9mcm9udF9yaWdodC5wbmdcIjogdGhpcy53YWxsX3NpZGVfcmlnaHQsXG4gICAgICAgICAgICBcIndhbGxfc2lkZV9taWRfbGVmdC5wbmdcIjogdGhpcy53YWxsX3NpZGVfbGVmdCxcbiAgICAgICAgICAgIFwid2FsbF9zaWRlX21pZF9yaWdodC5wbmdcIjogdGhpcy53YWxsX3NpZGVfcmlnaHQsXG4gICAgICAgICAgICBcIndhbGxfc2lkZV90b3BfbGVmdC5wbmdcIjoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB4MTogMTEsIHkxOiAxMiwgeDI6IDE2LCB5MjogMTIsIHR5cGU6IFNlZ21lbnRUeXBlLk5PUk1BTCB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgxOiAxMSwgeTE6IDEyLCB4MjogMTEsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3A6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDAsIHgyOiAxNiwgeTI6IDAsIHR5cGU6IFNlZ21lbnRUeXBlLlRPUCB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbGVmdDogW1xuICAgICAgICAgICAgICAgICAgICB7IHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByaWdodDogW1xuICAgICAgICAgICAgICAgICAgICB7IHgxOiAxNiwgeTE6IDAsIHgyOiAxNiwgeTI6IDEyLCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogW1xuICAgICAgICAgICAgICAgICAgICB7IHgxOiAwLCB5MTogMTYsIHgyOiAxMSwgeTI6IDE2LCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwid2FsbF9zaWRlX3RvcF9yaWdodC5wbmdcIjoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDEyLCB4MjogNSwgeTI6IDEyLCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4MTogNSwgeTE6IDEyLCB4MjogNSwgeTI6IDE2LCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvcDogW1xuICAgICAgICAgICAgICAgICAgICB7IHgxOiAwLCB5MTogMCwgeDI6IDE2LCB5MjogMCwgdHlwZTogU2VnbWVudFR5cGUuVE9QIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDE6IDAsIHkxOiAxMiwgeDI6IDAsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByaWdodDogW1xuICAgICAgICAgICAgICAgICAgICB7IHgxOiAxNiwgeTE6IDAsIHgyOiAxNiwgeTI6IDE2LCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogW1xuICAgICAgICAgICAgICAgICAgICB7IHgxOiA1LCB5MTogMTYsIHgyOiAxNiwgeTI6IDE2LCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwid2FsbF9pbm5lcl9jb3JuZXJfdF90b3BfbGVmdC5wbmdcIjogdGhpcy53YWxsX3RvcCxcbiAgICAgICAgICAgIFwid2FsbF9pbm5lcl9jb3JuZXJfdF90b3BfcmlnaHQucG5nXCI6IHRoaXMud2FsbF90b3AsXG4gICAgICAgICAgICBcIndhbGxfaW5uZXJfY29ybmVyX2xfdG9wX2xlZnQucG5nXCI6IHRoaXMud2FsbF9jb3JuZXJfbGVmdCxcbiAgICAgICAgICAgIFwid2FsbF9pbm5lcl9jb3JuZXJfbF90b3BfcmlnaHQucG5nXCI6IHRoaXMud2FsbF9jb3JuZXJfcmlnaHQsXG4gICAgICAgICAgICBcIndhbGxfY29ybmVyX2JvdHRvbV9sZWZ0LnBuZ1wiOiB0aGlzLndhbGxfY29ybmVyX2xlZnQsXG4gICAgICAgICAgICBcIndhbGxfY29ybmVyX2JvdHRvbV9yaWdodC5wbmdcIjogdGhpcy53YWxsX2Nvcm5lcl9yaWdodCxcbiAgICAgICAgICAgIFwid2FsbF9jb3JuZXJfdG9wX2xlZnQucG5nXCI6IHRoaXMud2FsbF90b3AsXG4gICAgICAgICAgICBcIndhbGxfY29ybmVyX3RvcF9yaWdodC5wbmdcIjogdGhpcy53YWxsX3RvcCxcbiAgICAgICAgICAgIFwid2FsbF9mb3VudGFpbl90b3AucG5nXCI6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDE6IDAsIHkxOiAxMiwgeDI6IDAsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDE6IDAsIHkxOiAxMiwgeDI6IDIsIHkyOiAxMiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDE6IDIsIHkxOiA5LCB4MjogMiwgeTI6IDEyLCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4MTogMiwgeTE6IDksIHgyOiAxNCwgeTI6IDksIHR5cGU6IFNlZ21lbnRUeXBlLk5PUk1BTCB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgxOiAxNCwgeTE6IDksIHgyOiAxNCwgeTI6IDEyLCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4MTogMTQsIHkxOiAxMiwgeDI6IDE2LCB5MjogMTIsIHR5cGU6IFNlZ21lbnRUeXBlLk5PUk1BTCB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgxOiAxNiwgeTE6IDEyLCB4MjogMTYsIHkyOiAxNiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b3A6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB4MTogMCwgeTE6IDAsIHgyOiAxNiwgeTI6IDAsIHR5cGU6IFNlZ21lbnRUeXBlLlRPUCB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbGVmdDogW1xuICAgICAgICAgICAgICAgICAgICB7IHgxOiAwLCB5MTogMCwgeDI6IDAsIHkyOiAxMiwgdHlwZTogU2VnbWVudFR5cGUuTk9STUFMIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByaWdodDogW1xuICAgICAgICAgICAgICAgICAgICB7IHgxOiAxNiwgeTE6IDAsIHgyOiAxNiwgeTI6IDEyLCB0eXBlOiBTZWdtZW50VHlwZS5OT1JNQUwgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIndhbGxfb25lX3RvcC5wbmdcIjogdGhpcy53YWxsX3RvcCxcbiAgICAgICAgICAgIFwid2FsbF9vbmVfY29ybmVyX2xlZnQucG5nXCI6IHRoaXMud2FsbF9jb3JuZXJfbGVmdCxcbiAgICAgICAgICAgIFwid2FsbF9vbmVfY29ybmVyX3JpZ2h0LnBuZ1wiOiB0aGlzLndhbGxfY29ybmVyX3JpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmR1bmdlb24gPSBkdW5nZW9uO1xuICAgICAgICB0aGlzLmxheWVyID0gbmV3IFBJWEkuZGlzcGxheS5MYXllcigpO1xuICAgICAgICB0aGlzLmxheWVyLnVzZVJlbmRlclRleHR1cmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmxheWVyLm9uKCdkaXNwbGF5JywgKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnQuYmxlbmRNb2RlID0gUElYSS5CTEVORF9NT0RFUy5NVUxUSVBMWTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGF5ZXIuY2xlYXJDb2xvciA9IFswLCAwLCAwLCAxXTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBuZXcgUElYSS5Db250YWluZXIoKTtcbiAgICAgICAgdGhpcy5sYXllci5hZGRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuaGVyb0xpZ2h0VGV4dHVyZSA9IER1bmdlb25MaWdodC5ncmFkaWVudChcIndoaXRlXCIsIDE1MCk7XG4gICAgICAgIHRoaXMuZm91bnRhaW5SZWRUZXh0dXJlID0gRHVuZ2VvbkxpZ2h0LmdyYWRpZW50KFwicmdiKDIxMSw3OCw1NilcIiwgNTApO1xuICAgICAgICB0aGlzLmZvdW50YWluQmx1ZVRleHR1cmUgPSBEdW5nZW9uTGlnaHQuZ3JhZGllbnQoXCJyZ2IoODYsMTUyLDIwNClcIiwgNTApO1xuICAgICAgICB0aGlzLmJvbmZpcmVUZXh0dXJlID0gRHVuZ2VvbkxpZ2h0LmdyYWRpZW50KFwicmdiKDI1NSwyMzksMjA0KVwiLCAxMDApO1xuICAgICAgICB0aGlzLnNoYWRvd0Nhc3RlciA9IG5ldyBTaGFkb3dDYXN0ZXIoKTtcbiAgICAgICAgdGhpcy5kdW5nZW9uLnRpY2tlci5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmR1bmdlb24udGlja2VyLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMubGlnaHRzLmZvckVhY2gobCA9PiBsLmRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMuaGVyb0xpZ2h0VGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZm91bnRhaW5CbHVlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZm91bnRhaW5SZWRUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5ib25maXJlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5sYXllci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGxvYWRNYXAoKSB7XG4gICAgICAgIHRoaXMuc2hhZG93Q2FzdGVyLmluaXQoKTtcbiAgICAgICAgY29uc3QgZHVuZ2VvbiA9IHRoaXMuZHVuZ2VvbjtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBkdW5nZW9uLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGR1bmdlb24ud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBkdW5nZW9uLmNlbGwoeCwgeSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuaGFzRmxvb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjZWxsLmZsb29yTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2FsbF9mb3VudGFpbl9iYXNpbl9yZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlnaHQobmV3IFBJWEkuUG9pbnQoeCAqIFRJTEVfU0laRSwgeSAqIFRJTEVfU0laRSksIExpZ2h0VHlwZS5SRURfQkFTSU4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2FsbF9mb3VudGFpbl9iYXNpbl9ibHVlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZExpZ2h0KG5ldyBQSVhJLlBvaW50KHggKiBUSUxFX1NJWkUsIHkgKiBUSUxFX1NJWkUpLCBMaWdodFR5cGUuQkxVRV9CQVNJTik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc190b3AgPSB5ID4gMCAmJiBkdW5nZW9uLmNlbGwoeCwgeSAtIDEpLmhhc0Zsb29yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNfYm90dG9tID0geSArIDEgPCBkdW5nZW9uLmhlaWdodCAmJiBkdW5nZW9uLmNlbGwoeCwgeSArIDEpLmhhc0Zsb29yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNfbGVmdCA9IHggPiAwICYmIGR1bmdlb24uY2VsbCh4IC0gMSwgeSkuaGFzRmxvb3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc19yaWdodCA9IHggKyAxIDwgZHVuZ2Vvbi53aWR0aCAmJiBkdW5nZW9uLmNlbGwoeCArIDEsIHkpLmhhc0Zsb29yO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsV2FsbCA9IGNlbGwud2FsbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsV2FsbCAmJiB0aGlzLmNvbmZpZ1tjZWxsV2FsbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnW2NlbGxXYWxsXSB8fCB0aGlzLndhbGxfZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IHRoaXMud2FsbF9kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHgsIHksIGNvbmZpZy5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNfdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoeCwgeSwgY29uZmlnLnRvcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzX2JvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHgsIHksIGNvbmZpZy5ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc19sZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoeCwgeSwgY29uZmlnLmxlZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc19yaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHgsIHksIGNvbmZpZy5yaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhZG93Q2FzdGVyLm9wdGltaXplKCk7XG4gICAgfVxuICAgIGFkZExpZ2h0KHBvc2l0aW9uLCB0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBMaWdodFR5cGUuSEVSTzpcbiAgICAgICAgICAgICAgICB0aGlzLmxpZ2h0cy5wdXNoKG5ldyBMaWdodFNvdXJjZShwb3NpdGlvbiwgMzUwLCB0aGlzLmhlcm9MaWdodFRleHR1cmUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExpZ2h0VHlwZS5SRURfQkFTSU46XG4gICAgICAgICAgICAgICAgdGhpcy5saWdodHMucHVzaChuZXcgTGlnaHRTb3VyY2UocG9zaXRpb24sIDE1MCwgdGhpcy5mb3VudGFpblJlZFRleHR1cmUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExpZ2h0VHlwZS5CTFVFX0JBU0lOOlxuICAgICAgICAgICAgICAgIHRoaXMubGlnaHRzLnB1c2gobmV3IExpZ2h0U291cmNlKHBvc2l0aW9uLCAxNTAsIHRoaXMuZm91bnRhaW5CbHVlVGV4dHVyZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTGlnaHRUeXBlLkJPTkZJUkU6XG4gICAgICAgICAgICAgICAgdGhpcy5saWdodHMucHVzaChuZXcgTGlnaHRTb3VyY2UocG9zaXRpb24sIDI1MCwgdGhpcy5ib25maXJlVGV4dHVyZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQoeCwgeSwgc2VnbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICAgICAgdGhpcy5zaGFkb3dDYXN0ZXIuYWRkU2VnbWVudCh4ICogVElMRV9TSVpFICsgc2VnbWVudC54MSwgeSAqIFRJTEVfU0laRSArIHNlZ21lbnQueTEsIHggKiBUSUxFX1NJWkUgKyBzZWdtZW50LngyLCB5ICogVElMRV9TSVpFICsgc2VnbWVudC55Miwgc2VnbWVudC50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMubGlnaHRzLmZvckVhY2goKGxpZ2h0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBQSVhJLlBvaW50KGxpZ2h0LnBvc2l0aW9uLnggKyA4LCBsaWdodC5wb3NpdGlvbi55ICsgOCk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd0Nhc3Rlci5zZXRMaWdodExvY2F0aW9uKHN0YXJ0LngsIHN0YXJ0LnksIGxpZ2h0Lm1heERpc3RhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuc2hhZG93Q2FzdGVyLnN3ZWVwKCk7XG4gICAgICAgICAgICBsaWdodC5zcHJpdGUucG9zaXRpb24uc2V0KHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgICAgICAgbGlnaHQubWFzay5jbGVhcigpXG4gICAgICAgICAgICAgICAgLmJlZ2luRmlsbCgweEZGRkZGRiwgMSlcbiAgICAgICAgICAgICAgICAuZHJhd1BvbHlnb24ob3V0cHV0KVxuICAgICAgICAgICAgICAgIC5lbmRGaWxsKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ3JhZGllbnQoY29sb3IsIHJhZGl1cykge1xuICAgICAgICBjb25zdCBkaWFtZXRlciA9IHJhZGl1cyA8PCAxO1xuICAgICAgICBjb25zdCBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgYy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICBjLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICBjb25zdCBjdHggPSBjLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY29uc3QgZ3JkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHJhZGl1cywgcmFkaXVzLCAwLCByYWRpdXMsIHJhZGl1cywgcmFkaXVzKTtcbiAgICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMC4xLCBjb2xvcik7XG4gICAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDEsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JkO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGRpYW1ldGVyLCBkaWFtZXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBJWEkuVGV4dHVyZS5mcm9tKGMpO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgTGlnaHRUeXBlO1xuKGZ1bmN0aW9uIChMaWdodFR5cGUpIHtcbiAgICBMaWdodFR5cGVbTGlnaHRUeXBlW1wiSEVST1wiXSA9IDBdID0gXCJIRVJPXCI7XG4gICAgTGlnaHRUeXBlW0xpZ2h0VHlwZVtcIlJFRF9CQVNJTlwiXSA9IDFdID0gXCJSRURfQkFTSU5cIjtcbiAgICBMaWdodFR5cGVbTGlnaHRUeXBlW1wiQkxVRV9CQVNJTlwiXSA9IDJdID0gXCJCTFVFX0JBU0lOXCI7XG4gICAgTGlnaHRUeXBlW0xpZ2h0VHlwZVtcIkJPTkZJUkVcIl0gPSAzXSA9IFwiQk9ORklSRVwiO1xufSkoTGlnaHRUeXBlIHx8IChMaWdodFR5cGUgPSB7fSkpO1xuY2xhc3MgTGlnaHRTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBtYXhEaXN0YW5jZSwgdGV4dHVyZSwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuICAgICAgICB0aGlzLm1hc2sgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuICAgICAgICB0aGlzLm1hc2suaXNNYXNrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgIHRoaXMuc3ByaXRlLmFuY2hvci5zZXQoMC41LCAwLjUpO1xuICAgICAgICB0aGlzLnNwcml0ZS5tYXNrID0gdGhpcy5tYXNrO1xuICAgICAgICB0aGlzLnNwcml0ZS5ibGVuZE1vZGUgPSBQSVhJLkJMRU5EX01PREVTLkFERDtcbiAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMubWFzayk7XG4gICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLnNwcml0ZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3ByaXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tYXNrLmRlc3Ryb3koKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb2lucywgSGVhbHRoQmlnRmxhc2ssIEhlYWx0aEZsYXNrLCBXZWFwb24gfSBmcm9tIFwiLi9kcm9wXCI7XG5pbXBvcnQgeyBEdW5nZW9uTGlnaHQgfSBmcm9tIFwiLi9kdW5nZW9uLmxpZ2h0XCI7XG5pbXBvcnQgKiBhcyBQSVhJIGZyb20gJ3BpeGkuanMnO1xuY29uc3QgVElMRV9TSVpFID0gMTY7XG5leHBvcnQgY29uc3QgRHVuZ2VvblpJbmRleGVzID0ge1xuICAgIGNoYXJhY3RlcjogNjAsXG4gICAgaGVybzogNzAsXG4gICAgZHJvcDogNTAsXG4gICAgc3RhdGljOiA0MCxcbiAgICBmbG9vcjogMSxcbiAgICB3YWxsOiAxMDAsXG4gICAgcm93OiAyNTZcbn07XG5leHBvcnQgY2xhc3MgRHVuZ2Vvbk1hcCB7XG4gICAgY29uc3RydWN0b3IoY29udHJvbGxlciwgdGlja2VyLCBybmcsIHNlZWQsIGxldmVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2NhbGUgPSAyO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICB0aGlzLnRpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgdGhpcy5ybmcgPSBybmc7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jZWxscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMud2lkdGg7IHkrKykge1xuICAgICAgICAgICAgdGhpcy5jZWxsc1t5XSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLmhlaWdodDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsc1t5XVt4XSA9IG5ldyBNYXBDZWxsKHRoaXMsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnpJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnNvcnRhYmxlQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zY2FsZS5zZXQodGhpcy5zY2FsZSwgdGhpcy5zY2FsZSk7XG4gICAgICAgIHRoaXMubGlnaHQgPSBuZXcgRHVuZ2VvbkxpZ2h0KHRoaXMpO1xuICAgICAgICB0aGlzLmxpZ2h0LmxheWVyLnpJbmRleCA9IDE7XG4gICAgICAgIHRoaXMubGlnaHQuY29udGFpbmVyLnNjYWxlLnNldCh0aGlzLnNjYWxlLCB0aGlzLnNjYWxlKTtcbiAgICAgICAgdGhpcy5saWdodGluZyA9IG5ldyBQSVhJLlNwcml0ZSh0aGlzLmxpZ2h0LmxheWVyLmdldFJlbmRlclRleHR1cmUoKSk7XG4gICAgICAgIHRoaXMubGlnaHRpbmcuYmxlbmRNb2RlID0gUElYSS5CTEVORF9NT0RFUy5NVUxUSVBMWTtcbiAgICAgICAgdGhpcy5saWdodGluZy56SW5kZXggPSAyO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsc1t5XVt4XS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saWdodGluZy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubGlnaHQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5kZXN0cm95KHsgY2hpbGRyZW46IHRydWUgfSk7XG4gICAgfVxuICAgIGxvZyhtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcbiAgICB9XG4gICAgY2VsbCh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxzW3ldW3hdO1xuICAgIH1cbiAgICByZW1vdmUoeCwgeSwgb2JqZWN0KSB7XG4gICAgICAgIGZvciAobGV0IGR4ID0gMDsgZHggPCBvYmplY3Qud2lkdGg7IGR4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGR5ID0gMDsgZHkgPCBvYmplY3QuaGVpZ2h0OyBkeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY2VsbCh4ICsgZHgsIHkgLSBkeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNlbGwub2JqZWN0O1xuICAgICAgICAgICAgICAgIGlmIChjICYmIChjID09PSBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwub2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHgsIHksIG9iamVjdCkge1xuICAgICAgICBmb3IgKGxldCBkeCA9IDA7IGR4IDwgb2JqZWN0LndpZHRoOyBkeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkeSA9IDA7IGR5IDwgb2JqZWN0LmhlaWdodDsgZHkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbCh4ICsgZHgsIHkgLSBkeSkub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGF2YWlsYWJsZSh4LCB5LCBvYmplY3QpIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAwOyBkeCA8IG9iamVjdC53aWR0aDsgZHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgZHkgPSAwOyBkeSA8IG9iamVjdC5oZWlnaHQ7IGR5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5jZWxsKHggKyBkeCwgeSAtIGR5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwuaGFzRmxvb3IgfHwgY2VsbC5jb2xsaWRlKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2FtZXJhKHgsIHkpIHtcbiAgICAgICAgY29uc3QgY193ID0gdGhpcy5jb250cm9sbGVyLmFwcC5zY3JlZW4ud2lkdGg7XG4gICAgICAgIGNvbnN0IGNfaCA9IHRoaXMuY29udHJvbGxlci5hcHAuc2NyZWVuLmhlaWdodDtcbiAgICAgICAgY29uc3QgcF94ID0gKGNfdyA+PiAxKSAtIHggKiB0aGlzLnNjYWxlO1xuICAgICAgICBjb25zdCBwX3kgPSAoY19oID4+IDEpIC0geSAqIHRoaXMuc2NhbGU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnBvc2l0aW9uLnNldChwX3gsIHBfeSk7XG4gICAgICAgIHRoaXMubGlnaHQuY29udGFpbmVyLnBvc2l0aW9uLnNldChwX3gsIHBfeSk7XG4gICAgfVxuICAgIHNwcml0ZSh4LCB5LCBuYW1lKSB7XG4gICAgICAgIGxldCBzcHJpdGU7XG4gICAgICAgIGlmICghbmFtZS5lbmRzV2l0aCgnLnBuZycpKSB7XG4gICAgICAgICAgICBjb25zdCBhbmltYXRlZCA9IHRoaXMuY29udHJvbGxlci5yZXNvdXJjZXMuYW5pbWF0ZWQobmFtZSk7XG4gICAgICAgICAgICBhbmltYXRlZC5hbmltYXRpb25TcGVlZCA9IDAuMjtcbiAgICAgICAgICAgIGFuaW1hdGVkLnBsYXkoKTtcbiAgICAgICAgICAgIHNwcml0ZSA9IGFuaW1hdGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5jb250cm9sbGVyLnJlc291cmNlcy5zcHJpdGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCh4ICogVElMRV9TSVpFLCB5ICogVElMRV9TSVpFKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgcmV0dXJuIHNwcml0ZTtcbiAgICB9XG4gICAgYW5pbWF0ZWQoeCwgeSwgbmFtZSkge1xuICAgICAgICBjb25zdCBhbmltYXRlZCA9IHRoaXMuY29udHJvbGxlci5yZXNvdXJjZXMuYW5pbWF0ZWQobmFtZSk7XG4gICAgICAgIGFuaW1hdGVkLmFuaW1hdGlvblNwZWVkID0gMC4yO1xuICAgICAgICBhbmltYXRlZC5wbGF5KCk7XG4gICAgICAgIGFuaW1hdGVkLnBvc2l0aW9uLnNldCh4ICogVElMRV9TSVpFLCB5ICogVElMRV9TSVpFKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQoYW5pbWF0ZWQpO1xuICAgICAgICByZXR1cm4gYW5pbWF0ZWQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1hcENlbGwge1xuICAgIGNvbnN0cnVjdG9yKGR1bmdlb24sIHgsIHkpIHtcbiAgICAgICAgdGhpcy5fZmxvb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl93YWxsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZHJvcCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29iamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZHVuZ2VvbiA9IGR1bmdlb247XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgKF9hID0gdGhpcy5fZmxvb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX2Zsb29yID0gbnVsbDtcbiAgICAgICAgKF9iID0gdGhpcy5fd2FsbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fd2FsbCA9IG51bGw7XG4gICAgICAgIChfYyA9IHRoaXMuX2Ryb3ApID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX2Ryb3AgPSBudWxsO1xuICAgICAgICAoX2QgPSB0aGlzLl9vYmplY3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX29iamVjdCA9IG51bGw7XG4gICAgfVxuICAgIHNldCBmbG9vck5hbWUobmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuX2Zsb29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9mbG9vciA9IG51bGw7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9mbG9vciA9IG5ldyBEZWZhdWx0RHVuZ2VvbkZsb29yKHRoaXMuZHVuZ2VvbiwgdGhpcy54LCB0aGlzLnksIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmbG9vck5hbWUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9mbG9vcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpIHx8IG51bGw7XG4gICAgfVxuICAgIGdldCBmbG9vcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zsb29yO1xuICAgIH1cbiAgICBnZXQgaGFzRmxvb3IoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2Zsb29yO1xuICAgIH1cbiAgICBnZXQgd2FsbE5hbWUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl93YWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHdhbGxOYW1lKG5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLl93YWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl93YWxsID0gbnVsbDtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhbGwgPSBuZXcgRHVuZ2VvbldhbGwodGhpcy5kdW5nZW9uLCB0aGlzLngsIHRoaXMueSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHdhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YWxsO1xuICAgIH1cbiAgICBzZXQgZHJvcEl0ZW0oZHJvcCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuX2Ryb3ApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX2Ryb3AgPSBudWxsO1xuICAgICAgICBpZiAoZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5fZHJvcCA9IG5ldyBEdW5nZW9uRHJvcCh0aGlzLmR1bmdlb24sIHRoaXMueCwgdGhpcy55LCBkcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZHJvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3A7XG4gICAgfVxuICAgIGdldCBoYXNEcm9wKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kcm9wO1xuICAgIH1cbiAgICByYW5kb21Ecm9wKCkge1xuICAgICAgICBjb25zdCBybmcgPSB0aGlzLmR1bmdlb24ucm5nO1xuICAgICAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLmR1bmdlb24uY29udHJvbGxlci5yZXNvdXJjZXM7XG4gICAgICAgIGNvbnN0IHdlaWdodF9jb2lucyA9IDIwO1xuICAgICAgICBjb25zdCB3ZWlnaHRfaGVhbHRoX2ZsYXNrID0gMTA7XG4gICAgICAgIGNvbnN0IHdlaWdodF9oZWFsdGhfYmlnX2ZsYXNrID0gMTA7XG4gICAgICAgIGNvbnN0IHdlaWdodF93ZWFwb24gPSAxMDtcbiAgICAgICAgY29uc3Qgc3VtID0gd2VpZ2h0X2NvaW5zICsgd2VpZ2h0X2hlYWx0aF9mbGFzayArIHdlaWdodF9oZWFsdGhfYmlnX2ZsYXNrICsgd2VpZ2h0X3dlYXBvbjtcbiAgICAgICAgbGV0IHJlbWFpbmluZ19kaXN0YW5jZSA9IHJuZy5uZXh0RmxvYXQoKSAqIHN1bTtcbiAgICAgICAgaWYgKChyZW1haW5pbmdfZGlzdGFuY2UgLT0gd2VpZ2h0X3dlYXBvbikgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5kcm9wSXRlbSA9IFdlYXBvbi5jcmVhdGUocmVzb3VyY2VzLCBybmcsIHRoaXMuZHVuZ2Vvbi5sZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJlbWFpbmluZ19kaXN0YW5jZSAtPSB3ZWlnaHRfaGVhbHRoX2JpZ19mbGFzaykgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5kcm9wSXRlbSA9IG5ldyBIZWFsdGhCaWdGbGFzayhyZXNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChyZW1haW5pbmdfZGlzdGFuY2UgLT0gd2VpZ2h0X2hlYWx0aF9mbGFzaykgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5kcm9wSXRlbSA9IG5ldyBIZWFsdGhGbGFzayhyZXNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChyZW1haW5pbmdfZGlzdGFuY2UgLSB3ZWlnaHRfY29pbnMpIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuZHJvcEl0ZW0gPSBuZXcgQ29pbnMocm5nLCByZXNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0Ryb3A7XG4gICAgfVxuICAgIGdldCBvYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYmplY3Q7XG4gICAgfVxuICAgIHNldCBvYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgJiYgISh0aGlzLl9vYmplY3QgPT09IG51bGwgfHwgdGhpcy5fb2JqZWN0ID09PSBvYmplY3QpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImN1cnJlbnQgY2hhclwiLCB0aGlzLl9vYmplY3QpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJuZXcgY2hhclwiLCBvYmplY3QpO1xuICAgICAgICAgICAgdGhyb3cgXCJlcnJvciB3aGlsZSBzZXQgY2hhciB0byBjZWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xuICAgIH1cbiAgICBnZXQgaGFzT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0ICE9IG51bGw7XG4gICAgfVxuICAgIGxhZGRlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLl9mbG9vcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fZmxvb3IgPSBuZXcgRHVuZ2VvbkxhZGRlcih0aGlzLmR1bmdlb24sIHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gICAgZ2V0IGludGVyYWN0aW5nKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fZmxvb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnRlcmFjdGluZykgfHwgKChfYiA9IHRoaXMuX3dhbGwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbnRlcmFjdGluZykgfHwgKChfYyA9IHRoaXMuX2Ryb3ApID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pbnRlcmFjdGluZykgfHwgKChfZCA9IHRoaXMuX29iamVjdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmludGVyYWN0aW5nKSB8fCBmYWxzZTtcbiAgICB9XG4gICAgaW50ZXJhY3QoaGVybykge1xuICAgICAgICBpZiAodGhpcy5fb2JqZWN0ICYmIHRoaXMuX29iamVjdC5pbnRlcmFjdGluZykge1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0LmludGVyYWN0KGhlcm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2Ryb3AgJiYgdGhpcy5fZHJvcC5pbnRlcmFjdGluZykge1xuICAgICAgICAgICAgdGhpcy5fZHJvcC5pbnRlcmFjdChoZXJvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl93YWxsICYmIHRoaXMuX3dhbGwuaW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhbGwuaW50ZXJhY3QoaGVybyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZmxvb3IgJiYgdGhpcy5fZmxvb3IuaW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zsb29yLmludGVyYWN0KGhlcm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxpZGUob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fb2JqZWN0ICYmIHRoaXMuX29iamVjdC5jb2xsaWRlKG9iamVjdCkpIHx8XG4gICAgICAgICAgICAodGhpcy5fd2FsbCAmJiB0aGlzLl93YWxsLmNvbGxpZGUob2JqZWN0KSkgfHxcbiAgICAgICAgICAgIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEdW5nZW9uRmxvb3Ige1xuICAgIGNvbnN0cnVjdG9yKGR1bmdlb24sIHgsIHksIG5hbWUpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxO1xuICAgICAgICB0aGlzLndpZHRoID0gMTtcbiAgICAgICAgdGhpcy5zdGF0aWMgPSB0cnVlO1xuICAgICAgICB0aGlzLmR1bmdlb24gPSBkdW5nZW9uO1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNwcml0ZSA9IGR1bmdlb24uc3ByaXRlKHgsIHksIG5hbWUpO1xuICAgICAgICB0aGlzLnNwcml0ZS56SW5kZXggPSBEdW5nZW9uWkluZGV4ZXMuZmxvb3I7XG4gICAgfVxuICAgIGNvbGxpZGUoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3ByaXRlLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGVmYXVsdER1bmdlb25GbG9vciBleHRlbmRzIER1bmdlb25GbG9vciB7XG4gICAgY29uc3RydWN0b3IoZHVuZ2VvbiwgeCwgeSwgbmFtZSkge1xuICAgICAgICBzdXBlcihkdW5nZW9uLCB4LCB5LCBuYW1lKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBpbnRlcmFjdChfKSB7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIER1bmdlb25MYWRkZXIgZXh0ZW5kcyBEdW5nZW9uRmxvb3Ige1xuICAgIGNvbnN0cnVjdG9yKGR1bmdlb24sIHgsIHkpIHtcbiAgICAgICAgc3VwZXIoZHVuZ2VvbiwgeCwgeSwgJ2Zsb29yX2xhZGRlci5wbmcnKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGluZyA9IHRydWU7XG4gICAgfVxuICAgIGludGVyYWN0KGhlcm8pIHtcbiAgICAgICAgdGhpcy5kdW5nZW9uLmNvbnRyb2xsZXIudXBkYXRlSGVybyhoZXJvLmNoYXJhY3RlciwgdGhpcy5kdW5nZW9uLmxldmVsICsgMSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIER1bmdlb25XYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihkdW5nZW9uLCB4LCB5LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTtcbiAgICAgICAgdGhpcy53aWR0aCA9IDE7XG4gICAgICAgIHRoaXMuc3RhdGljID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmR1bmdlb24gPSBkdW5nZW9uO1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNwcml0ZSA9IGR1bmdlb24uc3ByaXRlKHgsIHksIG5hbWUpO1xuICAgICAgICB0aGlzLnNwcml0ZS56SW5kZXggPSBEdW5nZW9uWkluZGV4ZXMud2FsbCArIHkgKiBEdW5nZW9uWkluZGV4ZXMucm93O1xuICAgIH1cbiAgICBpbnRlcmFjdChfKSB7XG4gICAgfVxuICAgIGNvbGxpZGUoXykge1xuICAgICAgICByZXR1cm4gIXRoaXMuZHVuZ2Vvbi5jZWxsKHRoaXMueCwgdGhpcy55KS5oYXNGbG9vcjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEdW5nZW9uRHJvcCB7XG4gICAgY29uc3RydWN0b3IoZHVuZ2VvbiwgeCwgeSwgZHJvcCkge1xuICAgICAgICB0aGlzLmhlaWdodCA9IDE7XG4gICAgICAgIHRoaXMud2lkdGggPSAxO1xuICAgICAgICB0aGlzLnN0YXRpYyA9IHRydWU7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmR1bmdlb24gPSBkdW5nZW9uO1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmRyb3AgPSBkcm9wO1xuICAgICAgICB0aGlzLnNwcml0ZSA9IGR1bmdlb24uc3ByaXRlKHgsIHksIGRyb3Auc3ByaXRlTmFtZSk7XG4gICAgICAgIHRoaXMuc3ByaXRlLnpJbmRleCA9IER1bmdlb25aSW5kZXhlcy5kcm9wICsgeSAqIER1bmdlb25aSW5kZXhlcy5yb3c7XG4gICAgICAgIHRoaXMuc3ByaXRlLnggKz0gKFRJTEVfU0laRSA+PiAxKTtcbiAgICAgICAgdGhpcy5zcHJpdGUueSArPSBUSUxFX1NJWkUgLSAyO1xuICAgICAgICB0aGlzLnNwcml0ZS5hbmNob3Iuc2V0KDAuNSwgMSk7XG4gICAgICAgIGlmICh0aGlzLnNwcml0ZSBpbnN0YW5jZW9mIFBJWEkuQW5pbWF0ZWRTcHJpdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFuaW1hdGlvblNwZWVkID0gMC4yO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUucGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBpY2tlZFVwKGhlcm8pIHtcbiAgICAgICAgaWYgKHRoaXMuZHJvcC5waWNrZWRVcChoZXJvKSkge1xuICAgICAgICAgICAgdGhpcy5kdW5nZW9uLmNlbGwodGhpcy54LCB0aGlzLnkpLmRyb3BJdGVtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludGVyYWN0KF8pIHtcbiAgICB9XG4gICAgY29sbGlkZShfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zcHJpdGUuZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEdW5nZW9uVGl0bGUgZXh0ZW5kcyBQSVhJLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGl0bGUgPSBuZXcgUElYSS5CaXRtYXBUZXh0KFwiXCIsIHsgZm9udDogeyBuYW1lOiAnYWxhZ2FyZCcsIHNpemU6IDMyIH0gfSk7XG4gICAgICAgIHRoaXMudGl0bGUuYW5jaG9yID0gMC41O1xuICAgICAgICB0aGlzLnRpdGxlLnBvc2l0aW9uLnNldCgwLCAxNik7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy50aXRsZSk7XG4gICAgfVxuICAgIHNldCBsZXZlbChsZXZlbCkge1xuICAgICAgICB0aGlzLnRpdGxlLnRleHQgPSBgTEVWRUwgJHtsZXZlbH1gO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRpdGxlLmRlc3Ryb3koKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgKiBhcyBQSVhJIGZyb20gJ3BpeGkuanMnO1xuZXhwb3J0IHZhciBIZXVyaXN0aWM7XG4oZnVuY3Rpb24gKEhldXJpc3RpYykge1xuICAgIEhldXJpc3RpY1tIZXVyaXN0aWNbXCJNYW5oYXR0YW5cIl0gPSAwXSA9IFwiTWFuaGF0dGFuXCI7XG4gICAgSGV1cmlzdGljW0hldXJpc3RpY1tcIkV1Y2xpZGVhblwiXSA9IDFdID0gXCJFdWNsaWRlYW5cIjtcbiAgICBIZXVyaXN0aWNbSGV1cmlzdGljW1wiQ2hlYnlzaGV2XCJdID0gMl0gPSBcIkNoZWJ5c2hldlwiO1xuICAgIEhldXJpc3RpY1tIZXVyaXN0aWNbXCJPY3RpbGVcIl0gPSAzXSA9IFwiT2N0aWxlXCI7XG59KShIZXVyaXN0aWMgfHwgKEhldXJpc3RpYyA9IHt9KSk7XG5jbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZyA9IDA7XG4gICAgICAgIHRoaXMuaCA9IDA7XG4gICAgICAgIHRoaXMuZiA9IDA7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxuICAgIGVxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmVxdWFscyhvdGhlci5wb3NpdGlvbik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFBhdGhGaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBkaWFnb25hbEFsbG93ZWQgPSB0cnVlLCBpbmNsdWRlU3RhcnQgPSBmYWxzZSwgaW5jbHVkZUVuZCA9IGZhbHNlLCBoZXVyaXN0aWMgPSBIZXVyaXN0aWMuQ2hlYnlzaGV2LCB3ZWlnaHQgPSAxKSB7XG4gICAgICAgIHRoaXMubWFwID0gW107XG4gICAgICAgIHRoaXMud2VpZ2h0ID0gMTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5kaWFnb25hbEFsbG93ZWQgPSBkaWFnb25hbEFsbG93ZWQ7XG4gICAgICAgIHRoaXMuaW5jbHVkZVN0YXJ0ID0gaW5jbHVkZVN0YXJ0O1xuICAgICAgICB0aGlzLmluY2x1ZGVFbmQgPSBpbmNsdWRlRW5kO1xuICAgICAgICB0aGlzLmhldXJpc3RpYyA9IGhldXJpc3RpYztcbiAgICAgICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gW107XG4gICAgICAgICAgICB0aGlzLm1hcC5wdXNoKHJvdyk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2goMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoeCwgeSkge1xuICAgICAgICB0aGlzLm1hcFt4XVt5XSA9IDA7XG4gICAgfVxuICAgIG1hcmsoeCwgeSkge1xuICAgICAgICB0aGlzLm1hcFt4XVt5XSA9IDE7XG4gICAgfVxuICAgIGZpbmQoc3RhcnQsIGVuZCkge1xuICAgICAgICBsZXQgc3RhcnRfbm9kZSA9IG5ldyBOb2RlKG51bGwsIHN0YXJ0KTtcbiAgICAgICAgbGV0IGVuZF9ub2RlID0gbmV3IE5vZGUobnVsbCwgZW5kKTtcbiAgICAgICAgbGV0IG9wZW5fbGlzdCA9IFtdO1xuICAgICAgICBsZXQgY2xvc2VkX2xpc3QgPSBbXTtcbiAgICAgICAgb3Blbl9saXN0LnB1c2goc3RhcnRfbm9kZSk7XG4gICAgICAgIHdoaWxlIChvcGVuX2xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRfbm9kZSA9IG9wZW5fbGlzdFswXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50X2luZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb3Blbl9saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBvcGVuX2xpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZiA8IGN1cnJlbnRfbm9kZS5mKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW5fbGlzdC5zcGxpY2UoY3VycmVudF9pbmRleCwgMSk7XG4gICAgICAgICAgICBjbG9zZWRfbGlzdC5wdXNoKGN1cnJlbnRfbm9kZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudF9ub2RlLmVxdWFsKGVuZF9ub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNsdWRlRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50X25vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudF9ub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQucGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChjdXJyZW50LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNsdWRlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKGN1cnJlbnQucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc3F1YXJlcyA9IHRoaXMuZGlhZ29uYWxBbGxvd2VkID8gUGF0aEZpbmRpbmcuYWRqYWNlbnRTcXVhcmVzRGlhZ29uYWwgOiBQYXRoRmluZGluZy5hZGphY2VudFNxdWFyZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNxdWFyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3X3Bvc2l0aW9uID0gc3F1YXJlc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZV9wb3NpdGlvbiA9IG5ldyBQSVhJLlBvaW50KGN1cnJlbnRfbm9kZS5wb3NpdGlvbi54ICsgbmV3X3Bvc2l0aW9uLngsIGN1cnJlbnRfbm9kZS5wb3NpdGlvbi55ICsgbmV3X3Bvc2l0aW9uLnkpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlX3Bvc2l0aW9uLnggPj0gdGhpcy53aWR0aCB8fCBub2RlX3Bvc2l0aW9uLnggPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIG5vZGVfcG9zaXRpb24ueSA+PSB0aGlzLmhlaWdodCB8fCBub2RlX3Bvc2l0aW9uLnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXBbbm9kZV9wb3NpdGlvbi54XVtub2RlX3Bvc2l0aW9uLnldICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXdfbm9kZSA9IG5ldyBOb2RlKGN1cnJlbnRfbm9kZSwgbm9kZV9wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXdfbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlZF9saXN0LmZpbmQoYyA9PiBjLmVxdWFsKGNoaWxkKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGQuZyA9IGN1cnJlbnRfbm9kZS5nICsgMTtcbiAgICAgICAgICAgICAgICBjaGlsZC5oID0gdGhpcy5oZXVyaXN0aWNGdW5jdGlvbihjaGlsZC5wb3NpdGlvbiwgZW5kX25vZGUucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGNoaWxkLmYgPSBjaGlsZC5nICsgY2hpbGQuaDtcbiAgICAgICAgICAgICAgICBpZiAob3Blbl9saXN0LmZpbmQoYyA9PiBjLmVxdWFsKGNoaWxkKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3Blbl9saXN0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaGV1cmlzdGljRnVuY3Rpb24ocG9zMCwgcG9zMSkge1xuICAgICAgICBsZXQgZHggPSBNYXRoLmFicyhwb3MxLnggLSBwb3MwLngpO1xuICAgICAgICBsZXQgZHkgPSBNYXRoLmFicyhwb3MxLnkgLSBwb3MwLnkpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaGV1cmlzdGljKSB7XG4gICAgICAgICAgICBjYXNlIEhldXJpc3RpYy5NYW5oYXR0YW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkeCArIGR5KSAqIHRoaXMud2VpZ2h0O1xuICAgICAgICAgICAgY2FzZSBIZXVyaXN0aWMuRXVjbGlkZWFuOlxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpICogdGhpcy53ZWlnaHQ7XG4gICAgICAgICAgICBjYXNlIEhldXJpc3RpYy5DaGVieXNoZXY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGR4LCBkeSkgKiB0aGlzLndlaWdodDtcbiAgICAgICAgICAgIGNhc2UgSGV1cmlzdGljLk9jdGlsZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKGR4ICsgZHkgLSAwLjU4ICogTWF0aC5taW4oZHgsIGR5KSkgKiB0aGlzLndlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbn1cblBhdGhGaW5kaW5nLmFkamFjZW50U3F1YXJlcyA9IFtcbiAgICBuZXcgUElYSS5Qb2ludCgwLCAtMSksXG4gICAgbmV3IFBJWEkuUG9pbnQoMCwgMSksXG4gICAgbmV3IFBJWEkuUG9pbnQoLTEsIDApLFxuICAgIG5ldyBQSVhJLlBvaW50KDEsIDApLFxuXTtcblBhdGhGaW5kaW5nLmFkamFjZW50U3F1YXJlc0RpYWdvbmFsID0gW1xuICAgIG5ldyBQSVhJLlBvaW50KDAsIC0xKSxcbiAgICBuZXcgUElYSS5Qb2ludCgwLCAxKSxcbiAgICBuZXcgUElYSS5Qb2ludCgtMSwgMCksXG4gICAgbmV3IFBJWEkuUG9pbnQoMSwgMCksXG4gICAgbmV3IFBJWEkuUG9pbnQoLTEsIC0xKSxcbiAgICBuZXcgUElYSS5Qb2ludCgtMSwgMSksXG4gICAgbmV3IFBJWEkuUG9pbnQoMSwgLTEpLFxuICAgIG5ldyBQSVhJLlBvaW50KDEsIDEpXG5dO1xuIiwiaW1wb3J0IHsgRHVuZ2VvblpJbmRleGVzIH0gZnJvbSBcIi4vZHVuZ2Vvbi5tYXBcIjtcbmltcG9ydCB7IE9ic2VydmFibGVWYXIgfSBmcm9tIFwiLi9vYnNlcnZhYmxlXCI7XG5pbXBvcnQgeyBMaW5lYXJDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlc1wiO1xuaW1wb3J0IHsgUGF0aEZpbmRpbmcgfSBmcm9tIFwiLi9wYXRoZmluZGluZ1wiO1xuaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiO1xuY29uc3QgVElMRV9TSVpFID0gMTY7XG5leHBvcnQgY2xhc3MgQ2hhcmFjdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBuZXcgT2JzZXJ2YWJsZVZhcihvcHRpb25zLnNwZWVkKTtcbiAgICAgICAgdGhpcy5faGVhbHRoTWF4ID0gbmV3IE9ic2VydmFibGVWYXIob3B0aW9ucy5oZWFsdGhNYXgpO1xuICAgICAgICB0aGlzLl9oZWFsdGggPSBuZXcgT2JzZXJ2YWJsZVZhcihvcHRpb25zLmhlYWx0aE1heCk7XG4gICAgICAgIHRoaXMuX2RlYWQgPSBuZXcgT2JzZXJ2YWJsZVZhcihmYWxzZSk7XG4gICAgICAgIHRoaXMuX2tpbGxlZEJ5ID0gbmV3IE9ic2VydmFibGVWYXIobnVsbCk7XG4gICAgfVxuICAgIGdldCBzcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NwZWVkLmdldCgpO1xuICAgIH1cbiAgICBnZXQgaGVhbHRoTWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhbHRoTWF4O1xuICAgIH1cbiAgICBnZXQgaGVhbHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhbHRoO1xuICAgIH1cbiAgICBnZXQgZGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYWQ7XG4gICAgfVxuICAgIGdldCBraWxsZWRCeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tpbGxlZEJ5O1xuICAgIH1cbiAgICBoZWFsKGhlYWx0aCkge1xuICAgICAgICB0aGlzLl9oZWFsdGgudXBkYXRlKGggPT4gTWF0aC5taW4odGhpcy5faGVhbHRoTWF4LmdldCgpLCBoICsgaGVhbHRoKSk7XG4gICAgfVxuICAgIGhpdERhbWFnZShieSwgZGFtYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGVhZC5nZXQoKSkge1xuICAgICAgICAgICAgdGhpcy5faGVhbHRoLnVwZGF0ZSgoaCkgPT4gTWF0aC5tYXgoMCwgaCAtIGRhbWFnZSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYWx0aC5nZXQoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2tpbGxlZEJ5LnNldChieSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVhZC5zZXQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgdmFyIFNjYW5EaXJlY3Rpb247XG4oZnVuY3Rpb24gKFNjYW5EaXJlY3Rpb24pIHtcbiAgICBTY2FuRGlyZWN0aW9uW1NjYW5EaXJlY3Rpb25bXCJMRUZUXCJdID0gMV0gPSBcIkxFRlRcIjtcbiAgICBTY2FuRGlyZWN0aW9uW1NjYW5EaXJlY3Rpb25bXCJSSUdIVFwiXSA9IDJdID0gXCJSSUdIVFwiO1xuICAgIFNjYW5EaXJlY3Rpb25bU2NhbkRpcmVjdGlvbltcIkFST1VORFwiXSA9IDRdID0gXCJBUk9VTkRcIjtcbn0pKFNjYW5EaXJlY3Rpb24gfHwgKFNjYW5EaXJlY3Rpb24gPSB7fSkpO1xuZXhwb3J0IGNsYXNzIEJhc2VDaGFyYWN0ZXJBSSB7XG4gICAgY29uc3RydWN0b3IoZHVuZ2Vvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmR1bmdlb24gPSBkdW5nZW9uO1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgdGhpcy5feCA9IG9wdGlvbnMueDtcbiAgICAgICAgdGhpcy5feSA9IG9wdGlvbnMueTtcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IEJhc2VDaGFyYWN0ZXJWaWV3KGR1bmdlb24sIG9wdGlvbnMuekluZGV4LCBvcHRpb25zLndpZHRoLCBvcHRpb25zLm9uX3Bvc2l0aW9uKTtcbiAgICB9XG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfVxuICAgIHNldCBhbmltYXRpb24oYW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fYW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uLnJ1bigpO1xuICAgIH1cbiAgICBnZXQgYW5pbWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9uO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICB0aGlzLmNoYXJhY3Rlci5raWxsZWRCeS5zdWJzY3JpYmUodGhpcy5oYW5kbGVLaWxsZWRCeSwgdGhpcyk7XG4gICAgICAgIHRoaXMuY2hhcmFjdGVyLmRlYWQuc3Vic2NyaWJlKHRoaXMuaGFuZGxlRGVhZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaWRsZSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuX2FuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLmNoYXJhY3Rlci5raWxsZWRCeS51bnN1YnNjcmliZSh0aGlzLmhhbmRsZUtpbGxlZEJ5LCB0aGlzKTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIuZGVhZC51bnN1YnNjcmliZSh0aGlzLmhhbmRsZURlYWQsIHRoaXMpO1xuICAgICAgICB0aGlzLmR1bmdlb24ucmVtb3ZlKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMpO1xuICAgICAgICB0aGlzLnZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICBjb2xsaWRlKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcyAhPT0gb2JqZWN0O1xuICAgIH1cbiAgICBoYW5kbGVLaWxsZWRCeShieSkge1xuICAgICAgICBpZiAoYnkpXG4gICAgICAgICAgICB0aGlzLm9uS2lsbGVkQnkoYnkpO1xuICAgIH1cbiAgICBoYW5kbGVEZWFkKGRlYWQpIHtcbiAgICAgICAgaWYgKGRlYWQpIHtcbiAgICAgICAgICAgIHRoaXMub25EZWFkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZERyb3BDZWxsKG1heF9kaXN0YW5jZSA9IDUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZENlbGwobWF4X2Rpc3RhbmNlLCBjZWxsID0+IGNlbGwuaGFzRmxvb3IgJiYgIWNlbGwuaGFzT2JqZWN0ICYmICFjZWxsLmhhc0Ryb3ApO1xuICAgIH1cbiAgICBmaW5kU3Bhd25DZWxsKG1heF9kaXN0YW5jZSA9IDUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZENlbGwobWF4X2Rpc3RhbmNlLCBjZWxsID0+IGNlbGwuaGFzRmxvb3IgJiYgIWNlbGwuaGFzT2JqZWN0KTtcbiAgICB9XG4gICAgZmluZENlbGwobWF4X2Rpc3RhbmNlLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgcG9zX3ggPSB0aGlzLng7XG4gICAgICAgIGNvbnN0IHBvc195ID0gdGhpcy55O1xuICAgICAgICBjb25zdCBpc19sZWZ0ID0gdGhpcy52aWV3LmlzX2xlZnQ7XG4gICAgICAgIGxldCBjbG9zZXN0Q2VsbCA9IG51bGw7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBudWxsO1xuICAgICAgICBjb25zdCBtZXRyaWMgPSAoYSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKGEueCAtIHBvc194KSwgTWF0aC5hYnMoYS55IC0gcG9zX3kpKSArXG4gICAgICAgICAgICAgICAgKGEueSAhPT0gcG9zX3kgPyAwLjUgOiAwKSArXG4gICAgICAgICAgICAgICAgKGEueCA9PT0gcG9zX3ggJiYgYS55ID09PSBwb3NfeSA/IDAgOiAxKSArXG4gICAgICAgICAgICAgICAgKGlzX2xlZnQgPyAoYS54IDwgcG9zX3ggPyAwIDogMSkgOiAoYS54ID4gcG9zX3ggPyAwIDogMC41KSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1pbl94ID0gTWF0aC5tYXgoMCwgcG9zX3ggLSBtYXhfZGlzdGFuY2UpO1xuICAgICAgICBjb25zdCBtYXhfeCA9IE1hdGgubWluKHRoaXMuZHVuZ2Vvbi53aWR0aCAtIDEsIHBvc194ICsgbWF4X2Rpc3RhbmNlKTtcbiAgICAgICAgY29uc3QgbWluX3kgPSBNYXRoLm1heCgwLCBwb3NfeSAtIG1heF9kaXN0YW5jZSk7XG4gICAgICAgIGNvbnN0IG1heF95ID0gTWF0aC5taW4odGhpcy5kdW5nZW9uLndpZHRoIC0gMSwgcG9zX3kgKyBtYXhfZGlzdGFuY2UpO1xuICAgICAgICBmb3IgKGxldCB4ID0gbWluX3g7IHggPD0gbWF4X3g7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IG1pbl95OyB5IDw9IG1heF95OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5kdW5nZW9uLmNlbGwoeCwgeSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuaGFzRmxvb3IgJiYgcHJlZGljYXRlKGNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gbWV0cmljKGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdERpc3RhbmNlID09PSBudWxsIHx8IGNsb3Nlc3REaXN0YW5jZSA+IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0Q2VsbCA9IGNlbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvc2VzdENlbGw7XG4gICAgfVxuICAgIG1vdmUobXgsIG15KSB7XG4gICAgICAgIGlmIChteCA+IDApXG4gICAgICAgICAgICB0aGlzLnZpZXcuaXNfbGVmdCA9IGZhbHNlO1xuICAgICAgICBpZiAobXggPCAwKVxuICAgICAgICAgICAgdGhpcy52aWV3LmlzX2xlZnQgPSB0cnVlO1xuICAgICAgICBjb25zdCBuZXdfeCA9IHRoaXMueCArIG14O1xuICAgICAgICBjb25zdCBuZXdfeSA9IHRoaXMueSArIG15O1xuICAgICAgICBpZiAodGhpcy5kdW5nZW9uLmF2YWlsYWJsZShuZXdfeCwgbmV3X3ksIHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bihuZXdfeCwgbmV3X3kpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZFBhdGgoY2hhcmFjdGVyKSB7XG4gICAgICAgIGNvbnN0IGR1bmdlb24gPSB0aGlzLmR1bmdlb247XG4gICAgICAgIGNvbnN0IHBmID0gbmV3IFBhdGhGaW5kaW5nKGR1bmdlb24ud2lkdGgsIGR1bmdlb24uaGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBkdW5nZW9uLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGR1bmdlb24ud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBkdW5nZW9uLmNlbGwoeCwgeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGNlbGwub2JqZWN0O1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLmhhc0Zsb29yICYmICghY2VsbC5jb2xsaWRlKHRoaXMpIHx8IG0gPT09IGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcGYuY2xlYXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZi5tYXJrKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBQSVhJLlBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IFBJWEkuUG9pbnQoY2hhcmFjdGVyLngsIGNoYXJhY3Rlci55KTtcbiAgICAgICAgcmV0dXJuIHBmLmZpbmQoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGlkbGUoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IElkbGVBbmltYXRpb24odGhpcywgdGhpcy5kdW5nZW9uLnRpY2tlciwge1xuICAgICAgICAgICAgc3ByaXRlOiB0aGlzLmNoYXJhY3Rlci5uYW1lICsgJ19pZGxlJyxcbiAgICAgICAgICAgIHNwZWVkOiB0aGlzLmNoYXJhY3Rlci5zcGVlZCxcbiAgICAgICAgICAgIHVwZGF0ZTogKGFuaW1hdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbihmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5pc2g6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aW9uKHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWRsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bihuZXdfeCwgbmV3X3kpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgUnVuQW5pbWF0aW9uKHRoaXMsIHRoaXMuZHVuZ2Vvbi50aWNrZXIsIHtcbiAgICAgICAgICAgIG5ld194OiBuZXdfeCxcbiAgICAgICAgICAgIG5ld195OiBuZXdfeSxcbiAgICAgICAgICAgIHNwcml0ZTogdGhpcy5jaGFyYWN0ZXIubmFtZSArICdfcnVuJyxcbiAgICAgICAgICAgIHNwZWVkOiB0aGlzLmNoYXJhY3Rlci5zcGVlZCxcbiAgICAgICAgICAgIGZpbmlzaDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY3Rpb24odHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGl0KCkge1xuICAgICAgICBjb25zdCB3ZWFwb24gPSB0aGlzLmNoYXJhY3Rlci53ZWFwb247XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEhpdEFuaW1hdGlvbih0aGlzLCB0aGlzLmR1bmdlb24udGlja2VyLCB7XG4gICAgICAgICAgICBzcHJpdGU6IHRoaXMuY2hhcmFjdGVyLm5hbWUgKyAnX2lkbGUnLFxuICAgICAgICAgICAgc3BlZWQ6ICh3ZWFwb24gPT09IG51bGwgfHwgd2VhcG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3ZWFwb24uc3BlZWQpIHx8IHRoaXMuY2hhcmFjdGVyLnNwZWVkLFxuICAgICAgICAgICAgY3VydmU6IHdlYXBvbiA9PT0gbnVsbCB8fCB3ZWFwb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdlYXBvbi5jdXJ2ZSxcbiAgICAgICAgICAgIGZpbmlzaDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbkhpdCgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY3Rpb24odHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldFBvc2l0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy5kdW5nZW9uLnJlbW92ZSh0aGlzLl94LCB0aGlzLl95LCB0aGlzKTtcbiAgICAgICAgdGhpcy5feCA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmZsb29yKHkpO1xuICAgICAgICB0aGlzLmR1bmdlb24uc2V0KHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMpO1xuICAgICAgICB0aGlzLnZpZXcuc2V0UG9zaXRpb24oeCwgeSk7XG4gICAgfVxuICAgIGxvb2tBdChjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGNoYXJhY3Rlci54IDwgdGhpcy54KVxuICAgICAgICAgICAgdGhpcy52aWV3LmlzX2xlZnQgPSB0cnVlO1xuICAgICAgICBpZiAoY2hhcmFjdGVyLnggPiB0aGlzLngpXG4gICAgICAgICAgICB0aGlzLnZpZXcuaXNfbGVmdCA9IGZhbHNlO1xuICAgIH1cbiAgICBzY2FuT2JqZWN0cyhkaXJlY3Rpb24sIG1heF9kaXN0YW5jZSwgcHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSB0aGlzLnNjYW5DZWxscyhkaXJlY3Rpb24sIG1heF9kaXN0YW5jZSwgY2VsbCA9PiBjZWxsLmhhc09iamVjdCAmJiBwcmVkaWNhdGUoY2VsbC5vYmplY3QpKVxuICAgICAgICAgICAgLm1hcChjZWxsID0+IGNlbGwub2JqZWN0KTtcbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldChvYmplY3RzKTtcbiAgICAgICAgcmV0dXJuIFsuLi5zZXRdO1xuICAgIH1cbiAgICBzY2FuQ2VsbHMoZGlyZWN0aW9uLCBtYXhfZGlzdGFuY2UsIHByZWRpY2F0ZSkge1xuICAgICAgICBjb25zdCBwb3NfeCA9IHRoaXMueDtcbiAgICAgICAgY29uc3QgcG9zX3kgPSB0aGlzLnk7XG4gICAgICAgIGNvbnN0IHNjYW5fbGVmdCA9IGRpcmVjdGlvbiA9PT0gU2NhbkRpcmVjdGlvbi5BUk9VTkQgfHwgZGlyZWN0aW9uID09PSBTY2FuRGlyZWN0aW9uLkxFRlQ7XG4gICAgICAgIGNvbnN0IHNjYW5fcmlnaHQgPSBkaXJlY3Rpb24gPT09IFNjYW5EaXJlY3Rpb24uQVJPVU5EIHx8IGRpcmVjdGlvbiA9PT0gU2NhbkRpcmVjdGlvbi5SSUdIVDtcbiAgICAgICAgY29uc3Qgc2Nhbl94X21pbiA9IHNjYW5fbGVmdCA/IE1hdGgubWF4KDAsIHBvc194IC0gbWF4X2Rpc3RhbmNlKSA6IHBvc194O1xuICAgICAgICBjb25zdCBzY2FuX3hfbWF4ID0gc2Nhbl9yaWdodCA/IE1hdGgubWluKHRoaXMuZHVuZ2Vvbi53aWR0aCAtIDEsIHBvc194ICsgbWF4X2Rpc3RhbmNlKSA6IHBvc194O1xuICAgICAgICBjb25zdCBzY2FuX3lfbWluID0gTWF0aC5tYXgoMCwgcG9zX3kgLSBtYXhfZGlzdGFuY2UpO1xuICAgICAgICBjb25zdCBzY2FuX3lfbWF4ID0gTWF0aC5taW4odGhpcy5kdW5nZW9uLmhlaWdodCAtIDEsIHBvc195ICsgbWF4X2Rpc3RhbmNlKTtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgc195ID0gc2Nhbl95X21pbjsgc195IDw9IHNjYW5feV9tYXg7IHNfeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzX3ggPSBzY2FuX3hfbWluOyBzX3ggPD0gc2Nhbl94X21heDsgc194KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5kdW5nZW9uLmNlbGwoc194LCBzX3kpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoY2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH1cbiAgICByYXljYXN0SXNWaXNpYmxlKHgxLCB5MSkge1xuICAgICAgICBsZXQgeDAgPSB0aGlzLng7XG4gICAgICAgIGxldCB5MCA9IHRoaXMueTtcbiAgICAgICAgY29uc3QgZHggPSBNYXRoLmFicyh4MSAtIHgwKTtcbiAgICAgICAgY29uc3QgZHkgPSBNYXRoLmFicyh5MSAtIHkwKTtcbiAgICAgICAgY29uc3Qgc3ggPSB4MCA8IHgxID8gMSA6IC0xO1xuICAgICAgICBjb25zdCBzeSA9IHkwIDwgeTEgPyAxIDogLTE7XG4gICAgICAgIGxldCBlcnIgPSAoZHggPiBkeSA/IGR4IDogLWR5KSAvIDI7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoeDAgPT09IHgxICYmIHkwID09PSB5MSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBlMiA9IGVycjtcbiAgICAgICAgICAgIGlmIChlMiA+IC1keCkge1xuICAgICAgICAgICAgICAgIGVyciAtPSBkeTtcbiAgICAgICAgICAgICAgICB4MCArPSBzeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlMiA8IGR5KSB7XG4gICAgICAgICAgICAgICAgZXJyICs9IGR4O1xuICAgICAgICAgICAgICAgIHkwICs9IHN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHgwID09PSB4MSAmJiB5MCA9PT0geTEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5kdW5nZW9uLmNlbGwoeDAsIHkwKTtcbiAgICAgICAgICAgIGlmICghY2VsbC5oYXNGbG9vcilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2VsbC5jb2xsaWRlKHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFyYWN0ZXIsIHRpY2tlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9zcHJpdGVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5fc3ByaXRlUGxheSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuICAgICAgICB0aGlzLnZpZXcgPSBjaGFyYWN0ZXIudmlldztcbiAgICAgICAgdGhpcy50aWNrZXIgPSB0aWNrZXI7XG4gICAgICAgIHRoaXMuc3ByaXRlID0gb3B0aW9ucy5zcHJpdGU7XG4gICAgICAgIHRoaXMuc3BlZWQgPSBvcHRpb25zLnNwZWVkO1xuICAgICAgICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZSB8fCBMaW5lYXJDdXJ2ZS5saW5lKCk7XG4gICAgICAgIHRoaXMub25fc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IG51bGw7XG4gICAgICAgIHRoaXMub25fdXBkYXRlID0gb3B0aW9ucy51cGRhdGUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5vbl9mcmFtZSA9IG9wdGlvbnMuZnJhbWUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5vbl9jYW5jZWwgPSBvcHRpb25zLmNhbmNlbCB8fCBudWxsO1xuICAgICAgICB0aGlzLm9uX2ZpbmlzaCA9IG9wdGlvbnMuZmluaXNoO1xuICAgIH1cbiAgICBnZXQgc3ByaXRlVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nwcml0ZVRpbWU7XG4gICAgfVxuICAgIHJ1bigpIHtcbiAgICAgICAgdGhpcy5fc3ByaXRlUGxheSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB0aGlzLnRpY2tlci5hZGQodGhpcy50aWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMub25fc3RhcnQpXG4gICAgICAgICAgICB0aGlzLm9uX3N0YXJ0KHRoaXMpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsZWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uX2NhbmNlbClcbiAgICAgICAgICAgICAgICB0aGlzLm9uX2NhbmNlbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aWNrKGRlbHRhVGltZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNwcml0ZShkZWx0YVRpbWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5vbl91cGRhdGUpXG4gICAgICAgICAgICB0aGlzLm9uX3VwZGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXJtaW5hdGVkICYmICF0aGlzLl9zcHJpdGVQbGF5KSB7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uX2ZpbmlzaClcbiAgICAgICAgICAgICAgICB0aGlzLm9uX2ZpbmlzaCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMuY2hhcmFjdGVyLmFuaW1hdGlvbiAhPT0gdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGVybWluYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50aWNrZXIucmVtb3ZlKHRoaXMudGljaywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3ByaXRlKGRlbHRhVGltZSkge1xuICAgICAgICBjb25zdCBzcHJpdGUgPSB0aGlzLnZpZXcuc3ByaXRlO1xuICAgICAgICBpZiAoIXNwcml0ZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwibm8gc3ByaXRlIGZvdW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVQbGF5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IHNwcml0ZS5hbmltYXRpb25TcGVlZCAqIGRlbHRhVGltZTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNGcmFtZSA9IHNwcml0ZS5jdXJyZW50RnJhbWU7XG4gICAgICAgIHRoaXMuX3Nwcml0ZVRpbWUgKz0gZWxhcHNlZDtcbiAgICAgICAgbGV0IGN1cnJlbnRGcmFtZSA9IE1hdGguZmxvb3IodGhpcy5fc3ByaXRlVGltZSkgJSBzcHJpdGUudG90YWxGcmFtZXM7XG4gICAgICAgIGlmIChjdXJyZW50RnJhbWUgPCAwKSB7XG4gICAgICAgICAgICBjdXJyZW50RnJhbWUgKz0gc3ByaXRlLnRvdGFsRnJhbWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zcHJpdGVUaW1lIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlVGltZSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVQbGF5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc3ByaXRlVGltZSA+PSBzcHJpdGUudG90YWxGcmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVRpbWUgPSBzcHJpdGUudG90YWxGcmFtZXMgLSAxO1xuICAgICAgICAgICAgdGhpcy5fc3ByaXRlUGxheSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzRnJhbWUgIT09IGN1cnJlbnRGcmFtZSkge1xuICAgICAgICAgICAgc3ByaXRlLmdvdG9BbmRTdG9wKGN1cnJlbnRGcmFtZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vbl9mcmFtZSlcbiAgICAgICAgICAgICAgICB0aGlzLm9uX2ZyYW1lKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIElkbGVBbmltYXRpb24gZXh0ZW5kcyBBbmltYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJhY3RlciwgdGlja2VyLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGNoYXJhY3RlciwgdGlja2VyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMudmlldy5zZXRTcHJpdGUodGhpcy5zcHJpdGUsIHRoaXMuc3BlZWQpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICB9XG4gICAgY2FuY2VsZWQoKSB7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1bkFuaW1hdGlvbiBleHRlbmRzIEFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY2hhcmFjdGVyLCB0aWNrZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY2hhcmFjdGVyLCB0aWNrZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnggPSBjaGFyYWN0ZXIueDtcbiAgICAgICAgdGhpcy55ID0gY2hhcmFjdGVyLnk7XG4gICAgICAgIHRoaXMubmV3X3ggPSBvcHRpb25zLm5ld194O1xuICAgICAgICB0aGlzLm5ld195ID0gb3B0aW9ucy5uZXdfeTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMudmlldy5zZXRTcHJpdGUodGhpcy5zcHJpdGUsIHRoaXMuc3BlZWQpO1xuICAgICAgICB0aGlzLmNoYXJhY3Rlci5kdW5nZW9uLnNldCh0aGlzLm5ld194LCB0aGlzLm5ld195LCB0aGlzLmNoYXJhY3Rlcik7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLnNwcml0ZVRpbWUgLyB0aGlzLnZpZXcuc3ByaXRlLnRvdGFsRnJhbWVzO1xuICAgICAgICBjb25zdCBwb3NfeCA9IHRoaXMueCArICh0aGlzLm5ld194IC0gdGhpcy54KSAqIGRlbHRhO1xuICAgICAgICBjb25zdCBwb3NfeSA9IHRoaXMueSArICh0aGlzLm5ld195IC0gdGhpcy55KSAqIGRlbHRhO1xuICAgICAgICB0aGlzLmNoYXJhY3Rlci52aWV3LnNldFBvc2l0aW9uKHBvc194LCBwb3NfeSk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIuZHVuZ2Vvbi5yZW1vdmUodGhpcy54LCB0aGlzLnksIHRoaXMuY2hhcmFjdGVyKTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIuZHVuZ2Vvbi5yZW1vdmUodGhpcy5uZXdfeCwgdGhpcy5uZXdfeSwgdGhpcy5jaGFyYWN0ZXIpO1xuICAgICAgICB0aGlzLmNoYXJhY3Rlci5zZXRQb3NpdGlvbih0aGlzLm5ld194LCB0aGlzLm5ld195KTtcbiAgICB9XG4gICAgY2FuY2VsZWQoKSB7XG4gICAgICAgIHRoaXMuY2hhcmFjdGVyLmR1bmdlb24ucmVtb3ZlKHRoaXMueCwgdGhpcy55LCB0aGlzLmNoYXJhY3Rlcik7XG4gICAgICAgIHRoaXMuY2hhcmFjdGVyLmR1bmdlb24ucmVtb3ZlKHRoaXMubmV3X3gsIHRoaXMubmV3X3ksIHRoaXMuY2hhcmFjdGVyKTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIuc2V0UG9zaXRpb24odGhpcy5jaGFyYWN0ZXIueCwgdGhpcy5jaGFyYWN0ZXIueSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEhpdEFuaW1hdGlvbiBleHRlbmRzIEFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY2hhcmFjdGVyLCB0aWNrZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY2hhcmFjdGVyLCB0aWNrZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy52aWV3LnNldFNwcml0ZSh0aGlzLnNwcml0ZSwgdGhpcy5zcGVlZCk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgd2VhcG9uID0gdGhpcy52aWV3LndlYXBvblNwcml0ZTtcbiAgICAgICAgaWYgKHdlYXBvbikge1xuICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gdGhpcy52aWV3LnNwcml0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5fc3ByaXRlVGltZSAvIHNwcml0ZS50b3RhbEZyYW1lcztcbiAgICAgICAgICAgIGNvbnN0IGN1cnZlRGVsdGEgPSB0aGlzLmN1cnZlKGRlbHRhKTtcbiAgICAgICAgICAgIHdlYXBvbi5hbmdsZSA9ICh0aGlzLnZpZXcuaXNfbGVmdCA/IC05MCA6IDkwKSAqIGN1cnZlRGVsdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBjb25zdCB3ZWFwb24gPSB0aGlzLnZpZXcud2VhcG9uU3ByaXRlO1xuICAgICAgICBpZiAod2VhcG9uKSB7XG4gICAgICAgICAgICB3ZWFwb24uYW5nbGUgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbGVkKCkge1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCYXNlQ2hhcmFjdGVyVmlldyBleHRlbmRzIFBJWEkuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihkdW5nZW9uLCB6SW5kZXgsIGdyaWRfd2lkdGgsIG9uX3Bvc2l0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2lzX2xlZnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3ByaXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2VhcG9uU3ByaXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMgPSBkdW5nZW9uLmNvbnRyb2xsZXIucmVzb3VyY2VzO1xuICAgICAgICB0aGlzLmJhc2VfekluZGV4ID0gekluZGV4O1xuICAgICAgICB0aGlzLmdyaWRfd2lkdGggPSBncmlkX3dpZHRoO1xuICAgICAgICB0aGlzLm9uX3Bvc2l0aW9uID0gb25fcG9zaXRpb24gfHwgbnVsbDtcbiAgICAgICAgZHVuZ2Vvbi5jb250YWluZXIuYWRkQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIGdldCBpc19sZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNfbGVmdDtcbiAgICB9XG4gICAgc2V0IGlzX2xlZnQoaXNfbGVmdCkge1xuICAgICAgICB0aGlzLl9pc19sZWZ0ID0gaXNfbGVmdDtcbiAgICAgICAgdGhpcy51cGRhdGVTcHJpdGVPcmllbnRhdGlvbigpO1xuICAgICAgICB0aGlzLnVwZGF0ZVdlYXBvbk9yaWVudGF0aW9uKCk7XG4gICAgfVxuICAgIGdldCBzcHJpdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcHJpdGU7XG4gICAgfVxuICAgIGdldCB3ZWFwb25TcHJpdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWFwb25TcHJpdGU7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYSA9IHRoaXMuX3Nwcml0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fc3ByaXRlID0gbnVsbDtcbiAgICAgICAgKF9iID0gdGhpcy5fd2VhcG9uU3ByaXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl93ZWFwb25TcHJpdGUgPSBudWxsO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHNldFBvc2l0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5zZXQoeCAqIFRJTEVfU0laRSwgeSAqIFRJTEVfU0laRSk7XG4gICAgICAgIHRoaXMuekluZGV4ID0gdGhpcy5iYXNlX3pJbmRleCArIE1hdGguZmxvb3IoeSkgKiBEdW5nZW9uWkluZGV4ZXMucm93O1xuICAgICAgICBpZiAodGhpcy5vbl9wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vbl9wb3NpdGlvbih4ICogVElMRV9TSVpFLCB5ICogVElMRV9TSVpFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTcHJpdGUobmFtZSwgc3BlZWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLl9zcHJpdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3Nwcml0ZSA9IHRoaXMucmVzb3VyY2VzLmFuaW1hdGVkKG5hbWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc3ByaXRlLmxvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3ByaXRlLmFuaW1hdGlvblNwZWVkID0gMC4yICogc3BlZWQ7XG4gICAgICAgIHRoaXMuX3Nwcml0ZS5hbmNob3Iuc2V0KDAsIDEpO1xuICAgICAgICB0aGlzLl9zcHJpdGUucG9zaXRpb24ueSA9IFRJTEVfU0laRSAtIDI7XG4gICAgICAgIHRoaXMuX3Nwcml0ZS56SW5kZXggPSAxO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuX3Nwcml0ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlU3ByaXRlT3JpZW50YXRpb24oKTtcbiAgICAgICAgdGhpcy51cGRhdGVXZWFwb25PcmllbnRhdGlvbigpO1xuICAgIH1cbiAgICBzZXRXZWFwb24od2VhcG9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fd2VhcG9uU3ByaXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl93ZWFwb25TcHJpdGUgPSBudWxsO1xuICAgICAgICBpZiAod2VhcG9uKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWFwb25TcHJpdGUgPSB3ZWFwb24uc3ByaXRlKCk7XG4gICAgICAgICAgICB0aGlzLl93ZWFwb25TcHJpdGUuekluZGV4ID0gMjtcbiAgICAgICAgICAgIHRoaXMuX3dlYXBvblNwcml0ZS5wb3NpdGlvbi54ID0gVElMRV9TSVpFO1xuICAgICAgICAgICAgdGhpcy5fd2VhcG9uU3ByaXRlLnBvc2l0aW9uLnkgPSBUSUxFX1NJWkUgLSA0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfbGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYXBvblNwcml0ZS5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWFwb25TcHJpdGUuc2NhbGUueCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fd2VhcG9uU3ByaXRlLmFuY2hvci5zZXQoMC41LCAxKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5fd2VhcG9uU3ByaXRlKTtcbiAgICAgICAgICAgIHRoaXMuc29ydENoaWxkcmVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3ByaXRlT3JpZW50YXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9zcHJpdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc19sZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlLnBvc2l0aW9uLnggPSB0aGlzLl9zcHJpdGUud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nwcml0ZS53aWR0aCA+IHRoaXMuZ3JpZF93aWR0aCAqIFRJTEVfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGUucG9zaXRpb24ueCAtPSAodGhpcy5fc3ByaXRlLndpZHRoIC0gdGhpcy5ncmlkX3dpZHRoICogVElMRV9TSVpFKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS5zY2FsZS54ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGUucG9zaXRpb24ueCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nwcml0ZS53aWR0aCA+IHRoaXMuZ3JpZF93aWR0aCAqIFRJTEVfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGUucG9zaXRpb24ueCAtPSAodGhpcy5fc3ByaXRlLndpZHRoIC0gdGhpcy5ncmlkX3dpZHRoICogVElMRV9TSVpFKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS5zY2FsZS54ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVXZWFwb25PcmllbnRhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlYXBvblNwcml0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfbGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYXBvblNwcml0ZS5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWFwb25TcHJpdGUuc2NhbGUueCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2VhcG9uU3ByaXRlLnBvc2l0aW9uLnggPSBUSUxFX1NJWkU7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2VhcG9uU3ByaXRlLnNjYWxlLnggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29sb3JzLCBTaXplcyB9IGZyb20gXCIuL3VpXCI7XG5pbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCI7XG5jb25zdCBCQVJfSEVJR0hUID0gMTg7XG5leHBvcnQgY2xhc3MgQmFyVmlldyBleHRlbmRzIFBJWEkuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgICAgICAgdGhpcy5fd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDA7XG4gICAgICAgIHRoaXMuX3dpZHRoTWF4ID0gb3B0aW9ucy53aWR0aE1heDtcbiAgICAgICAgdGhpcy5fcmVjdCA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuX2xhYmVsQ2VudGVyID0gb3B0aW9ucy5sYWJlbENlbnRlciB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGFiZWwgPSBuZXcgUElYSS5CaXRtYXBUZXh0KFwiXCIsIHsgZm9udDogeyBuYW1lOiBcImFsYWdhcmRcIiwgc2l6ZTogMTYgfSB9KTtcbiAgICAgICAgdGhpcy5fbGFiZWwuYW5jaG9yID0gbmV3IFBJWEkuUG9pbnQodGhpcy5fbGFiZWxDZW50ZXIgPyAwLjUgOiAwLCAwLjUpO1xuICAgICAgICB0aGlzLl9sYWJlbC5wb3NpdGlvbi5zZXQoKFNpemVzLnVpQm9yZGVyIDw8IDEpICsgKHRoaXMuX2xhYmVsQ2VudGVyID8gdGhpcy5fd2lkdGhNYXggPj4gMSA6IDApLCBTaXplcy51aUJvcmRlciArIChCQVJfSEVJR0hUID4+IDEpKTtcbiAgICAgICAgc3VwZXIuYWRkQ2hpbGQodGhpcy5fcmVjdCwgdGhpcy5fbGFiZWwpO1xuICAgIH1cbiAgICBzZXQgY29sb3IoY29sb3IpIHtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy51cGRhdGVSZWN0KCk7XG4gICAgfVxuICAgIHNldCB3aWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnVwZGF0ZVJlY3QoKTtcbiAgICB9XG4gICAgc2V0IGxhYmVsKHRleHQpIHtcbiAgICAgICAgdGhpcy5fbGFiZWwudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIHNldCB3aWR0aE1heCh3aWR0aE1heCkge1xuICAgICAgICB0aGlzLl93aWR0aE1heCA9IHdpZHRoTWF4O1xuICAgICAgICB0aGlzLl9sYWJlbC5wb3NpdGlvbi5zZXQoKFNpemVzLnVpQm9yZGVyIDw8IDEpICsgKHRoaXMuX2xhYmVsQ2VudGVyID8gdGhpcy5fd2lkdGhNYXggPj4gMSA6IDApLCBTaXplcy51aUJvcmRlciArIChCQVJfSEVJR0hUID4+IDEpKTtcbiAgICAgICAgdGhpcy51cGRhdGVSZWN0KCk7XG4gICAgfVxuICAgIHVwZGF0ZVJlY3QoKSB7XG4gICAgICAgIHRoaXMuX3JlY3QuY2xlYXIoKVxuICAgICAgICAgICAgLmJlZ2luRmlsbChDb2xvcnMudWlCYWNrZ3JvdW5kLCAwLjMpXG4gICAgICAgICAgICAuZHJhd1JlY3QoMCwgMCwgdGhpcy5fd2lkdGhNYXggKyAoU2l6ZXMudWlCb3JkZXIgPDwgMSksIEJBUl9IRUlHSFQgKyAoU2l6ZXMudWlCb3JkZXIgPDwgMSkpXG4gICAgICAgICAgICAuZW5kRmlsbCgpXG4gICAgICAgICAgICAuYmVnaW5GaWxsKHRoaXMuX2NvbG9yLCAwLjMpXG4gICAgICAgICAgICAuZHJhd1JlY3QoU2l6ZXMudWlCb3JkZXIsIFNpemVzLnVpQm9yZGVyLCB0aGlzLl93aWR0aCwgQkFSX0hFSUdIVClcbiAgICAgICAgICAgIC5lbmRGaWxsKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSGVybywgSGVyb0FJIH0gZnJvbSBcIi4vaGVyb1wiO1xuaW1wb3J0IHsgQmFzZUNoYXJhY3RlckFJLCBDaGFyYWN0ZXIsIElkbGVBbmltYXRpb24sIFNjYW5EaXJlY3Rpb24gfSBmcm9tIFwiLi9jaGFyYWN0ZXJcIjtcbmV4cG9ydCB2YXIgTW9uc3RlckNhdGVnb3J5O1xuKGZ1bmN0aW9uIChNb25zdGVyQ2F0ZWdvcnkpIHtcbiAgICBNb25zdGVyQ2F0ZWdvcnlbTW9uc3RlckNhdGVnb3J5W1wiREVNT05cIl0gPSAxXSA9IFwiREVNT05cIjtcbiAgICBNb25zdGVyQ2F0ZWdvcnlbTW9uc3RlckNhdGVnb3J5W1wiWk9NQklFXCJdID0gMl0gPSBcIlpPTUJJRVwiO1xuICAgIE1vbnN0ZXJDYXRlZ29yeVtNb25zdGVyQ2F0ZWdvcnlbXCJPUkNcIl0gPSAzXSA9IFwiT1JDXCI7XG4gICAgTW9uc3RlckNhdGVnb3J5W01vbnN0ZXJDYXRlZ29yeVtcIlNMSU1FXCJdID0gNF0gPSBcIlNMSU1FXCI7XG4gICAgTW9uc3RlckNhdGVnb3J5W01vbnN0ZXJDYXRlZ29yeVtcIlVOREVBRFwiXSA9IDVdID0gXCJVTkRFQURcIjtcbn0pKE1vbnN0ZXJDYXRlZ29yeSB8fCAoTW9uc3RlckNhdGVnb3J5ID0ge30pKTtcbmV4cG9ydCB2YXIgTW9uc3RlclR5cGU7XG4oZnVuY3Rpb24gKE1vbnN0ZXJUeXBlKSB7XG4gICAgTW9uc3RlclR5cGVbTW9uc3RlclR5cGVbXCJOT1JNQUxcIl0gPSAxXSA9IFwiTk9STUFMXCI7XG4gICAgTW9uc3RlclR5cGVbTW9uc3RlclR5cGVbXCJMRUFERVJcIl0gPSAyXSA9IFwiTEVBREVSXCI7XG4gICAgTW9uc3RlclR5cGVbTW9uc3RlclR5cGVbXCJNSU5JT05cIl0gPSAzXSA9IFwiTUlOSU9OXCI7XG59KShNb25zdGVyVHlwZSB8fCAoTW9uc3RlclR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBNb25zdGVyU3RhdGU7XG4oZnVuY3Rpb24gKE1vbnN0ZXJTdGF0ZSkge1xuICAgIE1vbnN0ZXJTdGF0ZVtNb25zdGVyU3RhdGVbXCJSRUFEWVwiXSA9IDBdID0gXCJSRUFEWVwiO1xuICAgIE1vbnN0ZXJTdGF0ZVtNb25zdGVyU3RhdGVbXCJBTEFSTVwiXSA9IDFdID0gXCJBTEFSTVwiO1xufSkoTW9uc3RlclN0YXRlIHx8IChNb25zdGVyU3RhdGUgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIE1vbnN0ZXJDaGFyYWN0ZXIgZXh0ZW5kcyBDaGFyYWN0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBvcHRpb25zLmxldmVsO1xuICAgICAgICB0aGlzLmx1Y2sgPSBvcHRpb25zLmx1Y2s7XG4gICAgICAgIHRoaXMuYmFzZURhbWFnZSA9IG9wdGlvbnMuYmFzZURhbWFnZTtcbiAgICAgICAgdGhpcy54cCA9IG9wdGlvbnMueHA7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBvcHRpb25zLmNhdGVnb3J5O1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICAgIHRoaXMuc3Bhd24gPSBvcHRpb25zLnNwYXduO1xuICAgICAgICB0aGlzLndlYXBvbiA9IG9wdGlvbnMud2VhcG9uO1xuICAgIH1cbiAgICBnZXQgZGFtYWdlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VEYW1hZ2UgKyAoKChfYSA9IHRoaXMud2VhcG9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGFtYWdlKSB8fCAwKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTW9uc3RlckFJIGV4dGVuZHMgQmFzZUNoYXJhY3RlckFJIHtcbiAgICBjb25zdHJ1Y3RvcihkdW5nZW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGR1bmdlb24sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gTW9uc3RlclN0YXRlLlJFQURZO1xuICAgICAgICB0aGlzLmxhc3RfcGF0aCA9IFtdO1xuICAgICAgICB0aGlzLnNwYXduZWQgPSBbXTtcbiAgICB9XG4gICAgaW50ZXJhY3QoKSB7XG4gICAgfVxuICAgIG9uS2lsbGVkQnkoYnkpIHtcbiAgICAgICAgaWYgKGJ5ICYmIGJ5IGluc3RhbmNlb2YgSGVybykge1xuICAgICAgICAgICAgdGhpcy5kdW5nZW9uLmxvZyhgJHt0aGlzLmNoYXJhY3Rlci5uYW1lfSBraWxsZWQgYnkgJHtieS5uYW1lfWApO1xuICAgICAgICAgICAgYnkuYWRkWHAodGhpcy5jaGFyYWN0ZXIueHApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRGVhZCgpIHtcbiAgICAgICAgdGhpcy5kcm9wKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICByZWFkeSgpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBNb25zdGVyU3RhdGUuUkVBRFk7XG4gICAgfVxuICAgIHNlbmRBbGFybShoZXJvKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gTW9uc3RlclN0YXRlLkFMQVJNO1xuICAgICAgICBmb3IgKGNvbnN0IG1vbnN0ZXIgb2YgdGhpcy5zY2FuTW9uc3RlcnMoU2NhbkRpcmVjdGlvbi5BUk9VTkQsIHRoaXMubWF4X2Rpc3RhbmNlKSkge1xuICAgICAgICAgICAgbW9uc3Rlci5hbGFybShoZXJvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhbGFybShoZXJvKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGFyYWN0ZXIuZGVhZC5nZXQoKSAmJlxuICAgICAgICAgICAgdGhpcy5jaGFyYWN0ZXIudHlwZSAhPT0gTW9uc3RlclR5cGUuTEVBREVSICYmXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gTW9uc3RlclN0YXRlLlJFQURZICYmXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiBpbnN0YW5jZW9mIElkbGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKGhlcm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICByYW5kb21Nb3ZlKCkge1xuICAgICAgICBjb25zdCByYW5kb21fbW92ZV9wZXJjZW50ID0gMC4xO1xuICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHJhbmRvbV9tb3ZlX3BlcmNlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVfeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMpIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVfeSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMpIC0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vdmUobW92ZV94LCBtb3ZlX3kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb3ZlVG9IZXJvKCkge1xuICAgICAgICBjb25zdCBbaGVyb10gPSB0aGlzLnNjYW5IZXJvKFNjYW5EaXJlY3Rpb24uQVJPVU5ELCB0aGlzLm1heF9kaXN0YW5jZSk7XG4gICAgICAgIGlmIChoZXJvKSB7XG4gICAgICAgICAgICB0aGlzLmxvb2tBdChoZXJvKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZEFsYXJtKGhlcm8pO1xuICAgICAgICAgICAgY29uc3QgZGlzdF94ID0gTWF0aC5hYnModGhpcy54IC0gaGVyby54KTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RfeSA9IE1hdGguYWJzKHRoaXMueSAtIGhlcm8ueSk7XG4gICAgICAgICAgICBpZiAoZGlzdF94ID4gdGhpcy53aWR0aCB8fCBkaXN0X3kgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmVUbyhoZXJvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2hhcmFjdGVyLmx1Y2sgPCB0aGlzLmR1bmdlb24ucm5nLm5leHRGbG9hdCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vdmVUbyhjaGFyYWN0ZXIpIHtcbiAgICAgICAgdGhpcy5sYXN0X3BhdGggPSB0aGlzLmZpbmRQYXRoKGNoYXJhY3Rlcik7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVCeVBhdGgoKTtcbiAgICB9XG4gICAgbW92ZUJ5UGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdF9wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmxhc3RfcGF0aFswXTtcbiAgICAgICAgICAgIGNvbnN0IGRfeCA9IG5leHQueCAtIHRoaXMueDtcbiAgICAgICAgICAgIGNvbnN0IGRfeSA9IG5leHQueSAtIHRoaXMueTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vdmUoZF94LCBkX3kpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0X3BhdGguc3BsaWNlKDAsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0X3BhdGggPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2NhbkhpdCgpIHtcbiAgICAgICAgY29uc3Qgd2VhcG9uID0gdGhpcy5jaGFyYWN0ZXIud2VhcG9uO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLnZpZXcuaXNfbGVmdCA/IFNjYW5EaXJlY3Rpb24uTEVGVCA6IFNjYW5EaXJlY3Rpb24uUklHSFQ7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gKHdlYXBvbiA9PT0gbnVsbCB8fCB3ZWFwb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdlYXBvbi5kaXN0YW5jZSkgfHwgMTtcbiAgICAgICAgY29uc3QgaGVyb2VzID0gdGhpcy5zY2FuSGVybyhkaXJlY3Rpb24sIGRpc3RhbmNlKTtcbiAgICAgICAgZm9yIChjb25zdCBoZXJvIG9mIGhlcm9lcykge1xuICAgICAgICAgICAgaGVyby5jaGFyYWN0ZXIuaGl0RGFtYWdlKHRoaXMuY2hhcmFjdGVyLCB0aGlzLmNoYXJhY3Rlci5kYW1hZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNwYXduTWluaW9ucygpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3Bhd25lZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3Bhd25lZFtpXS5jaGFyYWN0ZXIuZGVhZC5nZXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Bhd25lZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3Bhd25lZC5sZW5ndGggPCB0aGlzLmNoYXJhY3Rlci5zcGF3bikge1xuICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5maW5kU3Bhd25DZWxsKCk7XG4gICAgICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHNwYXduIGNlbGwgbm90IGZvdW5kIGF0ICR7dGhpcy54fToke3RoaXMueX1gLCB0aGlzLmNoYXJhY3Rlci5jYXRlZ29yeSwgdGhpcy5jaGFyYWN0ZXIudHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluaW9uID0gdGhpcy5zcGF3bk1pbmlvbihjZWxsLngsIGNlbGwueSk7XG4gICAgICAgICAgICBpZiAobWluaW9uKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5vYmplY3QgPSBtaW5pb247XG4gICAgICAgICAgICAgICAgdGhpcy5zcGF3bmVkLnB1c2gobWluaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIm1pbmlvbiBub3Qgc3Bhd25lZFwiLCB0aGlzLmNoYXJhY3Rlci5jYXRlZ29yeSwgdGhpcy5jaGFyYWN0ZXIudHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2Nhbkhlcm8oZGlyZWN0aW9uLCBtYXhfZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9iamVjdHMoZGlyZWN0aW9uLCBtYXhfZGlzdGFuY2UsIGMgPT4gYyBpbnN0YW5jZW9mIEhlcm9BSSlcbiAgICAgICAgICAgIC5maWx0ZXIobyA9PiB0aGlzLnJheWNhc3RJc1Zpc2libGUoby54LCBvLnkpKTtcbiAgICB9XG4gICAgc2Nhbk1vbnN0ZXJzKGRpcmVjdGlvbiwgbWF4X2Rpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYW5PYmplY3RzKGRpcmVjdGlvbiwgbWF4X2Rpc3RhbmNlLCBjID0+IGMgaW5zdGFuY2VvZiBNb25zdGVyQUkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEludmVudG9yeSB9IGZyb20gXCIuL2ludmVudG9yeVwiO1xuaW1wb3J0IHsgQmFzZUNoYXJhY3RlckFJLCBDaGFyYWN0ZXIsIElkbGVBbmltYXRpb24sIFNjYW5EaXJlY3Rpb24gfSBmcm9tIFwiLi9jaGFyYWN0ZXJcIjtcbmltcG9ydCB7IER1bmdlb25aSW5kZXhlcyB9IGZyb20gXCIuL2R1bmdlb24ubWFwXCI7XG5pbXBvcnQgeyBXZWFwb24gfSBmcm9tIFwiLi9kcm9wXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlVmFyIH0gZnJvbSBcIi4vb2JzZXJ2YWJsZVwiO1xuaW1wb3J0IHsgQmFyVmlldyB9IGZyb20gXCIuL2Jhci52aWV3XCI7XG5pbXBvcnQgeyBDb2xvcnMsIFNpemVzIH0gZnJvbSBcIi4vdWlcIjtcbmltcG9ydCB7IE1vbnN0ZXJBSSB9IGZyb20gXCIuL21vbnN0ZXJcIjtcbmltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIjtcbmV4cG9ydCBjb25zdCBoZXJvQ2hhcmFjdGVyTmFtZXMgPSBbXG4gICAgXCJlbGZfZlwiLFxuICAgIFwiZWxmX21cIixcbiAgICBcImtuaWdodF9mXCIsXG4gICAgXCJrbmlnaHRfbVwiLFxuICAgIFwid2l6YXJkX2ZcIixcbiAgICBcIndpemFyZF9tXCIsXG5dO1xuY29uc3QgZGVmYXVsdEdsb2JhbFN0YXRlID0ge1xuICAgIGNvaW5zOiAwLFxuICAgIGJhc2VEYW1hZ2U6IDMsXG4gICAgbGV2ZWw6IDEsXG4gICAgbGV2ZWxYcDogMCxcbiAgICBza2lsbFBvaW50czogMCxcbiAgICB4cDogMCxcbiAgICBoZWFsdGhNYXg6IDMwLFxuICAgIHNwZWVkOiAxLFxufTtcbmV4cG9ydCBjbGFzcyBIZXJvIGV4dGVuZHMgQ2hhcmFjdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzdGF0ZSwgcGVyc2lzdGVudCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgc3BlZWQ6IHN0YXRlLnNwZWVkLFxuICAgICAgICAgICAgaGVhbHRoTWF4OiBzdGF0ZS5oZWFsdGhNYXhcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW52ZW50b3J5ID0gbmV3IEludmVudG9yeSh0aGlzKTtcbiAgICAgICAgdGhpcy5kdW5nZW9uU2VlZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYm9uZmlyZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucGVyc2lzdGVudCA9IHBlcnNpc3RlbnQ7XG4gICAgICAgIHRoaXMuX2NvaW5zID0gbmV3IE9ic2VydmFibGVWYXIoc3RhdGUuY29pbnMpO1xuICAgICAgICB0aGlzLl9iYXNlRGFtYWdlID0gbmV3IE9ic2VydmFibGVWYXIoc3RhdGUuYmFzZURhbWFnZSk7XG4gICAgICAgIHRoaXMuX2xldmVsID0gbmV3IE9ic2VydmFibGVWYXIoc3RhdGUubGV2ZWwpO1xuICAgICAgICB0aGlzLl9sZXZlbFhwID0gbmV3IE9ic2VydmFibGVWYXIoc3RhdGUubGV2ZWxYcCk7XG4gICAgICAgIHRoaXMuX3NraWxsUG9pbnRzID0gbmV3IE9ic2VydmFibGVWYXIoc3RhdGUuc2tpbGxQb2ludHMpO1xuICAgICAgICB0aGlzLl94cCA9IG5ldyBPYnNlcnZhYmxlVmFyKHN0YXRlLnhwKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgZ2V0IGNvaW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29pbnM7XG4gICAgfVxuICAgIGFkZENvaW5zKGNvaW5zKSB7XG4gICAgICAgIHRoaXMuX2NvaW5zLnVwZGF0ZShjID0+IGMgKyBjb2lucyk7XG4gICAgfVxuICAgIGdldCBkYW1hZ2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VEYW1hZ2UuZ2V0KCkgKyAoKChfYSA9IHRoaXMud2VhcG9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGFtYWdlKSB8fCAwKTtcbiAgICB9XG4gICAgZ2V0IHdlYXBvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52ZW50b3J5LmVxdWlwbWVudC53ZWFwb24uaXRlbS5nZXQoKSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgbGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICB9XG4gICAgZ2V0IGxldmVsWHAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZXZlbFhwO1xuICAgIH1cbiAgICBnZXQgc2tpbGxQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9za2lsbFBvaW50cztcbiAgICB9XG4gICAgZ2V0IHhwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feHA7XG4gICAgfVxuICAgIGFkZFhwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3hwLnVwZGF0ZSgodikgPT4ge1xuICAgICAgICAgICAgbGV0IG5ld1hwID0gdiArIHZhbHVlO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZXZlbFhwID0gdGhpcy5fbGV2ZWxYcC5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3WHAgPj0gbGV2ZWxYcCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdYcCA9IG5ld1hwIC0gbGV2ZWxYcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWwudXBkYXRlKCh2KSA9PiB2ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsWHAudXBkYXRlKCh2KSA9PiB2ICsgMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NraWxsUG9pbnRzLnVwZGF0ZSgodikgPT4gdiArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1hwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jcmVhc2VIZWFsdGgoKSB7XG4gICAgICAgIHRoaXMuX3NraWxsUG9pbnRzLnVwZGF0ZSgocG9pbnRzKSA9PiB7XG4gICAgICAgICAgICBpZiAocG9pbnRzID4gMCkge1xuICAgICAgICAgICAgICAgIHBvaW50cy0tO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWx0aE1heC51cGRhdGUoKGgpID0+IGggKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFsdGgudXBkYXRlKChoKSA9PiBoICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLl9jb2lucy5zdWJzY3JpYmUodGhpcy5zYXZlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fYmFzZURhbWFnZS5zdWJzY3JpYmUodGhpcy5zYXZlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbGV2ZWwuc3Vic2NyaWJlKHRoaXMuc2F2ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2xldmVsWHAuc3Vic2NyaWJlKHRoaXMuc2F2ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3NraWxsUG9pbnRzLnN1YnNjcmliZSh0aGlzLnNhdmUsIHRoaXMpO1xuICAgICAgICB0aGlzLl94cC5zdWJzY3JpYmUodGhpcy5zYXZlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5faGVhbHRoTWF4LnN1YnNjcmliZSh0aGlzLnNhdmUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9zcGVlZC5zdWJzY3JpYmUodGhpcy5zYXZlLCB0aGlzKTtcbiAgICB9XG4gICAgc2F2ZSgpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50Lmdsb2JhbC5zYXZlKHRoaXMubmFtZSwgdGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvaW5zOiB0aGlzLl9jb2lucy5nZXQoKSxcbiAgICAgICAgICAgIGJhc2VEYW1hZ2U6IHRoaXMuX2Jhc2VEYW1hZ2UuZ2V0KCksXG4gICAgICAgICAgICBsZXZlbDogdGhpcy5fbGV2ZWwuZ2V0KCksXG4gICAgICAgICAgICBsZXZlbFhwOiB0aGlzLl9sZXZlbFhwLmdldCgpLFxuICAgICAgICAgICAgc2tpbGxQb2ludHM6IHRoaXMuX3NraWxsUG9pbnRzLmdldCgpLFxuICAgICAgICAgICAgeHA6IHRoaXMuX3hwLmdldCgpLFxuICAgICAgICAgICAgaGVhbHRoTWF4OiB0aGlzLl9oZWFsdGhNYXguZ2V0KCksXG4gICAgICAgICAgICBzcGVlZDogdGhpcy5fc3BlZWQuZ2V0KCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkKG5hbWUsIHBlcnNpc3RlbnQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gcGVyc2lzdGVudC5nbG9iYWwubG9hZChuYW1lKSB8fCBkZWZhdWx0R2xvYmFsU3RhdGU7XG4gICAgICAgIHJldHVybiBuZXcgSGVybyhuYW1lLCBzdGF0ZSwgcGVyc2lzdGVudCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEhlcm9BSSBleHRlbmRzIEJhc2VDaGFyYWN0ZXJBSSB7XG4gICAgY29uc3RydWN0b3IoY2hhcmFjdGVyLCBkdW5nZW9uLCB4LCB5KSB7XG4gICAgICAgIHN1cGVyKGR1bmdlb24sIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICB6SW5kZXg6IER1bmdlb25aSW5kZXhlcy5oZXJvLFxuICAgICAgICAgICAgb25fcG9zaXRpb246IGR1bmdlb24uY2FtZXJhLmJpbmQoZHVuZ2VvbiksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIuaW52ZW50b3J5LmVxdWlwbWVudC53ZWFwb24uaXRlbS5zdWJzY3JpYmUodGhpcy5vbldlYXBvblVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuY2hhcmFjdGVyLmludmVudG9yeS5kcm9wLnN1YnNjcmliZSh0aGlzLm9uRHJvcCwgdGhpcyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIuaW52ZW50b3J5LmVxdWlwbWVudC53ZWFwb24uaXRlbS51bnN1YnNjcmliZSh0aGlzLm9uV2VhcG9uVXBkYXRlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIuaW52ZW50b3J5LmRyb3AudW5zdWJzY3JpYmUodGhpcy5vbkRyb3AsIHRoaXMpO1xuICAgIH1cbiAgICBpbnRlcmFjdCgpIHtcbiAgICB9XG4gICAgb25LaWxsZWRCeShieSkge1xuICAgICAgICB0aGlzLmR1bmdlb24ubG9nKGAke3RoaXMuY2hhcmFjdGVyLm5hbWV9IGtpbGxlZCBieSAke2J5Lm5hbWV9YCk7XG4gICAgfVxuICAgIG9uRGVhZCgpIHtcbiAgICAgICAgdGhpcy5kdW5nZW9uLmNvbnRyb2xsZXIuZGVhZCgpO1xuICAgIH1cbiAgICBvbkRyb3AoZXZlbnQpIHtcbiAgICAgICAgbGV0IFtkcm9wXSA9IGV2ZW50O1xuICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5maW5kRHJvcENlbGwoKTtcbiAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgIGNlbGwuZHJvcEl0ZW0gPSBkcm9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uV2VhcG9uVXBkYXRlKHdlYXBvbikge1xuICAgICAgICB0aGlzLnZpZXcuc2V0V2VhcG9uKHdlYXBvbik7XG4gICAgfVxuICAgIGFjdGlvbihmaW5pc2hlZCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hhcmFjdGVyLmRlYWQuZ2V0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkbGUgPSB0aGlzLmFuaW1hdGlvbiBpbnN0YW5jZW9mIElkbGVBbmltYXRpb247XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5Ecm9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBqb3lzdGljayA9IHRoaXMuZHVuZ2Vvbi5jb250cm9sbGVyLmpveXN0aWNrO1xuICAgICAgICAgICAgaWYgKGlkbGUgJiYgam95c3RpY2suaW52ZW50b3J5Lm9uY2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHVuZ2Vvbi5jb250cm9sbGVyLnNob3dJbnZlbnRvcnkodGhpcy5jaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaWRsZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gOTsgZCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlnaXQgPSAoZCArIDEpICUgMTA7XG4gICAgICAgICAgICAgICAgaWYgKGpveXN0aWNrLmRpZ2l0KGRpZ2l0KS5vbmNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY2hhcmFjdGVyLmludmVudG9yeS5iZWx0LmNlbGwoZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBjZWxsLml0ZW0uZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtICYmIChpdGVtIGluc3RhbmNlb2YgV2VhcG9uIHx8IGlkbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnVzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkbGUgJiYgam95c3RpY2suZHJvcC5vbmNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJhY3Rlci5pbnZlbnRvcnkuZXF1aXBtZW50LndlYXBvbi5kcm9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWRsZSB8fCBmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJlZCA9IGpveXN0aWNrLmhpdC50cmlnZ2VyZWQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25jZSA9IGpveXN0aWNrLmhpdC5vbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy52aWV3LmlzX2xlZnQgPyBTY2FuRGlyZWN0aW9uLkxFRlQgOiBTY2FuRGlyZWN0aW9uLlJJR0hUO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbb2JqZWN0XSA9IHRoaXMuc2NhbkludGVyYWN0aW5nKGRpcmVjdGlvbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWRsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmludGVyYWN0KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJlZCB8fCBvbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9va0F0TW9uc3RlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkbGUgfHwgZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkX3ggPSBIZXJvQUkuZGVsdGEoam95c3RpY2subW92ZUxlZnQsIGpveXN0aWNrLm1vdmVSaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZF95ID0gSGVyb0FJLmRlbHRhKGpveXN0aWNrLm1vdmVVcCwgam95c3RpY2subW92ZURvd24pO1xuICAgICAgICAgICAgICAgIGlmIChkX3ggIT09IDAgfHwgZF95ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vdmUoZF94LCBkX3kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRpYyBkZWx0YShhLCBiKSB7XG4gICAgICAgIGlmIChhLnRyaWdnZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIudHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW5Ecm9wKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmR1bmdlb24uY2VsbCh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGlmICgoX2EgPSBjZWxsLmRyb3ApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5waWNrZWRVcCh0aGlzLmNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIFBJWEkuc291bmQucGxheSgnZnJ1aXRfY29sbGVjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW5IaXQoKSB7XG4gICAgICAgIGNvbnN0IHdlYXBvbiA9IHRoaXMuY2hhcmFjdGVyLndlYXBvbjtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSAod2VhcG9uID09PSBudWxsIHx8IHdlYXBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2VhcG9uLmRpc3RhbmNlKSB8fCAxO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLnZpZXcuaXNfbGVmdCA/IFNjYW5EaXJlY3Rpb24uTEVGVCA6IFNjYW5EaXJlY3Rpb24uUklHSFQ7XG4gICAgICAgIGNvbnN0IG1vbnN0ZXJzID0gdGhpcy5zY2FuTW9uc3RlcnMoZGlyZWN0aW9uLCBkaXN0YW5jZSk7XG4gICAgICAgIGZvciAobGV0IG1vbnN0ZXIgb2YgbW9uc3RlcnMpIHtcbiAgICAgICAgICAgIG1vbnN0ZXIuY2hhcmFjdGVyLmhpdERhbWFnZSh0aGlzLmNoYXJhY3RlciwgdGhpcy5jaGFyYWN0ZXIuZGFtYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9uc3RlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgUElYSS5zb3VuZC5wbGF5KCdoaXRfZGFtYWdlJywgeyBzcGVlZDogKHdlYXBvbiA9PT0gbnVsbCB8fCB3ZWFwb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdlYXBvbi5zcGVlZCkgfHwgMSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb29rQXRNb25zdGVycygpIHtcbiAgICAgICAgY29uc3Qgd2VhcG9uID0gdGhpcy5jaGFyYWN0ZXIud2VhcG9uO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9ICh3ZWFwb24gPT09IG51bGwgfHwgd2VhcG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3ZWFwb24uZGlzdGFuY2UpIHx8IDE7XG4gICAgICAgIGNvbnN0IGxlZnRIZWFsdGhTdW0gPSB0aGlzLm1vbnN0ZXJzSGVhbHRoKFNjYW5EaXJlY3Rpb24uTEVGVCwgZGlzdGFuY2UpO1xuICAgICAgICBjb25zdCByaWdodEhlYWx0aFN1bSA9IHRoaXMubW9uc3RlcnNIZWFsdGgoU2NhbkRpcmVjdGlvbi5SSUdIVCwgZGlzdGFuY2UpO1xuICAgICAgICBpZiAobGVmdEhlYWx0aFN1bSA+IDAgJiYgbGVmdEhlYWx0aFN1bSA+IHJpZ2h0SGVhbHRoU3VtKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuaXNfbGVmdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmlnaHRIZWFsdGhTdW0gPiAwICYmIHJpZ2h0SGVhbHRoU3VtID4gbGVmdEhlYWx0aFN1bSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmlzX2xlZnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuSW50ZXJhY3RpbmcoZGlyZWN0aW9uLCBtYXhfZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNlbGxzKGRpcmVjdGlvbiwgbWF4X2Rpc3RhbmNlLCBjID0+IGMuaW50ZXJhY3RpbmcpO1xuICAgIH1cbiAgICBzY2FuTW9uc3RlcnMoZGlyZWN0aW9uLCBtYXhfZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9iamVjdHMoZGlyZWN0aW9uLCBtYXhfZGlzdGFuY2UsIGMgPT4gYyBpbnN0YW5jZW9mIE1vbnN0ZXJBSSk7XG4gICAgfVxuICAgIG1vbnN0ZXJzSGVhbHRoKGRpcmVjdGlvbiwgbWF4X2Rpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYW5Nb25zdGVycyhkaXJlY3Rpb24sIG1heF9kaXN0YW5jZSkubWFwKG0gPT4gbS5jaGFyYWN0ZXIuaGVhbHRoLmdldCgpKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSGVyb1N0YXRlVmlldyBleHRlbmRzIFBJWEkuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihoZXJvU3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maXhlZEhQU2l6ZSA9IG9wdGlvbnMuZml4ZWRIUFNpemU7XG4gICAgICAgIHRoaXMuaHBCYXJTaXplID0gb3B0aW9ucy5ocEJhclNpemUgfHwgODtcbiAgICAgICAgdGhpcy5tYXhCYXJTaXplID0gb3B0aW9ucy5tYXhCYXJTaXplIHx8IDI1NjtcbiAgICAgICAgdGhpcy5tYXhCYXJJbm5lclNpemUgPSB0aGlzLm1heEJhclNpemUgLSAoU2l6ZXMudWlCb3JkZXIgPDwgMSk7XG4gICAgICAgIGNvbnN0IGJhckhlaWdodCA9IDE4ICsgKFNpemVzLnVpQm9yZGVyIDw8IDEpO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gYmFySGVpZ2h0ICsgU2l6ZXMudWlNYXJnaW47XG4gICAgICAgIHRoaXMuaGVyb1N0YXRlID0gaGVyb1N0YXRlO1xuICAgICAgICB0aGlzLmhlYWx0aCA9IG5ldyBCYXJWaWV3KHtcbiAgICAgICAgICAgIGNvbG9yOiBDb2xvcnMudWlSZWQsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIHdpZHRoTWF4OiB0aGlzLm1heEJhcklubmVyU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy54cCA9IG5ldyBCYXJWaWV3KHtcbiAgICAgICAgICAgIGNvbG9yOiBDb2xvcnMudWlZZWxsb3csXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIHdpZHRoTWF4OiB0aGlzLm1heEJhcklubmVyU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy54cC5wb3NpdGlvbi5zZXQoMCwgb2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuY29pbnMgPSBuZXcgUElYSS5CaXRtYXBUZXh0KFwiXCIsIHsgZm9udDogeyBuYW1lOiBcImFsYWdhcmRcIiwgc2l6ZTogMTYgfSB9KTtcbiAgICAgICAgdGhpcy5jb2lucy5wb3NpdGlvbi5zZXQoMCwgb2Zmc2V0WSAqIDIpO1xuICAgICAgICBzdXBlci5hZGRDaGlsZCh0aGlzLmhlYWx0aCwgdGhpcy54cCwgdGhpcy5jb2lucyk7XG4gICAgICAgIGhlcm9TdGF0ZS5oZWFsdGguc3Vic2NyaWJlKHRoaXMudXBkYXRlSGVhbHRoLCB0aGlzKTtcbiAgICAgICAgaGVyb1N0YXRlLmhlYWx0aE1heC5zdWJzY3JpYmUodGhpcy51cGRhdGVIZWFsdGhNYXgsIHRoaXMpO1xuICAgICAgICBoZXJvU3RhdGUubGV2ZWwuc3Vic2NyaWJlKHRoaXMudXBkYXRlWHAsIHRoaXMpO1xuICAgICAgICBoZXJvU3RhdGUubGV2ZWxYcC5zdWJzY3JpYmUodGhpcy51cGRhdGVYcCwgdGhpcyk7XG4gICAgICAgIGhlcm9TdGF0ZS5za2lsbFBvaW50cy5zdWJzY3JpYmUodGhpcy51cGRhdGVYcCwgdGhpcyk7XG4gICAgICAgIGhlcm9TdGF0ZS54cC5zdWJzY3JpYmUodGhpcy51cGRhdGVYcCwgdGhpcyk7XG4gICAgICAgIGhlcm9TdGF0ZS5jb2lucy5zdWJzY3JpYmUodGhpcy51cGRhdGVDb2lucywgdGhpcyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5oZXJvU3RhdGUuaGVhbHRoLnVuc3Vic2NyaWJlKHRoaXMudXBkYXRlSGVhbHRoLCB0aGlzKTtcbiAgICAgICAgdGhpcy5oZXJvU3RhdGUuaGVhbHRoTWF4LnVuc3Vic2NyaWJlKHRoaXMudXBkYXRlSGVhbHRoTWF4LCB0aGlzKTtcbiAgICAgICAgdGhpcy5oZXJvU3RhdGUubGV2ZWwudW5zdWJzY3JpYmUodGhpcy51cGRhdGVYcCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGVyb1N0YXRlLmxldmVsWHAudW5zdWJzY3JpYmUodGhpcy51cGRhdGVYcCwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGVyb1N0YXRlLnNraWxsUG9pbnRzLnVuc3Vic2NyaWJlKHRoaXMudXBkYXRlWHAsIHRoaXMpO1xuICAgICAgICB0aGlzLmhlcm9TdGF0ZS54cC51bnN1YnNjcmliZSh0aGlzLnVwZGF0ZVhwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5oZXJvU3RhdGUuY29pbnMudW5zdWJzY3JpYmUodGhpcy51cGRhdGVDb2lucywgdGhpcyk7XG4gICAgfVxuICAgIHVwZGF0ZUhlYWx0aE1heChoZWFsdGhNYXgpIHtcbiAgICAgICAgY29uc3QgaGVhbHRoID0gdGhpcy5oZXJvU3RhdGUuaGVhbHRoLmdldCgpO1xuICAgICAgICBpZiAoIXRoaXMuZml4ZWRIUFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoLndpZHRoTWF4ID0gdGhpcy5ocEJhclNpemUgKiBoZWFsdGhNYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFsdGgubGFiZWwgPSBgJHtoZWFsdGh9LyR7aGVhbHRoTWF4fWA7XG4gICAgfVxuICAgIHVwZGF0ZUhlYWx0aChoZWFsdGgpIHtcbiAgICAgICAgY29uc3QgaGVhbHRoTWF4ID0gdGhpcy5oZXJvU3RhdGUuaGVhbHRoTWF4LmdldCgpO1xuICAgICAgICBpZiAodGhpcy5maXhlZEhQU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5oZWFsdGgud2lkdGggPSBNYXRoLmZsb29yKHRoaXMubWF4QmFySW5uZXJTaXplICogaGVhbHRoIC8gaGVhbHRoTWF4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoLndpZHRoID0gdGhpcy5ocEJhclNpemUgKiBoZWFsdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFsdGgubGFiZWwgPSBgJHtoZWFsdGh9LyR7aGVhbHRoTWF4fWA7XG4gICAgfVxuICAgIHVwZGF0ZVhwKCkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGVyb1N0YXRlLmxldmVsLmdldCgpO1xuICAgICAgICBjb25zdCBsZXZlbFhwID0gdGhpcy5oZXJvU3RhdGUubGV2ZWxYcC5nZXQoKTtcbiAgICAgICAgY29uc3Qgc2tpbGxQb2ludHMgPSB0aGlzLmhlcm9TdGF0ZS5za2lsbFBvaW50cy5nZXQoKTtcbiAgICAgICAgY29uc3QgeHAgPSB0aGlzLmhlcm9TdGF0ZS54cC5nZXQoKTtcbiAgICAgICAgdGhpcy54cC53aWR0aE1heCA9IHRoaXMubWF4QmFySW5uZXJTaXplO1xuICAgICAgICB0aGlzLnhwLndpZHRoID0gTWF0aC5mbG9vcih0aGlzLm1heEJhcklubmVyU2l6ZSAqIHhwIC8gbGV2ZWxYcCk7XG4gICAgICAgIHRoaXMueHAubGFiZWwgPSBgTDoke2xldmVsfSBYUDoke3hwfS8ke2xldmVsWHB9IFNQOiR7c2tpbGxQb2ludHN9YDtcbiAgICB9XG4gICAgdXBkYXRlQ29pbnMoY29pbnMpIHtcbiAgICAgICAgdGhpcy5jb2lucy50ZXh0ID0gYCQke2NvaW5zfWA7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRHVuZ2VvblpJbmRleGVzIH0gZnJvbSBcIi4vZHVuZ2Vvbi5tYXBcIjtcbmltcG9ydCB7IE1vbnN0ZXJBSSwgTW9uc3RlckNhdGVnb3J5LCBNb25zdGVyQ2hhcmFjdGVyLCBNb25zdGVyVHlwZSB9IGZyb20gXCIuL21vbnN0ZXJcIjtcbmltcG9ydCB7IFNjYW5EaXJlY3Rpb24gfSBmcm9tIFwiLi9jaGFyYWN0ZXJcIjtcbmltcG9ydCB7IG1vbnN0ZXJXZWFwb25zLCBXZWFwb24gfSBmcm9tIFwiLi9kcm9wXCI7XG5leHBvcnQgY29uc3QgdGlueU1vbnN0ZXJzID0gW1xuICAgIHsgbmFtZTogXCJjaG9ydFwiLCBjYXRlZ29yeTogTW9uc3RlckNhdGVnb3J5LkRFTU9OLCB0eXBlOiBNb25zdGVyVHlwZS5OT1JNQUwsIGx1Y2s6IDAuMywgd2VhcG9uczogW10gfSxcbiAgICB7IG5hbWU6IFwid29nb2xcIiwgY2F0ZWdvcnk6IE1vbnN0ZXJDYXRlZ29yeS5ERU1PTiwgdHlwZTogTW9uc3RlclR5cGUuTk9STUFMLCBsdWNrOiAwLjMsIHdlYXBvbnM6IFtdIH0sXG4gICAgeyBuYW1lOiBcImltcFwiLCBjYXRlZ29yeTogTW9uc3RlckNhdGVnb3J5LkRFTU9OLCB0eXBlOiBNb25zdGVyVHlwZS5OT1JNQUwsIGx1Y2s6IDAuMywgd2VhcG9uczogW10gfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiaWNlX3pvbWJpZVwiLFxuICAgICAgICBjYXRlZ29yeTogTW9uc3RlckNhdGVnb3J5LlpPTUJJRSxcbiAgICAgICAgdHlwZTogTW9uc3RlclR5cGUuTk9STUFMLFxuICAgICAgICBsdWNrOiAwLjMsXG4gICAgICAgIHdlYXBvbnM6IFttb25zdGVyV2VhcG9ucy5rbmlmZV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJ0aW55X3pvbWJpZVwiLFxuICAgICAgICBjYXRlZ29yeTogTW9uc3RlckNhdGVnb3J5LlpPTUJJRSxcbiAgICAgICAgdHlwZTogTW9uc3RlclR5cGUuTk9STUFMLFxuICAgICAgICBsdWNrOiAwLjMsXG4gICAgICAgIHdlYXBvbnM6IFttb25zdGVyV2VhcG9ucy5rbmlmZV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJ6b21iaWVcIixcbiAgICAgICAgY2F0ZWdvcnk6IE1vbnN0ZXJDYXRlZ29yeS5aT01CSUUsXG4gICAgICAgIHR5cGU6IE1vbnN0ZXJUeXBlLk5PUk1BTCxcbiAgICAgICAgbHVjazogMC4zLFxuICAgICAgICB3ZWFwb25zOiBbbW9uc3RlcldlYXBvbnMua25pZmVdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwib3JjX3NoYW1hblwiLFxuICAgICAgICBjYXRlZ29yeTogTW9uc3RlckNhdGVnb3J5Lk9SQyxcbiAgICAgICAgdHlwZTogTW9uc3RlclR5cGUuTEVBREVSLFxuICAgICAgICBsdWNrOiAwLjQsXG4gICAgICAgIHdlYXBvbnM6IFttb25zdGVyV2VhcG9ucy5rbmlmZV1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJtYXNrZWRfb3JjXCIsXG4gICAgICAgIGNhdGVnb3J5OiBNb25zdGVyQ2F0ZWdvcnkuT1JDLFxuICAgICAgICB0eXBlOiBNb25zdGVyVHlwZS5OT1JNQUwsXG4gICAgICAgIGx1Y2s6IDAuMyxcbiAgICAgICAgd2VhcG9uczogW21vbnN0ZXJXZWFwb25zLmtuaWZlXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIm9yY193YXJyaW9yXCIsXG4gICAgICAgIGNhdGVnb3J5OiBNb25zdGVyQ2F0ZWdvcnkuT1JDLFxuICAgICAgICB0eXBlOiBNb25zdGVyVHlwZS5NSU5JT04sXG4gICAgICAgIGx1Y2s6IDAuMyxcbiAgICAgICAgd2VhcG9uczogW21vbnN0ZXJXZWFwb25zLmtuaWZlXVxuICAgIH0sXG4gICAgeyBuYW1lOiBcImdvYmxpblwiLCBjYXRlZ29yeTogTW9uc3RlckNhdGVnb3J5Lk9SQywgdHlwZTogTW9uc3RlclR5cGUuTUlOSU9OLCBsdWNrOiAwLjMsIHdlYXBvbnM6IFttb25zdGVyV2VhcG9ucy5rbmlmZV0gfSxcbiAgICB7IG5hbWU6IFwic3dhbXB5XCIsIGNhdGVnb3J5OiBNb25zdGVyQ2F0ZWdvcnkuU0xJTUUsIHR5cGU6IE1vbnN0ZXJUeXBlLk5PUk1BTCwgbHVjazogMC4zLCB3ZWFwb25zOiBbXSB9LFxuICAgIHsgbmFtZTogXCJtdWRkeVwiLCBjYXRlZ29yeTogTW9uc3RlckNhdGVnb3J5LlNMSU1FLCB0eXBlOiBNb25zdGVyVHlwZS5OT1JNQUwsIGx1Y2s6IDAuMywgd2VhcG9uczogW10gfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwibmVjcm9tYW5jZXJcIixcbiAgICAgICAgY2F0ZWdvcnk6IE1vbnN0ZXJDYXRlZ29yeS5VTkRFQUQsXG4gICAgICAgIHR5cGU6IE1vbnN0ZXJUeXBlLkxFQURFUixcbiAgICAgICAgbHVjazogMC40LFxuICAgICAgICB3ZWFwb25zOiBbbW9uc3RlcldlYXBvbnMua25pZmVdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwic2tlbGV0b25cIixcbiAgICAgICAgY2F0ZWdvcnk6IE1vbnN0ZXJDYXRlZ29yeS5VTkRFQUQsXG4gICAgICAgIHR5cGU6IE1vbnN0ZXJUeXBlLk1JTklPTixcbiAgICAgICAgbHVjazogMC4zLFxuICAgICAgICB3ZWFwb25zOiBbbW9uc3RlcldlYXBvbnMua25pZmVdXG4gICAgfSxcbl07XG5leHBvcnQgY2xhc3MgVGlueU1vbnN0ZXIgZXh0ZW5kcyBNb25zdGVyQ2hhcmFjdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGxldmVsLCB3ZWFwb24pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogY29uZmlnLm5hbWUsXG4gICAgICAgICAgICBjYXRlZ29yeTogY29uZmlnLmNhdGVnb3J5LFxuICAgICAgICAgICAgdHlwZTogY29uZmlnLnR5cGUsXG4gICAgICAgICAgICBzcGVlZDogMC44LFxuICAgICAgICAgICAgaGVhbHRoTWF4OiAxMCArIE1hdGguZmxvb3IobGV2ZWwgKiAyKSxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgIGx1Y2s6IGNvbmZpZy5sdWNrLFxuICAgICAgICAgICAgYmFzZURhbWFnZTogMSArIDAuNSAqIGxldmVsLFxuICAgICAgICAgICAgeHA6IDM1ICsgNSAqIGxldmVsLFxuICAgICAgICAgICAgc3Bhd246IDMsXG4gICAgICAgICAgICB3ZWFwb246IHdlYXBvbixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRpbnlNb25zdGVyQUkgZXh0ZW5kcyBNb25zdGVyQUkge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgZHVuZ2VvbiwgeCwgeSkge1xuICAgICAgICBzdXBlcihkdW5nZW9uLCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgekluZGV4OiBEdW5nZW9uWkluZGV4ZXMuY2hhcmFjdGVyXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heF9kaXN0YW5jZSA9IDU7XG4gICAgICAgIGNvbnN0IHdlYXBvbiA9IGNvbmZpZy5sdWNrIDwgdGhpcy5kdW5nZW9uLnJuZy5uZXh0RmxvYXQoKSA/XG4gICAgICAgICAgICBXZWFwb24uc2VsZWN0KHRoaXMuZHVuZ2Vvbi5jb250cm9sbGVyLnJlc291cmNlcywgdGhpcy5kdW5nZW9uLnJuZywgY29uZmlnLndlYXBvbnMpIDogbnVsbDtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBuZXcgVGlueU1vbnN0ZXIoY29uZmlnLCBkdW5nZW9uLmxldmVsLCB3ZWFwb24pO1xuICAgICAgICB0aGlzLnZpZXcuc2V0V2VhcG9uKHRoaXMuY2hhcmFjdGVyLndlYXBvbik7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBhY3Rpb24oZmluaXNoZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYXJhY3Rlci5kZWFkLmdldCgpICYmIGZpbmlzaGVkKSB7XG4gICAgICAgICAgICBjb25zdCBsZWFkZXIgPSB0aGlzLmNoYXJhY3Rlci50eXBlID09PSBNb25zdGVyVHlwZS5MRUFERVI7XG4gICAgICAgICAgICBpZiAobGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Bhd25NaW5pb25zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb3ZlRnJvbUhlcm9PckF0dGFjaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb3ZlVG9IZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vdmVCeVBhdGgoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJhbmRvbU1vdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb3ZlRnJvbUhlcm9PckF0dGFjaygpIHtcbiAgICAgICAgY29uc3QgW2hlcm9dID0gdGhpcy5zY2FuSGVybyhTY2FuRGlyZWN0aW9uLkFST1VORCwgdGhpcy5tYXhfZGlzdGFuY2UpO1xuICAgICAgICBpZiAoaGVybykge1xuICAgICAgICAgICAgdGhpcy5sb29rQXQoaGVybyk7XG4gICAgICAgICAgICB0aGlzLnNlbmRBbGFybShoZXJvKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RfeCA9IE1hdGguYWJzKHRoaXMueCAtIGhlcm8ueCk7XG4gICAgICAgICAgICBjb25zdCBkaXN0X3kgPSBNYXRoLmFicyh0aGlzLnkgLSBoZXJvLnkpO1xuICAgICAgICAgICAgaWYgKGRpc3RfeCA+IHRoaXMud2lkdGggfHwgZGlzdF95ID4gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkeCA9IE1hdGgubWluKDEsIE1hdGgubWF4KC0xLCB0aGlzLnggLSBoZXJvLngpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkeSA9IE1hdGgubWluKDEsIE1hdGgubWF4KC0xLCB0aGlzLnkgLSBoZXJvLnkpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm1vdmUgZnJvbSBoZXJvXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmUoZHgsIGR5KSB8fCB0aGlzLm1vdmUoZHgsIDApIHx8IHRoaXMubW92ZSgwLCBkeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNoYXJhY3Rlci5sdWNrIDwgdGhpcy5kdW5nZW9uLnJuZy5uZXh0RmxvYXQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYXR0YWNrIGhlcm9cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5oaXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRyb3AoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCB0aGlzLmNoYXJhY3Rlci5sdWNrKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmZpbmREcm9wQ2VsbCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmFuZG9tRHJvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNwYXduTWluaW9uKHgsIHkpIHtcbiAgICAgICAgY29uc3QgbWluaW9ucyA9IHRpbnlNb25zdGVycy5maWx0ZXIoYyA9PiBjLmNhdGVnb3J5ID09PSB0aGlzLmNoYXJhY3Rlci5jYXRlZ29yeSAmJiBjLnR5cGUgPT09IE1vbnN0ZXJUeXBlLk1JTklPTik7XG4gICAgICAgIGlmIChtaW5pb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwibm8gbWluaW9uIGNvbmZpZyBmb3VuZFwiLCB0aGlzLmNoYXJhY3Rlci5jYXRlZ29yeSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmR1bmdlb24ucm5nLmNob2ljZShtaW5pb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW55TW9uc3RlckFJKGNvbmZpZywgdGhpcy5kdW5nZW9uLCB4LCB5KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEdW5nZW9uWkluZGV4ZXMgfSBmcm9tIFwiLi9kdW5nZW9uLm1hcFwiO1xuaW1wb3J0IHsgTW9uc3RlckFJLCBNb25zdGVyQ2F0ZWdvcnksIE1vbnN0ZXJDaGFyYWN0ZXIsIE1vbnN0ZXJUeXBlIH0gZnJvbSBcIi4vbW9uc3RlclwiO1xuaW1wb3J0IHsgVGlueU1vbnN0ZXJBSSwgdGlueU1vbnN0ZXJzIH0gZnJvbSBcIi4vdGlueS5tb25zdGVyXCI7XG5pbXBvcnQgeyBDb2xvcnMgfSBmcm9tIFwiLi91aVwiO1xuaW1wb3J0IHsgQmFyVmlldyB9IGZyb20gXCIuL2Jhci52aWV3XCI7XG5pbXBvcnQgeyBtb25zdGVyV2VhcG9ucywgV2VhcG9uIH0gZnJvbSBcIi4vZHJvcFwiO1xuaW1wb3J0ICogYXMgUElYSSBmcm9tICdwaXhpLmpzJztcbmV4cG9ydCBjb25zdCBib3NzTW9uc3RlcnMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiBcImJpZ196b21iaWVcIiwgY2F0ZWdvcnk6IE1vbnN0ZXJDYXRlZ29yeS5aT01CSUUsIHdlYXBvbnM6IFtcbiAgICAgICAgICAgIG1vbnN0ZXJXZWFwb25zLmFuaW1lX3N3b3JkLFxuICAgICAgICAgICAgbW9uc3RlcldlYXBvbnMuYmF0b25fd2l0aF9zcGlrZXMsXG4gICAgICAgICAgICBtb25zdGVyV2VhcG9ucy5iaWdfaGFtbWVyLFxuICAgICAgICAgICAgbW9uc3RlcldlYXBvbnMuY2xlYXZlcixcbiAgICAgICAgICAgIG1vbnN0ZXJXZWFwb25zLm1hY2UsXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHsgbmFtZTogXCJiaWdfZGVtb25cIiwgY2F0ZWdvcnk6IE1vbnN0ZXJDYXRlZ29yeS5ERU1PTiwgd2VhcG9uczogW10gfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwib2dyZVwiLCBjYXRlZ29yeTogTW9uc3RlckNhdGVnb3J5Lk9SQywgd2VhcG9uczogW1xuICAgICAgICAgICAgbW9uc3RlcldlYXBvbnMuYW5pbWVfc3dvcmQsXG4gICAgICAgICAgICBtb25zdGVyV2VhcG9ucy5iYXRvbl93aXRoX3NwaWtlcyxcbiAgICAgICAgICAgIG1vbnN0ZXJXZWFwb25zLmJpZ19oYW1tZXIsXG4gICAgICAgICAgICBtb25zdGVyV2VhcG9ucy5jbGVhdmVyLFxuICAgICAgICAgICAgbW9uc3RlcldlYXBvbnMubWFjZSxcbiAgICAgICAgXVxuICAgIH0sXG5dO1xuZXhwb3J0IGNsYXNzIEJvc3NNb25zdGVyIGV4dGVuZHMgTW9uc3RlckNoYXJhY3RlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBsZXZlbCwgd2VhcG9uKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6IGNvbmZpZy5uYW1lLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IGNvbmZpZy5jYXRlZ29yeSxcbiAgICAgICAgICAgIHR5cGU6IE1vbnN0ZXJUeXBlLkxFQURFUixcbiAgICAgICAgICAgIHNwZWVkOiAwLjUsXG4gICAgICAgICAgICBoZWFsdGhNYXg6IDUwICsgTWF0aC5mbG9vcihsZXZlbCAqIDEwKSxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgIGx1Y2s6IDAuNCxcbiAgICAgICAgICAgIGJhc2VEYW1hZ2U6IDUgKyAwLjUgKiBsZXZlbCxcbiAgICAgICAgICAgIHhwOiAxMDAgKyA1MCAqIGxldmVsLFxuICAgICAgICAgICAgc3Bhd246IDUsXG4gICAgICAgICAgICB3ZWFwb246IHdlYXBvbixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJvc3NNb25zdGVyQUkgZXh0ZW5kcyBNb25zdGVyQUkge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgZHVuZ2VvbiwgeCwgeSkge1xuICAgICAgICBzdXBlcihkdW5nZW9uLCB7XG4gICAgICAgICAgICB3aWR0aDogMixcbiAgICAgICAgICAgIGhlaWdodDogMixcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgekluZGV4OiBEdW5nZW9uWkluZGV4ZXMuY2hhcmFjdGVyXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heF9kaXN0YW5jZSA9IDc7XG4gICAgICAgIGNvbnN0IHdlYXBvbiA9IFdlYXBvbi5zZWxlY3QodGhpcy5kdW5nZW9uLmNvbnRyb2xsZXIucmVzb3VyY2VzLCB0aGlzLmR1bmdlb24ucm5nLCBjb25maWcud2VhcG9ucyk7XG4gICAgICAgIHRoaXMuY2hhcmFjdGVyID0gbmV3IEJvc3NNb25zdGVyKGNvbmZpZywgZHVuZ2Vvbi5sZXZlbCwgd2VhcG9uKTtcbiAgICAgICAgdGhpcy52aWV3LnNldFdlYXBvbih0aGlzLmNoYXJhY3Rlci53ZWFwb24pO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgY29uc3QgY193ID0gZHVuZ2Vvbi5jb250cm9sbGVyLmFwcC5zY3JlZW4ud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlYWx0aFZpZXcgPSBuZXcgQm9zc0hlYWx0aFZpZXcodGhpcy5jaGFyYWN0ZXIpO1xuICAgICAgICBoZWFsdGhWaWV3LnpJbmRleCA9IDEzO1xuICAgICAgICBoZWFsdGhWaWV3LnBvc2l0aW9uLnNldCgoY193ID4+IDEpLCA2NCk7XG4gICAgICAgIGR1bmdlb24uY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZChoZWFsdGhWaWV3KTtcbiAgICB9XG4gICAgYWN0aW9uKGZpbmlzaGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGFyYWN0ZXIuZGVhZC5nZXQoKSAmJiBmaW5pc2hlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3Bhd25NaW5pb25zKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tb3ZlVG9IZXJvKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1vdmVCeVBhdGgoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZG9tTW92ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkcm9wKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmZpbmREcm9wQ2VsbCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmFuZG9tRHJvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNwYXduTWluaW9uKHgsIHkpIHtcbiAgICAgICAgY29uc3QgbWluaW9ucyA9IHRpbnlNb25zdGVycy5maWx0ZXIoYyA9PiBjLmNhdGVnb3J5ID09PSB0aGlzLmNoYXJhY3Rlci5jYXRlZ29yeSAmJiBjLnR5cGUgIT09IE1vbnN0ZXJUeXBlLkxFQURFUik7XG4gICAgICAgIGlmIChtaW5pb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwibm8gbWluaW9uIGNvbmZpZyBmb3VuZFwiLCB0aGlzLmNoYXJhY3Rlci5jYXRlZ29yeSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmR1bmdlb24ucm5nLmNob2ljZShtaW5pb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW55TW9uc3RlckFJKGNvbmZpZywgdGhpcy5kdW5nZW9uLCB4LCB5KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQm9zc0hlYWx0aFZpZXcgZXh0ZW5kcyBQSVhJLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoYm9zcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJvc3MgPSBib3NzO1xuICAgICAgICBjb25zdCBIRUFMVEhfTUFYX1dJRFRIID0gNTAwO1xuICAgICAgICBjb25zdCBIRUFMVEhfV0lEVEggPSA0O1xuICAgICAgICB0aGlzLnBvaW50V2lkdGggPSBNYXRoLm1pbihIRUFMVEhfV0lEVEgsIE1hdGguZmxvb3IoSEVBTFRIX01BWF9XSURUSCAvIHRoaXMuYm9zcy5oZWFsdGhNYXguZ2V0KCkpKTtcbiAgICAgICAgdGhpcy53aWR0aE1heCA9IHRoaXMucG9pbnRXaWR0aCAqIHRoaXMuYm9zcy5oZWFsdGhNYXguZ2V0KCk7XG4gICAgICAgIHRoaXMuaGVhbHRoID0gbmV3IEJhclZpZXcoe1xuICAgICAgICAgICAgY29sb3I6IENvbG9ycy51aVJlZCxcbiAgICAgICAgICAgIHdpZHRoTWF4OiB0aGlzLndpZHRoTWF4LFxuICAgICAgICAgICAgbGFiZWxDZW50ZXI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGVhbHRoLnBvc2l0aW9uLnNldCgtKHRoaXMud2lkdGhNYXggPj4gMSksIDApO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuaGVhbHRoKTtcbiAgICAgICAgdGhpcy5ib3NzLmhlYWx0aC5zdWJzY3JpYmUodGhpcy51cGRhdGVIZWFsdGgsIHRoaXMpO1xuICAgICAgICB0aGlzLmJvc3MuZGVhZC5zdWJzY3JpYmUodGhpcy51cGRhdGVEZWFkLCB0aGlzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ib3NzLmhlYWx0aC51bnN1YnNjcmliZSh0aGlzLnVwZGF0ZUhlYWx0aCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmJvc3MuZGVhZC51bnN1YnNjcmliZSh0aGlzLnVwZGF0ZURlYWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5oZWFsdGguZGVzdHJveSgpO1xuICAgICAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUhlYWx0aChoZWFsdGgpIHtcbiAgICAgICAgdGhpcy5oZWFsdGgud2lkdGggPSB0aGlzLnBvaW50V2lkdGggKiBoZWFsdGg7XG4gICAgICAgIHRoaXMuaGVhbHRoLmxhYmVsID0gYCR7dGhpcy5ib3NzLm5hbWV9IC0gJHtoZWFsdGh9YDtcbiAgICB9XG4gICAgdXBkYXRlRGVhZChkZWFkKSB7XG4gICAgICAgIGlmIChkZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEJhc2VDaGFyYWN0ZXJBSSwgQ2hhcmFjdGVyIH0gZnJvbSBcIi4vY2hhcmFjdGVyXCI7XG5pbXBvcnQgeyBEdW5nZW9uWkluZGV4ZXMgfSBmcm9tIFwiLi9kdW5nZW9uLm1hcFwiO1xuaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiO1xuZXhwb3J0IGNsYXNzIE5wY1NraWxsIHtcbiAgICBjb25zdHJ1Y3RvcihucGMsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5ucGMgPSBucGM7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNlbGxpbmdTa2lsbCBleHRlbmRzIE5wY1NraWxsIHtcbiAgICBjb25zdHJ1Y3RvcihucGMsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3VwZXIobnBjLCBjb250cm9sbGVyKTtcbiAgICB9XG4gICAgdXNlKGhlcm8pIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnNob3dJbnZlbnRvcnkoaGVybywgdGhpcy5ucGMpO1xuICAgIH1cbn1cblNlbGxpbmdTa2lsbC5pZCA9ICdzZWxsaW5nJztcbmV4cG9ydCBjbGFzcyBIZWFsU2tpbGwgZXh0ZW5kcyBOcGNTa2lsbCB7XG4gICAgY29uc3RydWN0b3IobnBjLCBjb250cm9sbGVyKSB7XG4gICAgICAgIHN1cGVyKG5wYywgY29udHJvbGxlcik7XG4gICAgfVxuICAgIHVzZShoZXJvKSB7XG4gICAgICAgIFBJWEkuc291bmQucGxheSgnYmlnX2VnZ19jb2xsZWN0Jyk7XG4gICAgICAgIGhlcm8uaGVhbChoZXJvLmhlYWx0aE1heC5nZXQoKSk7XG4gICAgfVxufVxuSGVhbFNraWxsLmlkID0gJ2hlYWwnO1xuZXhwb3J0IGNvbnN0IG5wY0NoYXJhY3RlcnMgPSBbXG4gICAgeyBuYW1lOiBcImFsY2hlbWlzdFwiLCB3aWR0aDogMSwgaGVpZ2h0OiAxLCBza2lsbHM6IFtTZWxsaW5nU2tpbGwuaWRdIH0sXG4gICAgeyBuYW1lOiBcImFyY2hlclwiLCB3aWR0aDogMSwgaGVpZ2h0OiAxLCBza2lsbHM6IFtTZWxsaW5nU2tpbGwuaWRdIH0sXG4gICAgeyBuYW1lOiBcImJpc2hvcFwiLCB3aWR0aDogMSwgaGVpZ2h0OiAyLCBza2lsbHM6IFtdIH0sXG4gICAgeyBuYW1lOiBcImJsYWNrc21pdGhcIiwgd2lkdGg6IDEsIGhlaWdodDogMSwgc2tpbGxzOiBbU2VsbGluZ1NraWxsLmlkXSB9LFxuICAgIHsgbmFtZTogXCJidXRjaGVyXCIsIHdpZHRoOiAxLCBoZWlnaHQ6IDEsIHNraWxsczogW1NlbGxpbmdTa2lsbC5pZF0gfSxcbiAgICB7IG5hbWU6IFwiZWxpdGVfa25pZ2h0XCIsIHdpZHRoOiAxLCBoZWlnaHQ6IDEsIHNraWxsczogW10gfSxcbiAgICB7IG5hbWU6IFwiZXhlY3V0aW9uZXJcIiwgd2lkdGg6IDIsIGhlaWdodDogMiwgc2tpbGxzOiBbXSB9LFxuICAgIHsgbmFtZTogXCJmYXRfbnVuXCIsIHdpZHRoOiAxLCBoZWlnaHQ6IDEsIHNraWxsczogW0hlYWxTa2lsbC5pZF0gfSxcbiAgICB7IG5hbWU6IFwiaGVhdnlfa25pZ2h0XCIsIHdpZHRoOiAxLCBoZWlnaHQ6IDEsIHNraWxsczogW10gfSxcbiAgICB7IG5hbWU6IFwiaGVyYWxkXCIsIHdpZHRoOiAxLCBoZWlnaHQ6IDEsIHNraWxsczogW10gfSxcbiAgICB7IG5hbWU6IFwia2luZ1wiLCB3aWR0aDogMSwgaGVpZ2h0OiAxLCBza2lsbHM6IFtdIH0sXG4gICAgeyBuYW1lOiBcImtuaWdodFwiLCB3aWR0aDogMSwgaGVpZ2h0OiAxLCBza2lsbHM6IFtdIH0sXG4gICAgeyBuYW1lOiBcImxhcmdlX2VsaXRlX2tuaWdodFwiLCB3aWR0aDogMiwgaGVpZ2h0OiAyLCBza2lsbHM6IFtdIH0sXG4gICAgeyBuYW1lOiBcImxhcmdlX2tuaWdodFwiLCB3aWR0aDogMiwgaGVpZ2h0OiAyLCBza2lsbHM6IFtdIH0sXG4gICAgeyBuYW1lOiBcIm1hZ2VcIiwgd2lkdGg6IDEsIGhlaWdodDogMSwgc2tpbGxzOiBbU2VsbGluZ1NraWxsLmlkXSB9LFxuICAgIHsgbmFtZTogXCJtYWdpY19zaG9wX2tlZXBlclwiLCB3aWR0aDogMSwgaGVpZ2h0OiAxLCBza2lsbHM6IFtTZWxsaW5nU2tpbGwuaWRdIH0sXG4gICAgeyBuYW1lOiBcIm1lcmNoYW50XCIsIHdpZHRoOiAxLCBoZWlnaHQ6IDEsIHNraWxsczogW1NlbGxpbmdTa2lsbC5pZF0gfSxcbiAgICB7IG5hbWU6IFwibW91bnRhaW5fa2luZ1wiLCB3aWR0aDogMSwgaGVpZ2h0OiAxLCBza2lsbHM6IFtdIH0sXG4gICAgeyBuYW1lOiBcIm5vcm1hbF9udW5cIiwgd2lkdGg6IDEsIGhlaWdodDogMSwgc2tpbGxzOiBbSGVhbFNraWxsLmlkXSB9LFxuICAgIHsgbmFtZTogXCJwcmluY2Vzc1wiLCB3aWR0aDogMSwgaGVpZ2h0OiAxLCBza2lsbHM6IFtdIH0sXG4gICAgeyBuYW1lOiBcInF1ZWVuXCIsIHdpZHRoOiAxLCBoZWlnaHQ6IDEsIHNraWxsczogW10gfSxcbiAgICB7IG5hbWU6IFwic2tpbm55X251blwiLCB3aWR0aDogMSwgaGVpZ2h0OiAxLCBza2lsbHM6IFtIZWFsU2tpbGwuaWRdIH0sXG4gICAgeyBuYW1lOiBcInRoaWVmXCIsIHdpZHRoOiAxLCBoZWlnaHQ6IDEsIHNraWxsczogW1NlbGxpbmdTa2lsbC5pZF0gfSxcbiAgICB7IG5hbWU6IFwidG93bnNmb2xrX2ZcIiwgd2lkdGg6IDEsIGhlaWdodDogMSwgc2tpbGxzOiBbXSB9LFxuXTtcbmV4cG9ydCBjbGFzcyBOcGNDaGFyYWN0ZXIgZXh0ZW5kcyBDaGFyYWN0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHNwZWVkOiAxLFxuICAgICAgICAgICAgaGVhbHRoTWF4OiAxMDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSB7fTtcbiAgICAgICAgdGhpcy5fc2tpbGwgPSB7fTtcbiAgICAgICAgdGhpcy5kYW1hZ2UgPSAxO1xuICAgICAgICB0aGlzLndlYXBvbiA9IG51bGw7XG4gICAgfVxuICAgIHNldENvbnRleHQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0Q29udGV4dChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRba2V5XTtcbiAgICB9XG4gICAgaGFzU2tpbGwoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NraWxsLmhhc093blByb3BlcnR5KGlkKTtcbiAgICB9XG4gICAgZ2V0U2tpbGwoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NraWxsW2lkXSB8fCBudWxsO1xuICAgIH1cbiAgICBhZGRTa2lsbChpZCwgc2tpbGwpIHtcbiAgICAgICAgdGhpcy5fc2tpbGxbaWRdID0gc2tpbGw7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE5wY0FJIGV4dGVuZHMgQmFzZUNoYXJhY3RlckFJIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGR1bmdlb24sIGNvbnRyb2xsZXIsIHgsIHkpIHtcbiAgICAgICAgc3VwZXIoZHVuZ2Vvbiwge1xuICAgICAgICAgICAgd2lkdGg6IGNvbmZpZy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodCxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgekluZGV4OiBEdW5nZW9uWkluZGV4ZXMuY2hhcmFjdGVyXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmludGVyYWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBuZXcgTnBjQ2hhcmFjdGVyKGNvbmZpZy5uYW1lKTtcbiAgICAgICAgdGhpcy5pbml0U2tpbGxzKGNvbnRyb2xsZXIsIGNvbmZpZy5za2lsbHMpO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgaW5pdFNraWxscyhjb250cm9sbGVyLCBza2lsbHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBza2lsbHMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNlbGxpbmdTa2lsbC5pZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyYWN0ZXIuYWRkU2tpbGwoaWQsIG5ldyBTZWxsaW5nU2tpbGwodGhpcy5jaGFyYWN0ZXIsIGNvbnRyb2xsZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBIZWFsU2tpbGwuaWQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcmFjdGVyLmFkZFNraWxsKGlkLCBuZXcgSGVhbFNraWxsKHRoaXMuY2hhcmFjdGVyLCBjb250cm9sbGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9uRGVhZCgpIHtcbiAgICB9XG4gICAgb25LaWxsZWRCeShfYnkpIHtcbiAgICB9XG4gICAgYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNjYW5IaXQoKSB7XG4gICAgfVxuICAgIGludGVyYWN0KGhlcm8pIHtcbiAgICAgICAgdGhpcy5sb29rQXQoaGVybyk7XG4gICAgICAgIHRoaXMuZHVuZ2Vvbi5jb250cm9sbGVyLnNob3dEaWFsb2coaGVyby5jaGFyYWN0ZXIsIHRoaXMuY2hhcmFjdGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEdW5nZW9uWkluZGV4ZXMgfSBmcm9tIFwiLi9kdW5nZW9uLm1hcFwiO1xuaW1wb3J0IHsgTGlnaHRUeXBlIH0gZnJvbSBcIi4vZHVuZ2Vvbi5saWdodFwiO1xuaW1wb3J0IHsgQnV0dG9uLCBMYXlvdXQsIFNlbGVjdGFibGVHcmlkLCBTaXplcyB9IGZyb20gXCIuL3VpXCI7XG5pbXBvcnQgKiBhcyBQSVhJIGZyb20gJ3BpeGkuanMnO1xuY29uc3QgVElMRV9TSVpFID0gMTY7XG5leHBvcnQgdmFyIEJvbmZpcmVTdGF0ZTtcbihmdW5jdGlvbiAoQm9uZmlyZVN0YXRlKSB7XG4gICAgQm9uZmlyZVN0YXRlW0JvbmZpcmVTdGF0ZVtcIlVOTElUXCJdID0gMF0gPSBcIlVOTElUXCI7XG4gICAgQm9uZmlyZVN0YXRlW0JvbmZpcmVTdGF0ZVtcIkxJR0hUXCJdID0gMV0gPSBcIkxJR0hUXCI7XG4gICAgQm9uZmlyZVN0YXRlW0JvbmZpcmVTdGF0ZVtcIkxJVFwiXSA9IDJdID0gXCJMSVRcIjtcbn0pKEJvbmZpcmVTdGF0ZSB8fCAoQm9uZmlyZVN0YXRlID0ge30pKTtcbmV4cG9ydCBjbGFzcyBEdW5nZW9uQm9uZmlyZSB7XG4gICAgY29uc3RydWN0b3IoZHVuZ2VvbiwgeCwgeSwgbGlnaHQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IDE7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTtcbiAgICAgICAgdGhpcy5zdGF0aWMgPSB0cnVlO1xuICAgICAgICB0aGlzLmludGVyYWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kdW5nZW9uID0gZHVuZ2VvbjtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBCb25maXJlU3RhdGUuVU5MSVQ7XG4gICAgICAgIHRoaXMuX3Nwcml0ZSA9IHRoaXMuZHVuZ2Vvbi5hbmltYXRlZCh0aGlzLngsIHRoaXMueSwgYGJvbmZpcmVfdW5saXRgKTtcbiAgICAgICAgdGhpcy5fc3ByaXRlLnpJbmRleCA9IER1bmdlb25aSW5kZXhlcy5zdGF0aWMgKyB0aGlzLnkgKiBEdW5nZW9uWkluZGV4ZXMucm93O1xuICAgICAgICB0aGlzLmR1bmdlb24uc2V0KHRoaXMueCwgdGhpcy55LCB0aGlzKTtcbiAgICAgICAgaWYgKGxpZ2h0KVxuICAgICAgICAgICAgdGhpcy5saWdodCgpO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kdW5nZW9uLnJlbW92ZSh0aGlzLngsIHRoaXMueSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3Nwcml0ZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIGludGVyYWN0KGhlcm8pIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBCb25maXJlU3RhdGUuVU5MSVQ6XG4gICAgICAgICAgICAgICAgaGVyby5jaGFyYWN0ZXIuYm9uZmlyZXMuYWRkKHRoaXMuZHVuZ2Vvbi5sZXZlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5saWdodCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCb25maXJlU3RhdGUuTElHSFQ6XG4gICAgICAgICAgICBjYXNlIEJvbmZpcmVTdGF0ZS5MSVQ6XG4gICAgICAgICAgICAgICAgdGhpcy5kdW5nZW9uLmNvbnRyb2xsZXIuc2hvd0JvbmZpcmUoaGVyby5jaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxpZGUoXykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQm9uZmlyZVN0YXRlLlVOTElUKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEJvbmZpcmVTdGF0ZS5MSUdIVDtcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUgPSB0aGlzLmR1bmdlb24uYW5pbWF0ZWQodGhpcy54LCB0aGlzLnksIFwiYm9uZmlyZV9saWdodFwiKTtcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS56SW5kZXggPSBEdW5nZW9uWkluZGV4ZXMuc3RhdGljICsgdGhpcy55ICogRHVuZ2VvblpJbmRleGVzLnJvdztcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS5sb29wID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUub25Db21wbGV0ZSA9ICgpID0+IHRoaXMubGl0KCk7XG4gICAgICAgICAgICB0aGlzLmR1bmdlb24ubGlnaHQuYWRkTGlnaHQoe1xuICAgICAgICAgICAgICAgIHg6IHRoaXMueCAqIFRJTEVfU0laRSArIDgsXG4gICAgICAgICAgICAgICAgeTogdGhpcy55ICogVElMRV9TSVpFIC0gVElMRV9TSVpFLFxuICAgICAgICAgICAgfSwgTGlnaHRUeXBlLkJPTkZJUkUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEJvbmZpcmVTdGF0ZS5MSVQ7XG4gICAgICAgIChfYSA9IHRoaXMuX3Nwcml0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fc3ByaXRlID0gdGhpcy5kdW5nZW9uLmFuaW1hdGVkKHRoaXMueCwgdGhpcy55LCBcImJvbmZpcmVfbGl0XCIpO1xuICAgICAgICB0aGlzLl9zcHJpdGUuekluZGV4ID0gRHVuZ2VvblpJbmRleGVzLnN0YXRpYyArIHRoaXMueSAqIER1bmdlb25aSW5kZXhlcy5yb3c7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIER1bmdlb25Cb25maXJlRGlhbG9nTW9kYWwge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIsIGhlcm8pIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGFibGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICB0aGlzLmhlcm8gPSBoZXJvO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IDQwMDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gNDAwO1xuICAgICAgICBjb25zdCBidXR0b25faGVpZ2h0ID0gMzI7XG4gICAgICAgIGNvbnN0IGJ1dHRvbl90ZXh0X3NpemUgPSAyNDtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gbmV3IFNlbGVjdGFibGVHcmlkKHRoaXMuY29udHJvbGxlci5qb3lzdGljayk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC5iZWdpbkZpbGwoMHgwMDAwMDApLmRyYXdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpLmVuZEZpbGwoKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLnpJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKHRoaXMuYmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnNvcnRDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5wb3NpdGlvbi5zZXQoKHRoaXMuY29udHJvbGxlci5hcHAuc2NyZWVuLndpZHRoID4+IDEpIC0gKHdpZHRoID4+IDEpLCAodGhpcy5jb250cm9sbGVyLmFwcC5zY3JlZW4uaGVpZ2h0ID4+IDEpIC0gKGhlaWdodCA+PiAxKSk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hcHAudGlja2VyLmFkZCh0aGlzLmhhbmRsZUlucHV0LCB0aGlzKTtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gbmV3IExheW91dCgpO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KFNpemVzLnVpTWFyZ2luLCBTaXplcy51aU1hcmdpbik7XG4gICAgICAgIGxheW91dC5jb21taXQoKTtcbiAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICBjb25zdCBhZGRCdXR0b24gPSAobGFiZWwsIGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnV0dG9uID0gbmV3IEJ1dHRvbih7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCAtIFNpemVzLnVpTWFyZ2luICogMixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJ1dHRvbl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgdGV4dFNpemU6IGJ1dHRvbl90ZXh0X3NpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgICAgIGJ1dHRvbi5wb3NpdGlvbi5zZXQobGF5b3V0LngsIGxheW91dC55KTtcbiAgICAgICAgICAgIGxheW91dC5vZmZzZXQoMCwgYnV0dG9uX2hlaWdodCk7XG4gICAgICAgICAgICBsYXlvdXQub2Zmc2V0KDAsIFNpemVzLnVpTWFyZ2luKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0YWJsZS5zZXQoMCwgeSwgYnV0dG9uLCBhY3Rpb24pO1xuICAgICAgICAgICAgeSsrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsZXZlbHMgPSBbLi4udGhpcy5oZXJvLmJvbmZpcmVzXS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIGZvciAoY29uc3QgbGV2ZWwgb2YgbGV2ZWxzKSB7XG4gICAgICAgICAgICBhZGRCdXR0b24oYExldmVsICR7bGV2ZWx9YCwgKCkgPT4gdGhpcy5nb3RvKGxldmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQnV0dG9uKGBDYW5jZWxgLCAoKSA9PiB0aGlzLmNhbmNlbCgpKTtcbiAgICB9XG4gICAgZ290byhsZXZlbCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuY2xvc2VNb2RhbCgpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuZ2VuZXJhdGVEdW5nZW9uKHtcbiAgICAgICAgICAgIGhlcm86IHRoaXMuaGVybyxcbiAgICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuY2xvc2VNb2RhbCgpO1xuICAgIH1cbiAgICBoYW5kbGVJbnB1dCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnNlbGVjdGFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVJbnB1dCgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5oYW5kbGVJbnB1dCwgdGhpcyk7XG4gICAgICAgIChfYSA9IHRoaXMuY29udGFpbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIChfYiA9IHRoaXMuYmFja2dyb3VuZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gbnVsbDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEdW5nZW9uTWFwIH0gZnJvbSBcIi4vZHVuZ2Vvbi5tYXBcIjtcbmltcG9ydCB7IEhlcm9BSSB9IGZyb20gXCIuL2hlcm9cIjtcbmltcG9ydCB7IFRpbnlNb25zdGVyQUksIHRpbnlNb25zdGVycyB9IGZyb20gXCIuL3RpbnkubW9uc3RlclwiO1xuaW1wb3J0IHsgQm9zc01vbnN0ZXJBSSwgYm9zc01vbnN0ZXJzIH0gZnJvbSBcIi4vYm9zcy5tb25zdGVyXCI7XG5pbXBvcnQgeyBOcGNBSSwgbnBjQ2hhcmFjdGVycyB9IGZyb20gXCIuL25wY1wiO1xuaW1wb3J0IHsgTGlnaHRUeXBlIH0gZnJvbSBcIi4vZHVuZ2Vvbi5saWdodFwiO1xuaW1wb3J0IHsgTW9uc3RlckNhdGVnb3J5IH0gZnJvbSBcIi4vbW9uc3RlclwiO1xuaW1wb3J0IHsgRHVuZ2VvbkJvbmZpcmUgfSBmcm9tIFwiLi9kdW5nZW9uLmJvbmZpcmVcIjtcbmltcG9ydCAqIGFzIFBJWEkgZnJvbSAncGl4aS5qcyc7XG5leHBvcnQgY2xhc3MgQmFzZUR1bmdlb25HZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMgPSBjb250cm9sbGVyLnJlc291cmNlcztcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG4gICAgY3JlYXRlRHVuZ2VvbihybmcsIHNlZWQsIGxldmVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRHVuZ2Vvbk1hcCh0aGlzLmNvbnRyb2xsZXIsIG5ldyBQSVhJLlRpY2tlcigpLCBybmcsIHNlZWQsIGxldmVsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgcmVwbGFjZUZsb29yUmFuZG9tbHkocm5nLCBkdW5nZW9uKSB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IFsnZmxvb3JfMi5wbmcnLCAnZmxvb3JfMy5wbmcnLCAnZmxvb3JfNC5wbmcnLCAnZmxvb3JfNS5wbmcnLCAnZmxvb3JfNi5wbmcnLCAnZmxvb3JfNy5wbmcnLCAnZmxvb3JfOC5wbmcnXTtcbiAgICAgICAgY29uc3QgcGVyY2VudCA9IDAuMjtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBkdW5nZW9uLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGR1bmdlb24ud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBkdW5nZW9uLmNlbGwoeCwgeSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuaGFzRmxvb3IgJiYgcm5nLm5leHRGbG9hdCgpIDwgcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmZsb29yTmFtZSA9IHJuZy5jaG9pY2UocmVwbGFjZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZVdhbGxSYW5kb21seShybmcsIGR1bmdlb24pIHtcbiAgICAgICAgY29uc3QgYmFubmVycyA9IFtcbiAgICAgICAgICAgICd3YWxsX2Jhbm5lcl9yZWQucG5nJyxcbiAgICAgICAgICAgICd3YWxsX2Jhbm5lcl9ibHVlLnBuZycsXG4gICAgICAgICAgICAnd2FsbF9iYW5uZXJfZ3JlZW4ucG5nJyxcbiAgICAgICAgICAgICd3YWxsX2Jhbm5lcl95ZWxsb3cucG5nJyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZ29vID0gW1xuICAgICAgICAgICAgJ3dhbGxfZ29vLnBuZycsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGZvdW50YWlucyA9IFtcbiAgICAgICAgICAgICd3YWxsX2ZvdW50YWluX21pZF9yZWQnLFxuICAgICAgICAgICAgJ3dhbGxfZm91bnRhaW5fbWlkX2JsdWUnLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBob2xlcyA9IFtcbiAgICAgICAgICAgICd3YWxsX2hvbGVfMS5wbmcnLFxuICAgICAgICAgICAgJ3dhbGxfaG9sZV8yLnBuZycsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHBlcmNlbnQgPSAwLjM7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgZHVuZ2Vvbi5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBkdW5nZW9uLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZHVuZ2Vvbi5jZWxsKHgsIHkpO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLndhbGxOYW1lID09PSAnd2FsbF9taWQucG5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm5nLm5leHRGbG9hdCgpIDwgcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnRzID0gWy4uLmhvbGVzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc19mbG9vciA9IHkgKyAxIDwgZHVuZ2Vvbi5oZWlnaHQgJiYgZHVuZ2Vvbi5jZWxsKHgsIHkgKyAxKS5mbG9vck5hbWUgPT09ICdmbG9vcl8xLnBuZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX2Zsb29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRzLnB1c2goLi4uYmFubmVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRzLnB1c2goLi4uZ29vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc190b3AgPSB5ID4gMCAmJiBkdW5nZW9uLmNlbGwoeCwgeSAtIDEpLndhbGxOYW1lID09PSAnd2FsbF90b3BfbWlkLnBuZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX3RvcCAmJiBoYXNfZmxvb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudHMucHVzaCguLi5mb3VudGFpbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBybmcuY2hvaWNlKHJlcGxhY2VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2FsbF9nb28ucG5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVuZ2Vvbi5jZWxsKHgsIHkpLndhbGxOYW1lID0gJ3dhbGxfZ29vLnBuZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bmdlb24uY2VsbCh4LCB5ICsgMSkuZmxvb3JOYW1lID0gJ3dhbGxfZ29vX2Jhc2UucG5nJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2FsbF9mb3VudGFpbl9taWRfcmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVuZ2Vvbi5jZWxsKHgsIHkgLSAxKS53YWxsTmFtZSA9ICd3YWxsX2ZvdW50YWluX3RvcC5wbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW5nZW9uLmNlbGwoeCwgeSkud2FsbE5hbWUgPSAnd2FsbF9mb3VudGFpbl9taWRfcmVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVuZ2Vvbi5jZWxsKHgsIHkgKyAxKS5mbG9vck5hbWUgPSAnd2FsbF9mb3VudGFpbl9iYXNpbl9yZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd3YWxsX2ZvdW50YWluX21pZF9ibHVlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVuZ2Vvbi5jZWxsKHgsIHkgLSAxKS53YWxsTmFtZSA9ICd3YWxsX2ZvdW50YWluX3RvcC5wbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW5nZW9uLmNlbGwoeCwgeSkud2FsbE5hbWUgPSAnd2FsbF9mb3VudGFpbl9taWRfYmx1ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bmdlb24uY2VsbCh4LCB5ICsgMSkuZmxvb3JOYW1lID0gJ3dhbGxfZm91bnRhaW5fYmFzaW5fYmx1ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bmdlb24uY2VsbCh4LCB5KS53YWxsTmFtZSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXN0YW5jZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyhhLnggLSBiLngpLCBNYXRoLmFicyhhLnkgLSBiLnkpKTtcbiAgICB9XG4gICAgZmluZEZyZWVQb3NpdGlvbnMoZHVuZ2Vvbiwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBjb25zdCBmcmVlID0gW107XG4gICAgICAgIGZvciAobGV0IHkgPSBoZWlnaHQ7IHkgPCBkdW5nZW9uLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGR1bmdlb24ud2lkdGggLSB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkeSA9IDA7IGR5IDwgaGVpZ2h0ICYmIHZhbGlkOyBkeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGR4ID0gMDsgZHggPCB3aWR0aCAmJiB2YWxpZDsgZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGR1bmdlb24uY2VsbCh4ICsgZHgsIHkgLSBkeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IGNlbGwuaGFzRmxvb3IgJiYgIWNlbGwuaGFzT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWxpZClcbiAgICAgICAgICAgICAgICAgICAgZnJlZS5wdXNoKGR1bmdlb24uY2VsbCh4LCB5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyZWU7XG4gICAgfVxuICAgIHBsYWNlSGVybyhybmcsIGR1bmdlb24sIGhlcm8pIHtcbiAgICAgICAgY29uc3QgZnJlZSA9IHRoaXMuZmluZEZyZWVQb3NpdGlvbnMoZHVuZ2VvbiwgMiwgMik7XG4gICAgICAgIGlmIChmcmVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgXCJoZXJvIG5vdCBwbGFjZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZWxsID0gcm5nLmNob2ljZShmcmVlKTtcbiAgICAgICAgY29uc3QgYWkgPSBuZXcgSGVyb0FJKGhlcm8sIGR1bmdlb24sIGNlbGwueCwgY2VsbC55KTtcbiAgICAgICAgZHVuZ2Vvbi5saWdodC5hZGRMaWdodChhaS52aWV3LCBMaWdodFR5cGUuSEVSTyk7XG4gICAgICAgIHJldHVybiBhaTtcbiAgICB9XG4gICAgcGxhY2VOcGMocm5nLCBkdW5nZW9uLCBoZXJvKSB7XG4gICAgICAgIGNvbnN0IG1heF9oZXJvX2Rpc3RhbmNlID0gMTA7XG4gICAgICAgIGNvbnN0IG5wY19jb3VudCA9IDU7XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbnBjX2NvdW50OyBuKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZyZWUgPSB0aGlzLmZpbmRGcmVlUG9zaXRpb25zKGR1bmdlb24sIDIsIDIpLmZpbHRlcihjZWxsID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZShoZXJvLCBjZWxsKSA8IG1heF9oZXJvX2Rpc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZnJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJubyBmcmVlIHBsYWNlIGZvciBucGNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpID0gcm5nLm5leHRSYW5nZSgwLCBmcmVlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBbY2VsbF0gPSBmcmVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHJuZy5jaG9pY2UobnBjQ2hhcmFjdGVycyk7XG4gICAgICAgICAgICBuZXcgTnBjQUkoY29uZmlnLCBkdW5nZW9uLCB0aGlzLmNvbnRyb2xsZXIsIGNlbGwueCwgY2VsbC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwbGFjZU1vbnN0ZXJzKHJuZywgZHVuZ2VvbiwgaGVybykge1xuICAgICAgICBjb25zdCB0b3RhbF9zcGFjZSA9IGR1bmdlb24ud2lkdGggKiBkdW5nZW9uLmhlaWdodDtcbiAgICAgICAgY29uc3QgZmxvb3Jfc3BhY2UgPSBNYXRoLmZsb29yKHRvdGFsX3NwYWNlICogMC40KTtcbiAgICAgICAgY29uc3Qgc3Bhd25fc3BhY2UgPSBNYXRoLmZsb29yKGZsb29yX3NwYWNlICogMC4yKTtcbiAgICAgICAgY29uc3QgbW9uc3Rlcl9jb3VudCA9IE1hdGguZmxvb3Ioc3Bhd25fc3BhY2UgKiAwLjA3KTtcbiAgICAgICAgY29uc29sZS5sb2coYGZsb29yX3NwYWNlOiAke2Zsb29yX3NwYWNlfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgbW9uc3Rlcl9jb3VudDogJHttb25zdGVyX2NvdW50fWApO1xuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IG1vbnN0ZXJfY291bnQ7IG0rKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBsYWNlTW9uc3RlcihybmcsIGR1bmdlb24sIGhlcm8pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGxhY2VNb25zdGVyKHJuZywgZHVuZ2VvbiwgaGVybykge1xuICAgICAgICBjb25zdCBtb25zdGVyX2NhdGVnb3J5ID0gdGhpcy5ib3NzQ29uZmlnKGR1bmdlb24pLmNhdGVnb3J5O1xuICAgICAgICBjb25zdCBmaWx0ZXJlZF9tb25zdGVycyA9IHRpbnlNb25zdGVycy5maWx0ZXIoY29uZmlnID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuY2F0ZWdvcnkgPT09IG1vbnN0ZXJfY2F0ZWdvcnkgfHxcbiAgICAgICAgICAgICAgICAoY29uZmlnLmNhdGVnb3J5ICE9IE1vbnN0ZXJDYXRlZ29yeS5ERU1PTiAmJlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuY2F0ZWdvcnkgIT0gTW9uc3RlckNhdGVnb3J5Lk9SQyAmJlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuY2F0ZWdvcnkgIT0gTW9uc3RlckNhdGVnb3J5LlpPTUJJRSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZmlsdGVyZWRfbW9uc3RlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJubyB0aW55IG1vbnN0ZXIgY29uZmlnIGZvdW5kXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbl9oZXJvX2Rpc3RhbmNlID0gMTU7XG4gICAgICAgIGNvbnN0IGZyZWUgPSB0aGlzLmZpbmRGcmVlUG9zaXRpb25zKGR1bmdlb24sIDIsIDIpLmZpbHRlcihjZWxsID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlKGhlcm8sIGNlbGwpID4gbWluX2hlcm9fZGlzdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZnJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIm5vIGZyZWUgcGxhY2UgZm9yIHRpbnkgbW9uc3RlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpID0gcm5nLm5leHRSYW5nZSgwLCBmcmVlLmxlbmd0aCk7XG4gICAgICAgIGxldCBbY2VsbF0gPSBmcmVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gcm5nLmNob2ljZShmaWx0ZXJlZF9tb25zdGVycyk7XG4gICAgICAgIG5ldyBUaW55TW9uc3RlckFJKGNvbmZpZywgZHVuZ2VvbiwgY2VsbC54LCBjZWxsLnkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGxhY2VCb3NzKHJuZywgZHVuZ2VvbiwgaGVybykge1xuICAgICAgICBjb25zdCBtaW5faGVyb19kaXN0YW5jZSA9IDIwO1xuICAgICAgICBjb25zdCBmcmVlID0gdGhpcy5maW5kRnJlZVBvc2l0aW9ucyhkdW5nZW9uLCAyLCAyKS5maWx0ZXIoY2VsbCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZShoZXJvLCBjZWxsKSA+IG1pbl9oZXJvX2Rpc3RhbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IHJuZy5uZXh0UmFuZ2UoMCwgZnJlZS5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IFtjZWxsXSA9IGZyZWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5ib3NzQ29uZmlnKGR1bmdlb24pO1xuICAgICAgICAgICAgbmV3IEJvc3NNb25zdGVyQUkoY29uZmlnLCBkdW5nZW9uLCBjZWxsLngsIGNlbGwueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYm9zcyBub3QgcGxhY2VkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJvc3NDb25maWcoZHVuZ2Vvbikge1xuICAgICAgICByZXR1cm4gYm9zc01vbnN0ZXJzW01hdGguZmxvb3IoZHVuZ2Vvbi5sZXZlbCAvIDUpICUgYm9zc01vbnN0ZXJzLmxlbmd0aF07XG4gICAgfVxuICAgIHBsYWNlRHJvcChybmcsIGR1bmdlb24pIHtcbiAgICAgICAgY29uc3QgZnJlZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGR1bmdlb24uaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgZHVuZ2Vvbi5oZWlnaHQ7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBkdW5nZW9uLmNlbGwoeCwgeSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuaGFzRmxvb3IgJiYgIWNlbGwuaGFzRHJvcCAmJiAhY2VsbC5oYXNPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJlZS5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcm9wX3BlcmNlbnQgPSAzO1xuICAgICAgICBjb25zdCBkcm9wX2NvdW50ID0gTWF0aC5mbG9vcihmcmVlLmxlbmd0aCAqIGRyb3BfcGVyY2VudCAvIDEwMC4wKTtcbiAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkcm9wX2NvdW50ICYmIGZyZWUubGVuZ3RoID4gMDsgZCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gcm5nLm5leHRSYW5nZSgwLCBmcmVlLmxlbmd0aCk7XG4gICAgICAgICAgICBmcmVlLnNwbGljZShpLCAxKVswXS5yYW5kb21Ecm9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGxhY2VMYWRkZXIocm5nLCBkdW5nZW9uLCBoZXJvKSB7XG4gICAgICAgIGNvbnN0IGZyZWUzID0gW107XG4gICAgICAgIGNvbnN0IGZyZWUxID0gW107XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbnMgPSBbWy0xLCAtMV0sIFswLCAtMV0sIFsxLCAtMV0sIFstMSwgMF0sIFsxLCAwXSwgWy0xLCAxXSwgWzAsIDFdLCBbMSwgMV1dO1xuICAgICAgICBmb3IgKGxldCB5ID0gMTsgeSA8IGR1bmdlb24uaGVpZ2h0IC0gMTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMTsgeCA8IGR1bmdlb24uaGVpZ2h0IC0gMTsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGR1bmdlb24uY2VsbCh4LCB5KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5oYXNGbG9vcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IFtkeCwgZHldIG9mIGRpcmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdW5nZW9uLmNlbGwoeCArIGR4LCB5ICsgZHkpLmhhc0Zsb29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShoZXJvLCB7IHg6IHgsIHk6IHkgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBkaXJlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJlZTMucHVzaChbY2VsbCwgZGlzdGFuY2VdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyZWUxLnB1c2goW2NlbGwsIGRpc3RhbmNlXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJlZTMuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pO1xuICAgICAgICBmcmVlMS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICAgIGNvbnN0IGZyZWUgPSBbLi4uZnJlZTEsIC4uLmZyZWUzXS5yZXZlcnNlKCkuc3BsaWNlKDAsIDEwKTtcbiAgICAgICAgaWYgKGZyZWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRocm93IFwibGFkZGVyIG5vdCBzZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBybmcuY2hvaWNlKGZyZWUpWzBdLmxhZGRlcigpO1xuICAgIH1cbiAgICBwbGFjZUJvbmZpcmUocm5nLCBkdW5nZW9uLCBoZXJvKSB7XG4gICAgICAgIGNvbnN0IG1heF9oZXJvX2Rpc3RhbmNlID0gMTA7XG4gICAgICAgIGNvbnN0IGZyZWUgPSB0aGlzLmZpbmRGcmVlUG9zaXRpb25zKGR1bmdlb24sIDIsIDIpLmZpbHRlcihjZWxsID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlKGhlcm8sIGNlbGwpIDwgbWF4X2hlcm9fZGlzdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZnJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gcm5nLmNob2ljZShmcmVlKTtcbiAgICAgICAgICAgIGNvbnN0IGxpZ2h0ID0gaGVyby5jaGFyYWN0ZXIuYm9uZmlyZXMuaGFzKGR1bmdlb24ubGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEdW5nZW9uQm9uZmlyZShkdW5nZW9uLCBjZWxsLngsIGNlbGwueSwgbGlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJib25maXJlIG5vdCBwbGFjZWRcIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHtcbiAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBmdW5jdGlvbiB5aWVsZHMoZGVsYXkgPSAwKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKSk7XG4gICAgfSk7XG59XG4iLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyB5aWVsZHMgfSBmcm9tIFwiLi4vY29uY3VyZW5jeVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihzaXplLCB2YWx1ZSkge1xuICAgIGNvbnN0IGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBhLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydCBjbGFzcyBDb2xvciB7XG4gICAgY29uc3RydWN0b3IoUiwgRywgQiwgQSA9IDI1NSkge1xuICAgICAgICB0aGlzLlIgPSBSO1xuICAgICAgICB0aGlzLkcgPSBHO1xuICAgICAgICB0aGlzLkIgPSBCO1xuICAgICAgICB0aGlzLkEgPSBBO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJnYihyZ2IpIHtcbiAgICAgICAgY29uc3QgciA9IChyZ2IgPj4gMTYpICYgMHhGRjtcbiAgICAgICAgY29uc3QgZyA9IChyZ2IgPj4gOCkgJiAweEZGO1xuICAgICAgICBjb25zdCBiID0gcmdiICYgMHhGRjtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21JbWFnZShpbWFnZURhdGEsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21CdWZmZXIoaW1hZ2VEYXRhLmRhdGEsIGltYWdlRGF0YS53aWR0aCwgeCwgeSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlciwgdywgeCwgeSkge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gNCAqICh5ICogdyArIHgpO1xuICAgICAgICBsZXQgUiA9IGJ1ZmZlcltvZmZzZXRdO1xuICAgICAgICBsZXQgRyA9IGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgICAgICAgbGV0IEIgPSBidWZmZXJbb2Zmc2V0ICsgMl07XG4gICAgICAgIGxldCBBID0gYnVmZmVyW29mZnNldCArIDNdO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKFIsIEcsIEIsIEEpO1xuICAgIH1cbiAgICBlcXVhbHModGhhdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5SID09PSB0aGF0LlIgJiZcbiAgICAgICAgICAgIHRoaXMuRyA9PT0gdGhhdC5HICYmXG4gICAgICAgICAgICB0aGlzLkIgPT09IHRoYXQuQiAmJlxuICAgICAgICAgICAgdGhpcy5BID09PSB0aGF0LkE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRpbGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBjb2xvciwgZXF1YWwgPSAoYSwgYikgPT4gYSA9PT0gYikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5lcXVhbCA9IGVxdWFsO1xuICAgIH1cbiAgICBlcXVhbHModGhhdCkge1xuICAgICAgICByZXR1cm4gdGhhdC5lcXVhbCh0aGlzLnZhbHVlLCB0aGF0LnZhbHVlKTtcbiAgICB9XG59XG5leHBvcnQgdmFyIFJlc29sdXRpb247XG4oZnVuY3Rpb24gKFJlc29sdXRpb24pIHtcbiAgICBSZXNvbHV0aW9uW1Jlc29sdXRpb25bXCJEZWNpZGVkXCJdID0gMF0gPSBcIkRlY2lkZWRcIjtcbiAgICBSZXNvbHV0aW9uW1Jlc29sdXRpb25bXCJVbmRlY2lkZWRcIl0gPSAtMV0gPSBcIlVuZGVjaWRlZFwiO1xuICAgIFJlc29sdXRpb25bUmVzb2x1dGlvbltcIkNvbnRyYWRpY3Rpb25cIl0gPSAtMl0gPSBcIkNvbnRyYWRpY3Rpb25cIjtcbn0pKFJlc29sdXRpb24gfHwgKFJlc29sdXRpb24gPSB7fSkpO1xuZXhwb3J0IGNsYXNzIE1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihybmcsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy53YXZlID0gW107XG4gICAgICAgIHRoaXMucHJvcGFnYXRvciA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBhdGlibGUgPSBbXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlZCA9IG51bGw7XG4gICAgICAgIHRoaXMudG9Qcm9wYWdhdGUgPSBbXTtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2tJdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLmJhY2t0cmFja0l0ZW1zTGVuZ3RocyA9IFtdO1xuICAgICAgICB0aGlzLnByZXZDaG9pY2VzID0gW107XG4gICAgICAgIHRoaXMuZHJvcHBlZEJhY2t0cmFja0l0ZW1zQ291bnQgPSAwO1xuICAgICAgICB0aGlzLlQgPSAwO1xuICAgICAgICB0aGlzLnBlcmlvZGljID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2VpZ2h0cyA9IFtdO1xuICAgICAgICB0aGlzLndlaWdodExvZ1dlaWdodHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdW1zT2ZPbmVzID0gW107XG4gICAgICAgIHRoaXMuc3VtT2ZXZWlnaHRzID0gMDtcbiAgICAgICAgdGhpcy5zdW1PZldlaWdodExvZ1dlaWdodHMgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0aW5nRW50cm9weSA9IDA7XG4gICAgICAgIHRoaXMuc3Vtc09mV2VpZ2h0cyA9IFtdO1xuICAgICAgICB0aGlzLnN1bXNPZldlaWdodExvZ1dlaWdodHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbnRyb3BpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBSZXNvbHV0aW9uLlVuZGVjaWRlZDtcbiAgICAgICAgdGhpcy5kZWZlcnJlZENvbnN0cmFpbnRzU3RlcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlYnVnID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm5nID0gcm5nO1xuICAgICAgICB0aGlzLkZNWCA9IHdpZHRoO1xuICAgICAgICB0aGlzLkZNWSA9IGhlaWdodDtcbiAgICB9XG4gICAgZ2V0IHBlcmNlbnQoKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53YXZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdW1zT2ZPbmVzW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQgKiAxMDAuMCAvIHRoaXMud2F2ZS5sZW5ndGg7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMud2F2ZSA9IGJ1ZmZlcih0aGlzLkZNWCAqIHRoaXMuRk1ZLCBbXSk7XG4gICAgICAgIHRoaXMuY29tcGF0aWJsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud2F2ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53YXZlW2ldID0gYnVmZmVyKHRoaXMuVCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNvbXBhdGlibGVbaV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5UOyB0KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBhdGlibGVbaV1bdF0gPSBidWZmZXIoNCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWlnaHRMb2dXZWlnaHRzID0gW107XG4gICAgICAgIHRoaXMuc3VtT2ZXZWlnaHRzID0gMDtcbiAgICAgICAgdGhpcy5zdW1PZldlaWdodExvZ1dlaWdodHMgPSAwO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuVDsgdCsrKSB7XG4gICAgICAgICAgICB0aGlzLndlaWdodExvZ1dlaWdodHNbdF0gPSB0aGlzLndlaWdodHNbdF0gKiBNYXRoLmxvZyh0aGlzLndlaWdodHNbdF0pO1xuICAgICAgICAgICAgdGhpcy5zdW1PZldlaWdodHMgKz0gdGhpcy53ZWlnaHRzW3RdO1xuICAgICAgICAgICAgdGhpcy5zdW1PZldlaWdodExvZ1dlaWdodHMgKz0gdGhpcy53ZWlnaHRMb2dXZWlnaHRzW3RdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRpbmdFbnRyb3B5ID0gTWF0aC5sb2codGhpcy5zdW1PZldlaWdodHMpIC0gdGhpcy5zdW1PZldlaWdodExvZ1dlaWdodHMgLyB0aGlzLnN1bU9mV2VpZ2h0cztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBSZXNvbHV0aW9uLlVuZGVjaWRlZDtcbiAgICAgICAgdGhpcy5pbml0Q29uc3RyYWludCgpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zdW1zT2ZPbmVzID0gW107XG4gICAgICAgIHRoaXMuc3Vtc09mV2VpZ2h0cyA9IFtdO1xuICAgICAgICB0aGlzLnN1bXNPZldlaWdodExvZ1dlaWdodHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbnRyb3BpZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndhdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5UOyB0KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhdmVbaV1bdF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgNDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGF0aWJsZVtpXVt0XVtkXSA9IHRoaXMucHJvcGFnYXRvcltNb2RlbC5vcHBvc2l0ZVtkXV1bdF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vtc09mT25lc1tpXSA9IHRoaXMud2VpZ2h0cy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnN1bXNPZldlaWdodHNbaV0gPSB0aGlzLnN1bU9mV2VpZ2h0cztcbiAgICAgICAgICAgIHRoaXMuc3Vtc09mV2VpZ2h0TG9nV2VpZ2h0c1tpXSA9IHRoaXMuc3VtT2ZXZWlnaHRMb2dXZWlnaHRzO1xuICAgICAgICAgICAgdGhpcy5lbnRyb3BpZXNbaV0gPSB0aGlzLnN0YXJ0aW5nRW50cm9weTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvUHJvcGFnYXRlID0gW107XG4gICAgICAgIHRoaXMuYmFja3RyYWNrSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2tJdGVtc0xlbmd0aHMgPSBbMF07XG4gICAgICAgIHRoaXMuZHJvcHBlZEJhY2t0cmFja0l0ZW1zQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnByZXZDaG9pY2VzID0gW107XG4gICAgICAgIHRoaXMuc3RhdHVzID0gUmVzb2x1dGlvbi5VbmRlY2lkZWQ7XG4gICAgfVxuICAgIHJ1bihsaW1pdCA9IDAsIGRlYnVnID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhdmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS50aW1lKFwibW9kZWwuaW5pdFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoXCJtb2RlbC5pbml0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS50aW1lKFwibW9kZWwuY2xlYXJcIik7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoXCJtb2RlbC5jbGVhclwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUudGltZShcIm1vZGVsLnJ1blwiKTtcbiAgICAgICAgICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGltaXQgfHwgbGltaXQgPT09IDA7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpICUgNTAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RlcFwiLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZnRlciBzdGVwXCIsIGkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBSZXNvbHV0aW9uLlVuZGVjaWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoXCJtb2RlbC5ydW5cIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgY29tcGxldGUsIHN0ZXBzOiAke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGVwKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgbGV0IHBhdHRlcm47XG4gICAgICAgIGxldCByZXN0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmRlZmVycmVkQ29uc3RyYWludHNTdGVwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInN0ZXAgY29uc3RyYWludFwiKTtcbiAgICAgICAgICAgIHRoaXMuc3RlcENvbnN0cmFpbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT0gUmVzb2x1dGlvbi5VbmRlY2lkZWQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIHJlc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZXN0YXJ0ID0gdHJ1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMudG9Qcm9wYWdhdGUubGVuZ3RoID09IDApO1xuICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2tJdGVtc0xlbmd0aHMucHVzaCh0aGlzLmRyb3BwZWRCYWNrdHJhY2tJdGVtc0NvdW50ICsgdGhpcy5iYWNrdHJhY2tJdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgW2luZGV4LCBwYXR0ZXJuXSA9IHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJvYnNlcnZlZFwiLCBpbmRleCwgcGF0dGVybik7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHVzaCB0byBwcmV2IGNob2ljZXNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2Q2hvaWNlcy5wdXNoKFtpbmRleCwgcGF0dGVybl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZG8gbG9vcFwiKTtcbiAgICAgICAgICAgIHJlc3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhdHVzXCIsIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gUmVzb2x1dGlvbi5VbmRlY2lkZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gUmVzb2x1dGlvbi5VbmRlY2lkZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwQ29uc3RyYWludCgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSAmJiB0aGlzLnN0YXR1cyA9PT0gUmVzb2x1dGlvbi5VbmRlY2lkZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkZWNpZGVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gUmVzb2x1dGlvbi5EZWNpZGVkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gUmVzb2x1dGlvbi5Db250cmFkaWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udHJhZGljdGlvblwiKTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIndoaWxlIGJhY2t0cmFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFja3RyYWNrSXRlbXNMZW5ndGhzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldlJ3ZlIGJhY2t0cmFja2VkIGFzIG11Y2ggYXMgd2UgY2FuLCBidXQsIGl0J3Mgc3RpbGwgbm90IHBvc3NpYmxlLiBUaGF0IG1lYW5zIGl0IGlzIGltcG9zc2libGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVzb2x1dGlvbi5Db250cmFkaWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja3RyYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5wcmV2Q2hvaWNlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b1Byb3BhZ2F0ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFJlc29sdXRpb24uVW5kZWNpZGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXJrIHRoZSBnaXZlbiBjaG9pY2UgYXMgaW1wb3NzaWJsZVwiLCBpdGVtWzBdLCBpdGVtWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MoW2l0ZW1bMF1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbEJhbihpdGVtWzBdLCBpdGVtWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBSZXNvbHV0aW9uLkNvbnRyYWRpY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBSZXNvbHV0aW9uLlVuZGVjaWRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gUmVzb2x1dGlvbi5Db250cmFkaWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIklmIHN0aWxsIGluIGNvbnRyYWRpY3Rpb24sIHJlcGVhdCBiYWNrdHJhY2tpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLy8gSW5jbHVkZSB0aGUgbGFzdCBiYW4gYXMgcGFydCBvZiB0aGUgcHJldmlvdXMgYmFja3RyYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy50b1Byb3BhZ2F0ZS5sZW5ndGggPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2tJdGVtc0xlbmd0aHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2t0cmFja0l0ZW1zTGVuZ3Rocy5wdXNoKHRoaXMuZHJvcHBlZEJhY2t0cmFja0l0ZW1zQ291bnQgKyB0aGlzLmJhY2t0cmFja0l0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlc3RhcnQgPSB0cnVlIGFuZCBicmVha1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAocmVzdGFydCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cztcbiAgICB9XG4gICAgb2JzZXJ2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9ic2VydmVcIik7XG4gICAgICAgIGxldCBtaW4gPSAxRSszO1xuICAgICAgICBsZXQgYXJnbWluID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53YXZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vbkJvdW5kYXJ5KGkgJSB0aGlzLkZNWCwgTWF0aC5mbG9vcihpIC8gdGhpcy5GTVgpKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBhbW91bnQgPSB0aGlzLnN1bXNPZk9uZXNbaV07XG4gICAgICAgICAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFt3YXZlPSR7aX1dIGZvdW5kIHplcm8gc3VtIG9mIG9uZXNgKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcyhbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gUmVzb2x1dGlvbi5Db250cmFkaWN0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBbLTEsIC0xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbnRyb3B5ID0gdGhpcy5lbnRyb3BpZXNbaV07XG4gICAgICAgICAgICBpZiAoYW1vdW50ID4gMSAmJiBlbnRyb3B5IDw9IG1pbikge1xuICAgICAgICAgICAgICAgIGxldCBub2lzZSA9IDFFLTYgKiB0aGlzLnJuZy5uZXh0RmxvYXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cm9weSArIG5vaXNlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGVudHJvcHkgKyBub2lzZTtcbiAgICAgICAgICAgICAgICAgICAgYXJnbWluID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ21pbiA9PSAtMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb21wbGV0ZSBvYnNlcnZlZFwiKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZWQgPSBidWZmZXIodGhpcy5GTVggKiB0aGlzLkZNWSwgMCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud2F2ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gaSAlIHRoaXMuRk1YLCB5ID0gTWF0aC5mbG9vcihpIC8gdGhpcy5GTVgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uQm91bmRhcnkoeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudGVzdE9ic2VydmVkKGkpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5UOyB0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMud2F2ZVtpXVt0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlZFtpXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbLTEsIC0xXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlzdHJpYnV0aW9uX3N1bSA9IDA7XG4gICAgICAgIGxldCBkaXN0cmlidXRpb24gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLlQ7IHQrKykge1xuICAgICAgICAgICAgZGlzdHJpYnV0aW9uW3RdID0gdGhpcy53YXZlW2FyZ21pbl1bdF0gPyB0aGlzLndlaWdodHNbdF0gOiAwO1xuICAgICAgICAgICAgZGlzdHJpYnV0aW9uX3N1bSArPSBkaXN0cmlidXRpb25bdF07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJuZCA9IHRoaXMucm5nLm5leHRGbG9hdCgpICogZGlzdHJpYnV0aW9uX3N1bTtcbiAgICAgICAgbGV0IHIgPSAwO1xuICAgICAgICBmb3IgKGxldCB3ZWlnaHQgb2YgZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgICBybmQgLT0gd2VpZ2h0O1xuICAgICAgICAgICAgaWYgKHJuZCA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHcgPSB0aGlzLndhdmVbYXJnbWluXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLlQ7IHQrKykge1xuICAgICAgICAgICAgaWYgKHdbdF0gIT0gKHQgPT0gcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJvYnNlcnZlIHNlbGVjdFwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbEJhbihhcmdtaW4sIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gUmVzb2x1dGlvbi5Db250cmFkaWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJvYnNlcnZlZFwiLCBbYXJnbWluLCByXSk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzKFthcmdtaW5dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FyZ21pbiwgcl07XG4gICAgfVxuICAgIHByb3BhZ2F0ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMudG9Qcm9wYWdhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IFtpLCB0XSA9IHRoaXMudG9Qcm9wYWdhdGUucG9wKCk7XG4gICAgICAgICAgICBsZXQgeCA9IGkgJSB0aGlzLkZNWCwgeSA9IE1hdGguZmxvb3IoaSAvIHRoaXMuRk1YKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRpcmVjdGlvbiA9IDA7IGRpcmVjdGlvbiA8IDQ7IGRpcmVjdGlvbisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHggPSBNb2RlbC5EWFtkaXJlY3Rpb25dLCBkeSA9IE1vZGVsLkRZW2RpcmVjdGlvbl07XG4gICAgICAgICAgICAgICAgbGV0IHN4ID0geCArIGR4LCBzeSA9IHkgKyBkeTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkJvdW5kYXJ5KHN4LCBzeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzeCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN4ICs9IHRoaXMuRk1YO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN4ID49IHRoaXMuRk1YKVxuICAgICAgICAgICAgICAgICAgICBzeCAtPSB0aGlzLkZNWDtcbiAgICAgICAgICAgICAgICBpZiAoc3kgPCAwKVxuICAgICAgICAgICAgICAgICAgICBzeSArPSB0aGlzLkZNWTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzeSA+PSB0aGlzLkZNWSlcbiAgICAgICAgICAgICAgICAgICAgc3kgLT0gdGhpcy5GTVk7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBzeCArIHN5ICogdGhpcy5GTVg7XG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4xID0gdGhpcy5wcm9wYWdhdG9yW2RpcmVjdGlvbl1bdF07XG4gICAgICAgICAgICAgICAgbGV0IGNvbXBhdCA9IHRoaXMuY29tcGF0aWJsZVtzXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdCBvZiBwYXR0ZXJuMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcCA9IGNvbXBhdFtzdF07XG4gICAgICAgICAgICAgICAgICAgIGNvbXBbZGlyZWN0aW9uXS0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcFtkaXJlY3Rpb25dID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsQmFuKHMsIHN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gUmVzb2x1dGlvbi5Db250cmFkaWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09IFJlc29sdXRpb24uQ29udHJhZGljdGlvbikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGJhbihpbmRleCwgcGF0dGVybikge1xuICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYmFuXCIsIGluZGV4LCBwYXR0ZXJuKTtcbiAgICAgICAgaWYgKHRoaXMud2F2ZVtpbmRleF1bcGF0dGVybl0pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWRDb25zdHJhaW50c1N0ZXAgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxCYW4oaW5kZXgsIHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID0gUmVzb2x1dGlvbi5Db250cmFkaWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcGFnYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cztcbiAgICB9XG4gICAgaW50ZXJuYWxCYW4oaW5kZXgsIHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImludGVybmFsIGJhblwiLCBpbmRleCwgcGF0dGVybik7XG4gICAgICAgIHRoaXMud2F2ZVtpbmRleF1bcGF0dGVybl0gPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvbXAgPSB0aGlzLmNvbXBhdGlibGVbaW5kZXhdW3BhdHRlcm5dO1xuICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IDQ7IGQrKykge1xuICAgICAgICAgICAgY29tcFtkXSAtPSB0aGlzLlQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b1Byb3BhZ2F0ZS5wdXNoKFtpbmRleCwgcGF0dGVybl0pO1xuICAgICAgICB0aGlzLnN1bXNPZk9uZXNbaW5kZXhdIC09IDE7XG4gICAgICAgIHRoaXMuc3Vtc09mV2VpZ2h0c1tpbmRleF0gLT0gdGhpcy53ZWlnaHRzW3BhdHRlcm5dO1xuICAgICAgICB0aGlzLnN1bXNPZldlaWdodExvZ1dlaWdodHNbaW5kZXhdIC09IHRoaXMud2VpZ2h0TG9nV2VpZ2h0c1twYXR0ZXJuXTtcbiAgICAgICAgbGV0IHN1bSA9IHRoaXMuc3Vtc09mV2VpZ2h0c1tpbmRleF07XG4gICAgICAgIHRoaXMuZW50cm9waWVzW2luZGV4XSA9IE1hdGgubG9nKHN1bSkgLSB0aGlzLnN1bXNPZldlaWdodExvZ1dlaWdodHNbaW5kZXhdIC8gc3VtO1xuICAgICAgICB0aGlzLmJhY2t0cmFja0l0ZW1zLnB1c2goW2luZGV4LCBwYXR0ZXJuXSk7XG4gICAgICAgIHRoaXMuYmFuQ29uc3RyYWludChpbmRleCwgcGF0dGVybik7XG4gICAgICAgIGlmICh0aGlzLnN1bXNPZk9uZXNbaW5kZXhdID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJzdW0gaXMgemVyb1wiLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcyhbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJhY2t0cmFjaygpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0TGVuZ3RoID0gdGhpcy5iYWNrdHJhY2tJdGVtc0xlbmd0aHMucG9wKCkgLSB0aGlzLmRyb3BwZWRCYWNrdHJhY2tJdGVtc0NvdW50O1xuICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImJhY2t0cmFja1wiLCB0YXJnZXRMZW5ndGgpO1xuICAgICAgICBjb25zdCBtYXJrdXAgPSBbXTtcbiAgICAgICAgY29uc3QgdG9Qcm9wYWdhdGVTZXQgPSBuZXcgU2V0KHRoaXMudG9Qcm9wYWdhdGUubWFwKChpKSA9PiBpLmpvaW4oXCIsXCIpKSk7XG4gICAgICAgIHdoaWxlICh0aGlzLmJhY2t0cmFja0l0ZW1zLmxlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgbGV0IFtpbmRleCwgcGF0dGVybkluZGV4XSA9IHRoaXMuYmFja3RyYWNrSXRlbXMucG9wKCk7XG4gICAgICAgICAgICBtYXJrdXAucHVzaChpbmRleCk7XG4gICAgICAgICAgICBsZXQgY29tcCA9IHRoaXMuY29tcGF0aWJsZVtpbmRleF1bcGF0dGVybkluZGV4XTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgNDsgZCsrKSB7XG4gICAgICAgICAgICAgICAgY29tcFtkXSArPSB0aGlzLlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndhdmVbaW5kZXhdW3BhdHRlcm5JbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdW1zT2ZPbmVzW2luZGV4XSArPSAxO1xuICAgICAgICAgICAgdGhpcy5zdW1zT2ZXZWlnaHRzW2luZGV4XSArPSB0aGlzLndlaWdodHNbcGF0dGVybkluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuc3Vtc09mV2VpZ2h0TG9nV2VpZ2h0c1tpbmRleF0gKz0gdGhpcy53ZWlnaHRMb2dXZWlnaHRzW3BhdHRlcm5JbmRleF07XG4gICAgICAgICAgICBsZXQgc3VtID0gdGhpcy5zdW1zT2ZXZWlnaHRzW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuZW50cm9waWVzW2luZGV4XSA9IE1hdGgubG9nKHN1bSkgLSB0aGlzLnN1bXNPZldlaWdodExvZ1dlaWdodHNbaW5kZXhdIC8gc3VtO1xuICAgICAgICAgICAgaWYgKCF0b1Byb3BhZ2F0ZVNldC5oYXMoW2luZGV4LCBwYXR0ZXJuSW5kZXhdLmpvaW4oXCIsXCIpKSkge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gaW5kZXggJSB0aGlzLkZNWCwgeSA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLkZNWCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZGlyZWN0aW9uID0gMDsgZGlyZWN0aW9uIDwgNDsgZGlyZWN0aW9uKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGR4ID0gTW9kZWwuRFhbZGlyZWN0aW9uXSwgZHkgPSBNb2RlbC5EWVtkaXJlY3Rpb25dO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3ggPSB4ICsgZHgsIHN5ID0geSArIGR5O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkJvdW5kYXJ5KHN4LCBzeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBzeCArPSB0aGlzLkZNWDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3ggPj0gdGhpcy5GTVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBzeCAtPSB0aGlzLkZNWDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5IDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5ICs9IHRoaXMuRk1ZO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzeSA+PSB0aGlzLkZNWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5IC09IHRoaXMuRk1ZO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHN4ICsgc3kgKiB0aGlzLkZNWDtcbiAgICAgICAgICAgICAgICAgICAgbWFya3VwLnB1c2gocyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnByb3BhZ2F0b3JbZGlyZWN0aW9uXVtwYXR0ZXJuSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzdCBvZiBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBhdGlibGVbc11bc3RdW2RpcmVjdGlvbl0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmFja3RyYWNrQ29uc3RyYWludChpbmRleCwgcGF0dGVybkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJiYWNrdHJhY2tlZFwiKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MobWFya3VwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk1vZGVsLkRYID0gWy0xLCAwLCAxLCAwXTtcbk1vZGVsLkRZID0gWzAsIDEsIDAsIC0xXTtcbk1vZGVsLm9wcG9zaXRlID0gWzIsIDMsIDAsIDFdO1xuIiwiY29uc3QgeF9kaXN0ID0gMjtcbmNvbnN0IHlfZGlzdCA9IDM7XG5leHBvcnQgY2xhc3MgSW1tdXRhYmxlUmVjdCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgdywgaCkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICB0aGlzLmggPSBoO1xuICAgIH1cbiAgICBtdXRhYmxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLncsIHRoaXMuaCk7XG4gICAgfVxuICAgIGV4cGFuZCgpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlUmVjdChhLnggLSB4X2Rpc3QsIGEueSAtIHlfZGlzdCwgYS53ICsgeF9kaXN0ICsgeF9kaXN0LCBhLmggKyB5X2Rpc3QgKyB5X2Rpc3QpO1xuICAgIH1cbiAgICBleHBhbmRWKCkge1xuICAgICAgICBjb25zdCBhID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVSZWN0KGEueCAtIHhfZGlzdCwgYS55LCBhLncgKyB4X2Rpc3QgKyB4X2Rpc3QsIGEuaCk7XG4gICAgfVxuICAgIGV4cGFuZEgoKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVJlY3QoYS54LCBhLnkgLSB5X2Rpc3QsIGEudywgYS5oICsgeV9kaXN0ICsgeV9kaXN0KTtcbiAgICB9XG4gICAgaXNPdmVybGFwKGIpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhLnggPCBiLnggKyBiLndcbiAgICAgICAgICAgICYmIGEueCArIGEudyA+IGIueFxuICAgICAgICAgICAgJiYgYS55IDwgYi55ICsgYi5oXG4gICAgICAgICAgICAmJiBhLnkgKyBhLmggPiBiLnk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYHt4PSR7dGhpcy54fSx5PSR7dGhpcy55fSx3PSR7dGhpcy53fSxoPSR7dGhpcy5ofX1gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNdXRhYmxlUmVjdCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgdywgaCkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICB0aGlzLmggPSBoO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShyZWN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZVJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbiAgICB9XG4gICAgaW1tdXRhYmxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMudywgdGhpcy5oKTtcbiAgICB9XG4gICAgaXNPdmVybGFwKGIpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhLnggPCBiLnggKyBiLndcbiAgICAgICAgICAgICYmIGEueCArIGEudyA+IGIueFxuICAgICAgICAgICAgJiYgYS55IDwgYi55ICsgYi5oXG4gICAgICAgICAgICAmJiBhLnkgKyBhLmggPiBiLnk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYHt4PSR7dGhpcy54fSx5PSR7dGhpcy55fSx3PSR7dGhpcy53fSxoPSR7dGhpcy5ofX1gO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEltbXV0YWJsZVJlY3QsIE11dGFibGVSZWN0IH0gZnJvbSBcIi4vZ2VvbWV0cnlcIjtcbmV4cG9ydCBjbGFzcyBUdW5uZWxpbmdBbGdvcml0aG0ge1xuICAgIGNvbnN0cnVjdG9yKHJuZywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnBvc3NpYmxlID0gW107XG4gICAgICAgIHRoaXMucm9vbXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb3JyaWRvcnNWID0gW107XG4gICAgICAgIHRoaXMuY29ycmlkb3JzSCA9IFtdO1xuICAgICAgICB0aGlzLnJuZyA9IHJuZztcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5yb29tX21pbl93ID0gb3B0aW9ucy5yb29tX21pbl93IHx8IDU7XG4gICAgICAgIHRoaXMucm9vbV9taW5faCA9IG9wdGlvbnMucm9vbV9taW5faCB8fCA1O1xuICAgICAgICB0aGlzLnJvb21fbWF4X3cgPSBvcHRpb25zLnJvb21fbWF4X3cgfHwgMjA7XG4gICAgICAgIHRoaXMucm9vbV9tYXhfaCA9IG9wdGlvbnMucm9vbV9tYXhfaCB8fCAyMDtcbiAgICAgICAgdGhpcy5yb29tX21pbl94ID0gb3B0aW9ucy5yb29tX21pbl94IHx8IDI7XG4gICAgICAgIHRoaXMucm9vbV9taW5feSA9IG9wdGlvbnMucm9vbV9taW5feSB8fCAyO1xuICAgICAgICB0aGlzLm1heF9jb3JyX2Rpc3QgPSBvcHRpb25zLm1heF9jb3JyX2Rpc3QgfHwgMjA7XG4gICAgICAgIHRoaXMubWF4X2NvcnJfd2lkdGggPSBvcHRpb25zLm1heF9jb3JyX3dpZHRoIHx8IDU7XG4gICAgICAgIHRoaXMuc2tldyA9IG9wdGlvbnMuc2tldyB8fCAzO1xuICAgICAgICB0aGlzLnhfZGlzdCA9IG9wdGlvbnMueF9kaXN0IHx8IDI7XG4gICAgICAgIHRoaXMueV9kaXN0ID0gb3B0aW9ucy55X2Rpc3QgfHwgMjtcbiAgICAgICAgdGhpcy5taW5fY29ycl9kaXN0X3ggPSBvcHRpb25zLm1pbl9jb3JyX2Rpc3RfeCB8fCAodGhpcy54X2Rpc3QgPDwgMSkgKyAxO1xuICAgICAgICB0aGlzLm1pbl9jb3JyX2Rpc3RfeSA9IG9wdGlvbnMubWluX2NvcnJfZGlzdF95IHx8ICh0aGlzLnlfZGlzdCA8PCAxKSArIDE7XG4gICAgICAgIHRoaXMubWF4X3Jvb21zID0gb3B0aW9ucy5tYXhfcm9vbXMgfHwgMDtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWcgfHwgZmFsc2U7XG4gICAgfVxuICAgIGlzT3ZlcmxhcChhKSB7XG4gICAgICAgIGNvbnN0IGYgPSBhLmlzT3ZlcmxhcC5iaW5kKGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5yb29tcy5zb21lKGYpIHx8XG4gICAgICAgICAgICB0aGlzLmNvcnJpZG9yc1Yuc29tZShmKSB8fFxuICAgICAgICAgICAgdGhpcy5jb3JyaWRvcnNILnNvbWUoZik7XG4gICAgfVxuICAgIDtcbiAgICB2YWxpZChyZWN0KSB7XG4gICAgICAgIHJldHVybiByZWN0LnggPj0gMCAmJiByZWN0LnkgPj0gMCAmJiByZWN0LncgPiAwICYmIHJlY3QuaCA+IDAgJiZcbiAgICAgICAgICAgIHJlY3QueCArIHJlY3QudyA8IHRoaXMud2lkdGggJiZcbiAgICAgICAgICAgIHJlY3QueSArIHJlY3QuaCA8IHRoaXMuaGVpZ2h0ICYmXG4gICAgICAgICAgICAhdGhpcy5pc092ZXJsYXAocmVjdCk7XG4gICAgfVxuICAgIGdlbmVyYXRlKCkge1xuICAgICAgICB0aGlzLnJvb21zLnNwbGljZSgwLCB0aGlzLnJvb21zLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY29ycmlkb3JzSC5zcGxpY2UoMCwgdGhpcy5jb3JyaWRvcnNILmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY29ycmlkb3JzVi5zcGxpY2UoMCwgdGhpcy5jb3JyaWRvcnNWLmxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRlRmlyc3RSb29tKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heF9yb29tcyA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5yb29tcy5sZW5ndGggPCB0aGlzLm1heF9yb29tcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2VuZXJhdGVOZXh0Um9vbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5nZW5lcmF0ZU5leHRSb29tKCkpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZW5lcmF0ZUZpcnN0Um9vbSgpIHtcbiAgICAgICAgY29uc3Qgcm9vbV93ID0gdGhpcy5ybmcubmV4dFJhbmdlKHRoaXMucm9vbV9taW5fdywgdGhpcy5yb29tX21heF93KTtcbiAgICAgICAgY29uc3Qgcm9vbV9oID0gdGhpcy5ybmcubmV4dFJhbmdlKHRoaXMucm9vbV9taW5faCwgdGhpcy5yb29tX21heF9oKTtcbiAgICAgICAgY29uc3QgbWluX3ggPSBNYXRoLm1heCh0aGlzLnJvb21fbWluX3gsICh0aGlzLndpZHRoID4+IDEpIC0gcm9vbV93KTtcbiAgICAgICAgY29uc3QgbWluX3kgPSBNYXRoLm1heCh0aGlzLnJvb21fbWluX3ksICh0aGlzLmhlaWdodCA+PiAxKSAtIHJvb21faCk7XG4gICAgICAgIGNvbnN0IG1heF94ID0gTWF0aC5taW4odGhpcy53aWR0aCAtIHRoaXMucm9vbV9taW5feCAtIHJvb21fdywgKHRoaXMud2lkdGggPj4gMSkgKyByb29tX3cpO1xuICAgICAgICBjb25zdCBtYXhfeSA9IE1hdGgubWluKHRoaXMuaGVpZ2h0IC0gdGhpcy5yb29tX21pbl95IC0gcm9vbV9oLCAodGhpcy5oZWlnaHQgPj4gMSkgKyByb29tX2gpO1xuICAgICAgICBjb25zdCByb29tID0gbmV3IEltbXV0YWJsZVJlY3QodGhpcy5uZXh0UmFuZ2UobWluX3gsIG1heF94KSwgdGhpcy5uZXh0UmFuZ2UobWluX3ksIG1heF95KSwgcm9vbV93LCByb29tX2gpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPdmVybGFwKHJvb20uZXhwYW5kKCkpKSB7XG4gICAgICAgICAgICB0aGlzLnJvb21zLnB1c2gocm9vbSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdlbmVyYXRlTmV4dFJvb20oKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJnZW5lcmF0ZSBuZXh0IHJvb21cIik7XG4gICAgICAgIHRoaXMucG9zc2libGUuc3BsaWNlKDAsIHRoaXMucG9zc2libGUubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5yb29tcy5mb3JFYWNoKChyb29tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b3BDID0gdGhpcy5maW5kVG9wQ29ycmlkb3JBcmVhKHJvb20pO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tQyA9IHRoaXMuZmluZEJvdHRvbUNvcnJpZG9yQXJlYShyb29tKTtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0QyA9IHRoaXMuZmluZFJpZ2h0Q29ycmlkb3JBcmVhKHJvb20pO1xuICAgICAgICAgICAgY29uc3QgbGVmdEMgPSB0aGlzLmZpbmRMZWZ0Q29ycmlkb3JBcmVhKHJvb20pO1xuICAgICAgICAgICAgaWYgKHRvcEMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwb3NzaWJsZSB0b3AgY29ycmlkb3IgYXJlYVwiLCByb29tLCB0b3BDKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3BSID0gdGhpcy5maW5kVG9wUm9vbUFyZWEodG9wQyk7XG4gICAgICAgICAgICAgICAgaWYgKHRvcFIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFkZCBwb3NzaWJsZSB0b3Agcm9vbSBhcmVhXCIsIHJvb20sIHRvcEMsIHRvcFIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3NpYmxlLnB1c2gobmV3IFBvc3NpYmxlKHRvcFIsIHRvcEMsIERpcmVjdGlvbi5UT1ApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm90dG9tQykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInBvc3NpYmxlIGJvdHRvbSBjb3JyaWRvciBhcmVhXCIsIHJvb20sIGJvdHRvbUMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdHRvbVIgPSB0aGlzLmZpbmRCb3R0b21Sb29tQXJlYShib3R0b21DKTtcbiAgICAgICAgICAgICAgICBpZiAoYm90dG9tUikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWRkIHBvc3NpYmxlIGJvdHRvbSByb29tIGFyZWFcIiwgcm9vbSwgYm90dG9tQywgYm90dG9tUik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zc2libGUucHVzaChuZXcgUG9zc2libGUoYm90dG9tUiwgYm90dG9tQywgRGlyZWN0aW9uLkJPVFRPTSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodEMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwb3NzaWJsZSByaWdodCBjb3JyaWRvciBhcmVhXCIsIHJvb20sIHJpZ2h0Qyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRSID0gdGhpcy5maW5kUmlnaHRSb29tQXJlYShyaWdodEMpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodFIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFkZCBwb3NzaWJsZSByaWdodCByb29tIGFyZWFcIiwgcm9vbSwgcmlnaHRDLCByaWdodFIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3NpYmxlLnB1c2gobmV3IFBvc3NpYmxlKHJpZ2h0UiwgcmlnaHRDLCBEaXJlY3Rpb24uUklHSFQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdEMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwb3NzaWJsZSBsZWZ0IGNvcnJpZG9yIGFyZWFcIiwgcm9vbSwgbGVmdEMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSID0gdGhpcy5maW5kTGVmdFJvb21BcmVhKGxlZnRDKTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdFIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFkZCBwb3NzaWJsZSBsZWZ0IHJvb20gYXJlYVwiLCByb29tLCBsZWZ0QywgbGVmdFIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc3NpYmxlLnB1c2gobmV3IFBvc3NpYmxlKGxlZnRSLCBsZWZ0QywgRGlyZWN0aW9uLkxFRlQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicG9zc2libGVcIiwgWy4uLnRoaXMucG9zc2libGVdKTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJvb21zXCIsIFsuLi50aGlzLnJvb21zXSk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb3JyaWRvcnNWXCIsIFsuLi50aGlzLmNvcnJpZG9yc1ZdKTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvcnJpZG9yc0hcIiwgWy4uLnRoaXMuY29ycmlkb3JzSF0pO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3NzaWJsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcy5ybmcubmV4dFJhbmdlKDAsIHRoaXMucG9zc2libGUubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlID0gdGhpcy5wb3NzaWJsZVtpXTtcbiAgICAgICAgICAgIHRoaXMucG9zc2libGUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgc3dpdGNoIChwb3NzaWJsZS5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIERpcmVjdGlvbi5UT1A6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdlbmVyYXRlVG9wUm9vbShwb3NzaWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlyZWN0aW9uLkJPVFRPTTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVCb3R0b21Sb29tKHBvc3NpYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb24uUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdlbmVyYXRlUmlnaHRSb29tKHBvc3NpYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb24uTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVMZWZ0Um9vbShwb3NzaWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmluZFRvcENvcnJpZG9yQXJlYShyb29tKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IE11dGFibGVSZWN0LmZyb20ocm9vbSk7XG4gICAgICAgIGJ1ZmZlci5oID0gdGhpcy5taW5fY29ycl9kaXN0X3k7XG4gICAgICAgIGJ1ZmZlci55IC09IHRoaXMubWluX2NvcnJfZGlzdF95O1xuICAgICAgICBidWZmZXIueCArPSB0aGlzLnhfZGlzdDtcbiAgICAgICAgYnVmZmVyLncgLT0gdGhpcy54X2Rpc3QgPDwgMTtcbiAgICAgICAgbGV0IGggPSAtMTtcbiAgICAgICAgbGV0IHkgPSAtMTtcbiAgICAgICAgZm9yICg7IGJ1ZmZlci5oIDw9IHRoaXMubWF4X2NvcnJfZGlzdDsgYnVmZmVyLmgrKywgYnVmZmVyLnktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsaWQoYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIGggPSBidWZmZXIuaDtcbiAgICAgICAgICAgICAgICB5ID0gYnVmZmVyLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaCA+PSAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgYnVmZmVyLmggPSBoO1xuICAgICAgICAgICAgYnVmZmVyLnkgPSB5O1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5pbW11dGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRCb3R0b21Db3JyaWRvckFyZWEocm9vbSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBNdXRhYmxlUmVjdC5mcm9tKHJvb20pO1xuICAgICAgICBidWZmZXIueSArPSByb29tLmg7XG4gICAgICAgIGJ1ZmZlci5oID0gdGhpcy5taW5fY29ycl9kaXN0X3k7XG4gICAgICAgIGJ1ZmZlci54ICs9IHRoaXMueF9kaXN0O1xuICAgICAgICBidWZmZXIudyAtPSB0aGlzLnhfZGlzdCA8PCAxO1xuICAgICAgICBsZXQgaCA9IC0xO1xuICAgICAgICBmb3IgKDsgYnVmZmVyLmggPCB0aGlzLm1heF9jb3JyX2Rpc3Q7IGJ1ZmZlci5oKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICBoID0gYnVmZmVyLmg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaCA+PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIuaCA9IGg7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLmltbXV0YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZFJpZ2h0Q29ycmlkb3JBcmVhKHJvb20pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gTXV0YWJsZVJlY3QuZnJvbShyb29tKTtcbiAgICAgICAgYnVmZmVyLnggKz0gYnVmZmVyLnc7XG4gICAgICAgIGJ1ZmZlci55ICs9IHRoaXMueV9kaXN0O1xuICAgICAgICBidWZmZXIuaCAtPSB0aGlzLnlfZGlzdCA8PCAxO1xuICAgICAgICBsZXQgdyA9IC0xO1xuICAgICAgICBmb3IgKDsgYnVmZmVyLncgPCB0aGlzLm1heF9jb3JyX2Rpc3Q7IGJ1ZmZlci53KyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICB3ID0gYnVmZmVyLnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodyA+PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIudyA9IHc7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLmltbXV0YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZExlZnRDb3JyaWRvckFyZWEocm9vbSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBNdXRhYmxlUmVjdC5mcm9tKHJvb20pO1xuICAgICAgICBidWZmZXIudyA9IHRoaXMubWluX2NvcnJfZGlzdF94O1xuICAgICAgICBidWZmZXIueCAtPSB0aGlzLm1pbl9jb3JyX2Rpc3RfeDtcbiAgICAgICAgYnVmZmVyLnkgKz0gdGhpcy55X2Rpc3Q7XG4gICAgICAgIGJ1ZmZlci5oIC09IHRoaXMueV9kaXN0IDw8IDE7XG4gICAgICAgIGxldCB3ID0gLTE7XG4gICAgICAgIGxldCB4ID0gLTE7XG4gICAgICAgIGZvciAoOyBidWZmZXIudyA8PSB0aGlzLm1heF9jb3JyX2Rpc3Q7IGJ1ZmZlci53KyssIGJ1ZmZlci54LS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICB3ID0gYnVmZmVyLnc7XG4gICAgICAgICAgICAgICAgeCA9IGJ1ZmZlci54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHcgPj0gMCAmJiB4ID49IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlci53ID0gdztcbiAgICAgICAgICAgIGJ1ZmZlci54ID0geDtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuaW1tdXRhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kVG9wUm9vbUFyZWEoY29ycmlkb3IpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gTXV0YWJsZVJlY3QuZnJvbShjb3JyaWRvcik7XG4gICAgICAgIGJ1ZmZlci5oIC09IHRoaXMubWluX2NvcnJfZGlzdF95O1xuICAgICAgICBidWZmZXIueCAtPSB0aGlzLnhfZGlzdDtcbiAgICAgICAgYnVmZmVyLncgKz0gdGhpcy54X2Rpc3QgPDwgMTtcbiAgICAgICAgaWYgKGJ1ZmZlci5oIDwgdGhpcy5yb29tX21pbl9oKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gdGhpcy5yb29tX21pbl9oIC0gYnVmZmVyLmg7XG4gICAgICAgICAgICBidWZmZXIuaCArPSBkO1xuICAgICAgICAgICAgYnVmZmVyLnkgLT0gZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeSA9IGJ1ZmZlci55O1xuICAgICAgICBsZXQgaCA9IGJ1ZmZlci5oO1xuICAgICAgICBmb3IgKDsgYnVmZmVyLmggPD0gdGhpcy5yb29tX21heF9oOyBidWZmZXIuaCsrLCBidWZmZXIueS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZChidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgaCA9IGJ1ZmZlci5oO1xuICAgICAgICAgICAgICAgIHkgPSBidWZmZXIueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5oID0gaDtcbiAgICAgICAgICAgICAgICBidWZmZXIueSA9IHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPj0gMCAmJiBoID49IDApIHtcbiAgICAgICAgICAgIGxldCB4ID0gYnVmZmVyLng7XG4gICAgICAgICAgICBsZXQgdyA9IGJ1ZmZlci53O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtaW5feCA9IGNvcnJpZG9yLnggKyB0aGlzLnhfZGlzdCArIDEgLSB0aGlzLnJvb21fbWF4X3c7IGJ1ZmZlci54ID4gbWluX3g7IGJ1ZmZlci54LS0sIGJ1ZmZlci53KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWxpZChidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBidWZmZXIueDtcbiAgICAgICAgICAgICAgICAgICAgdyA9IGJ1ZmZlci53O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnggPSB4O1xuICAgICAgICAgICAgYnVmZmVyLncgPSB3O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXhfeCA9IGNvcnJpZG9yLnggKyBjb3JyaWRvci53IC0gdGhpcy54X2Rpc3QgLSAxICsgdGhpcy5yb29tX21heF93OyBidWZmZXIueCArIGJ1ZmZlci53IDwgbWF4X3g7IGJ1ZmZlci53KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWxpZChidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBidWZmZXIudztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci53ID0gdztcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuaW1tdXRhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbmRCb3R0b21Sb29tQXJlYShjb3JyaWRvcikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBNdXRhYmxlUmVjdC5mcm9tKGNvcnJpZG9yKTtcbiAgICAgICAgYnVmZmVyLnkgKz0gdGhpcy5taW5fY29ycl9kaXN0X3k7XG4gICAgICAgIGJ1ZmZlci5oIC09IHRoaXMubWluX2NvcnJfZGlzdF95O1xuICAgICAgICBidWZmZXIueCAtPSB0aGlzLnhfZGlzdDtcbiAgICAgICAgYnVmZmVyLncgKz0gdGhpcy54X2Rpc3QgPDwgMTtcbiAgICAgICAgaWYgKGJ1ZmZlci5oIDwgdGhpcy5yb29tX21pbl9oKSB7XG4gICAgICAgICAgICBidWZmZXIuaCA9IHRoaXMucm9vbV9taW5faDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaCA9IGJ1ZmZlci5oO1xuICAgICAgICBmb3IgKDsgYnVmZmVyLmggPD0gdGhpcy5yb29tX21heF9oOyBidWZmZXIuaCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZChidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgaCA9IGJ1ZmZlci5oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmggPSBoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoID49IDApIHtcbiAgICAgICAgICAgIGxldCB4ID0gYnVmZmVyLng7XG4gICAgICAgICAgICBsZXQgdyA9IGJ1ZmZlci53O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtaW5feCA9IGNvcnJpZG9yLnggKyB0aGlzLnhfZGlzdCArIDEgLSB0aGlzLnJvb21fbWF4X3c7IGJ1ZmZlci54ID4gbWluX3g7IGJ1ZmZlci54LS0sIGJ1ZmZlci53KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWxpZChidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBidWZmZXIueDtcbiAgICAgICAgICAgICAgICAgICAgdyA9IGJ1ZmZlci53O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnggPSB4O1xuICAgICAgICAgICAgYnVmZmVyLncgPSB3O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXhfeCA9IGNvcnJpZG9yLnggKyBjb3JyaWRvci53IC0gdGhpcy54X2Rpc3QgLSAxICsgdGhpcy5yb29tX21heF93OyBidWZmZXIueCArIGJ1ZmZlci53IDwgbWF4X3g7IGJ1ZmZlci53KyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWxpZChidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBidWZmZXIudztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci53ID0gdztcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuaW1tdXRhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbmRSaWdodFJvb21BcmVhKGNvcnJpZG9yKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IE11dGFibGVSZWN0LmZyb20oY29ycmlkb3IpO1xuICAgICAgICBidWZmZXIueCArPSB0aGlzLm1pbl9jb3JyX2Rpc3RfeDtcbiAgICAgICAgYnVmZmVyLncgLT0gdGhpcy5taW5fY29ycl9kaXN0X3g7XG4gICAgICAgIGJ1ZmZlci55IC09IHRoaXMueV9kaXN0O1xuICAgICAgICBidWZmZXIuaCArPSB0aGlzLnlfZGlzdCA8PCAxO1xuICAgICAgICBpZiAoYnVmZmVyLncgPCB0aGlzLnJvb21fbWluX3cpIHtcbiAgICAgICAgICAgIGJ1ZmZlci53ID0gdGhpcy5yb29tX21pbl93O1xuICAgICAgICB9XG4gICAgICAgIGxldCB3ID0gYnVmZmVyLnc7XG4gICAgICAgIGZvciAoOyBidWZmZXIudyA8PSB0aGlzLnJvb21fbWF4X3c7IGJ1ZmZlci53KyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICB3ID0gYnVmZmVyLnc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXIudyA9IHc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHcgPj0gMCkge1xuICAgICAgICAgICAgbGV0IHkgPSBidWZmZXIueTtcbiAgICAgICAgICAgIGxldCBoID0gYnVmZmVyLmg7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1pbl95ID0gY29ycmlkb3IueSArIHRoaXMueV9kaXN0ICsgMSAtIHRoaXMucm9vbV9tYXhfaDsgYnVmZmVyLnkgPiBtaW5feTsgYnVmZmVyLnktLSwgYnVmZmVyLmgrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGJ1ZmZlci55O1xuICAgICAgICAgICAgICAgICAgICBoID0gYnVmZmVyLmg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIueSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5oID0gaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBtYXhfeSA9IGNvcnJpZG9yLnkgKyBjb3JyaWRvci5oIC0gdGhpcy55X2Rpc3QgLSAxICsgdGhpcy5yb29tX21heF9oOyBidWZmZXIueSArIGJ1ZmZlci5oIDwgbWF4X3k7IGJ1ZmZlci5oKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWxpZChidWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGggPSBidWZmZXIuaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5oID0gaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5pbW11dGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZmluZExlZnRSb29tQXJlYShjb3JyaWRvcikge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBNdXRhYmxlUmVjdC5mcm9tKGNvcnJpZG9yKTtcbiAgICAgICAgYnVmZmVyLncgLT0gdGhpcy5taW5fY29ycl9kaXN0X3g7XG4gICAgICAgIGJ1ZmZlci55IC09IHRoaXMueV9kaXN0O1xuICAgICAgICBidWZmZXIuaCArPSB0aGlzLnlfZGlzdCA8PCAxO1xuICAgICAgICBpZiAoYnVmZmVyLncgPCB0aGlzLnJvb21fbWluX3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLnJvb21fbWluX3cgLSBidWZmZXIudztcbiAgICAgICAgICAgIGJ1ZmZlci53ICs9IGQ7XG4gICAgICAgICAgICBidWZmZXIueCAtPSBkO1xuICAgICAgICB9XG4gICAgICAgIGxldCB4ID0gYnVmZmVyLng7XG4gICAgICAgIGxldCB3ID0gYnVmZmVyLnc7XG4gICAgICAgIGZvciAoOyBidWZmZXIudyA8PSB0aGlzLnJvb21fbWF4X3c7IGJ1ZmZlci53KyssIGJ1ZmZlci54LS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICB3ID0gYnVmZmVyLnc7XG4gICAgICAgICAgICAgICAgeCA9IGJ1ZmZlci54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnggPSB4O1xuICAgICAgICAgICAgICAgIGJ1ZmZlci53ID0gdztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA+PSAwICYmIHcgPj0gMCkge1xuICAgICAgICAgICAgbGV0IHkgPSBidWZmZXIueTtcbiAgICAgICAgICAgIGxldCBoID0gYnVmZmVyLmg7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1pbl95ID0gY29ycmlkb3IueSArIHRoaXMueV9kaXN0ICsgMSAtIHRoaXMucm9vbV9tYXhfaDsgYnVmZmVyLnkgPiBtaW5feTsgYnVmZmVyLnktLSwgYnVmZmVyLmgrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGJ1ZmZlci55O1xuICAgICAgICAgICAgICAgICAgICBoID0gYnVmZmVyLmg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIueSA9IHk7XG4gICAgICAgICAgICBidWZmZXIuaCA9IGg7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1heF95ID0gY29ycmlkb3IueSAtIHRoaXMueV9kaXN0IC0gMSArIHRoaXMucm9vbV9tYXhfaDsgYnVmZmVyLnkgKyBidWZmZXIuaCA8IG1heF95OyBidWZmZXIuaCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWQoYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBoID0gYnVmZmVyLmg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuaCA9IGg7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLmltbXV0YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwibGVmdCByb29tIGFyZWEgbm90IHZhbGlkXCIsIGNvcnJpZG9yLCBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZW5lcmF0ZVRvcFJvb20ocG9zc2libGUpIHtcbiAgICAgICAgY29uc3QgY29ycl93ID0gdGhpcy5uZXh0UmFuZ2UoMSwgTWF0aC5taW4odGhpcy5tYXhfY29ycl93aWR0aCwgcG9zc2libGUuY29ycmlkb3IudykpO1xuICAgICAgICBjb25zdCBjb3JyX2ggPSB0aGlzLm5leHRSYW5nZSh0aGlzLm1pbl9jb3JyX2Rpc3RfeSwgcG9zc2libGUuY29ycmlkb3IuaCk7XG4gICAgICAgIGNvbnN0IGNvcnJfeSA9IHBvc3NpYmxlLmNvcnJpZG9yLnkgKyAocG9zc2libGUuY29ycmlkb3IuaCAtIGNvcnJfaCk7XG4gICAgICAgIGNvbnN0IGNvcnJfeCA9IHRoaXMubmV4dFJhbmdlKHBvc3NpYmxlLmNvcnJpZG9yLngsIHBvc3NpYmxlLmNvcnJpZG9yLnggKyBwb3NzaWJsZS5jb3JyaWRvci53IC0gY29ycl93KTtcbiAgICAgICAgY29uc3QgY29yciA9IG5ldyBJbW11dGFibGVSZWN0KGNvcnJfeCwgY29ycl95LCBjb3JyX3csIGNvcnJfaCk7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkKGNvcnIuZXhwYW5kVigpKSkge1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9taW5feSA9IE1hdGgubWF4KDMsIHBvc3NpYmxlLnJvb20ueSwgY29yci55IC0gdGhpcy5yb29tX21heF9oKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb21feSA9IHRoaXMubmV4dFJhbmdlKHJvb21fbWluX3ksIGNvcnIueSAtIHRoaXMucm9vbV9taW5faCk7XG4gICAgICAgICAgICBjb25zdCByb29tX2ggPSBjb3JyLnkgLSByb29tX3k7XG4gICAgICAgICAgICBjb25zdCByb29tX21heF94ID0gY29yci54IC0gdGhpcy54X2Rpc3Q7XG4gICAgICAgICAgICBjb25zdCByb29tX21pbl94ID0gTWF0aC5tYXgoMiwgcG9zc2libGUucm9vbS54LCBjb3JyLnggKyBjb3JyLncgKyB0aGlzLnhfZGlzdCAtIHRoaXMucm9vbV9tYXhfdyk7XG4gICAgICAgICAgICBjb25zdCByb29tX3ggPSB0aGlzLm5leHRSYW5nZShyb29tX21pbl94LCByb29tX21heF94KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fbWluX3JpZ2h0X3ggPSBjb3JyLnggKyBjb3JyLncgKyB0aGlzLnhfZGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fbWF4X3JpZ2h0X3ggPSBNYXRoLm1pbihwb3NzaWJsZS5yb29tLnggKyBwb3NzaWJsZS5yb29tLncsIHJvb21feCArIHRoaXMucm9vbV9tYXhfdyk7XG4gICAgICAgICAgICBjb25zdCByb29tX3JpZ2h0X3ggPSB0aGlzLm5leHRSYW5nZShyb29tX21pbl9yaWdodF94LCByb29tX21heF9yaWdodF94KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fdyA9IHJvb21fcmlnaHRfeCAtIHJvb21feDtcbiAgICAgICAgICAgIGNvbnN0IHJvb20gPSBuZXcgSW1tdXRhYmxlUmVjdChyb29tX3gsIHJvb21feSwgcm9vbV93LCByb29tX2gpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsaWQocm9vbS5leHBhbmQoKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZGQgdG9wIHJvb21cIiwgY29yciwgcm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JyaWRvcnNWLnB1c2goY29ycik7XG4gICAgICAgICAgICAgICAgdGhpcy5yb29tcy5wdXNoKHJvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFdpdGhPdGhlcnMocm9vbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwidG9wIHJvb20gbm90IHZhbGlkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwidG9wIGNvcnJpZG9yIG5vdCB2YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdlbmVyYXRlQm90dG9tUm9vbShwb3NzaWJsZSkge1xuICAgICAgICBjb25zdCBjb3JyX3kgPSBwb3NzaWJsZS5jb3JyaWRvci55O1xuICAgICAgICBjb25zdCBjb3JyX3cgPSB0aGlzLm5leHRSYW5nZSgxLCBNYXRoLm1pbih0aGlzLm1heF9jb3JyX3dpZHRoLCBwb3NzaWJsZS5jb3JyaWRvci53KSk7XG4gICAgICAgIGNvbnN0IGNvcnJfaCA9IHRoaXMubmV4dFJhbmdlKHRoaXMubWluX2NvcnJfZGlzdF95LCBwb3NzaWJsZS5jb3JyaWRvci5oKTtcbiAgICAgICAgY29uc3QgY29ycl94ID0gdGhpcy5uZXh0UmFuZ2UocG9zc2libGUuY29ycmlkb3IueCwgcG9zc2libGUuY29ycmlkb3IueCArIHBvc3NpYmxlLmNvcnJpZG9yLncgLSBjb3JyX3cpO1xuICAgICAgICBjb25zdCBjb3JyID0gbmV3IEltbXV0YWJsZVJlY3QoY29ycl94LCBjb3JyX3ksIGNvcnJfdywgY29ycl9oKTtcbiAgICAgICAgaWYgKHRoaXMudmFsaWQoY29yci5leHBhbmRWKCkpKSB7XG4gICAgICAgICAgICBjb25zdCByb29tX3kgPSBjb3JyLnkgKyBjb3JyLmg7XG4gICAgICAgICAgICBjb25zdCByb29tX21pbl95ID0gcm9vbV95ICsgdGhpcy5yb29tX21pbl9oO1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9tYXhfeSA9IE1hdGgubWluKHBvc3NpYmxlLnJvb20ueSArIHBvc3NpYmxlLnJvb20uaCwgcm9vbV9taW5feSArIHRoaXMucm9vbV9tYXhfaCk7XG4gICAgICAgICAgICBjb25zdCByb29tX2JvdHRvbV95ID0gdGhpcy5uZXh0UmFuZ2Uocm9vbV9taW5feSwgcm9vbV9tYXhfeSk7XG4gICAgICAgICAgICBjb25zdCByb29tX2ggPSByb29tX2JvdHRvbV95IC0gcm9vbV95O1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9tYXhfeCA9IGNvcnIueCAtIHRoaXMueF9kaXN0O1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9taW5feCA9IE1hdGgubWF4KDIsIHBvc3NpYmxlLnJvb20ueCwgY29yci54ICsgY29yci53ICsgdGhpcy54X2Rpc3QgLSB0aGlzLnJvb21fbWF4X3cpO1xuICAgICAgICAgICAgY29uc3Qgcm9vbV94ID0gdGhpcy5uZXh0UmFuZ2Uocm9vbV9taW5feCwgcm9vbV9tYXhfeCk7XG4gICAgICAgICAgICBjb25zdCByb29tX21pbl9yaWdodF94ID0gY29yci54ICsgY29yci53ICsgdGhpcy54X2Rpc3Q7XG4gICAgICAgICAgICBjb25zdCByb29tX21heF9yaWdodF94ID0gTWF0aC5taW4ocG9zc2libGUucm9vbS54ICsgcG9zc2libGUucm9vbS53LCByb29tX3ggKyB0aGlzLnJvb21fbWF4X3cpO1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9yaWdodF94ID0gdGhpcy5uZXh0UmFuZ2Uocm9vbV9taW5fcmlnaHRfeCwgcm9vbV9tYXhfcmlnaHRfeCk7XG4gICAgICAgICAgICBjb25zdCByb29tX3cgPSByb29tX3JpZ2h0X3ggLSByb29tX3g7XG4gICAgICAgICAgICBjb25zdCByb29tID0gbmV3IEltbXV0YWJsZVJlY3Qocm9vbV94LCByb29tX3ksIHJvb21fdywgcm9vbV9oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkKHJvb20uZXhwYW5kKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWRkIGJvdHRvbSByb29tXCIsIGNvcnIsIHJvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ycmlkb3JzVi5wdXNoKGNvcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vbXMucHVzaChyb29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RXaXRoT3RoZXJzKHJvb20pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImJvdHRvbSByb29tIG5vdCB2YWxpZFwiLCBjb3JyLCByb29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImJvdHRvbSBjb3JyaWRvciBub3QgdmFsaWRcIiwgY29ycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZW5lcmF0ZVJpZ2h0Um9vbShwb3NzaWJsZSkge1xuICAgICAgICBjb25zdCBjb3JyX3ggPSBwb3NzaWJsZS5jb3JyaWRvci54O1xuICAgICAgICBjb25zdCBjb3JyX2ggPSB0aGlzLm5leHRSYW5nZSgxLCBNYXRoLm1pbih0aGlzLm1heF9jb3JyX3dpZHRoLCBwb3NzaWJsZS5jb3JyaWRvci5oKSk7XG4gICAgICAgIGNvbnN0IGNvcnJfdyA9IHRoaXMubmV4dFJhbmdlKHRoaXMubWluX2NvcnJfZGlzdF94LCBwb3NzaWJsZS5jb3JyaWRvci53KTtcbiAgICAgICAgY29uc3QgY29ycl95ID0gdGhpcy5uZXh0UmFuZ2UocG9zc2libGUuY29ycmlkb3IueSwgcG9zc2libGUuY29ycmlkb3IueSArIHBvc3NpYmxlLmNvcnJpZG9yLmggLSBjb3JyX2gpO1xuICAgICAgICBjb25zdCBjb3JyID0gbmV3IEltbXV0YWJsZVJlY3QoY29ycl94LCBjb3JyX3ksIGNvcnJfdywgY29ycl9oKTtcbiAgICAgICAgaWYgKHRoaXMudmFsaWQoY29yci5leHBhbmRIKCkpKSB7XG4gICAgICAgICAgICBjb25zdCByb29tX3ggPSBjb3JyLnggKyBjb3JyLnc7XG4gICAgICAgICAgICBjb25zdCByb29tX21pbl94ID0gcm9vbV94ICsgdGhpcy5yb29tX21pbl93O1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9tYXhfeCA9IE1hdGgubWluKHBvc3NpYmxlLnJvb20ueCArIHBvc3NpYmxlLnJvb20udywgcm9vbV9taW5feCArIHRoaXMucm9vbV9tYXhfdyk7XG4gICAgICAgICAgICBjb25zdCByb29tX3JpZ2h0X3ggPSB0aGlzLm5leHRSYW5nZShyb29tX21pbl94LCByb29tX21heF94KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fdyA9IHJvb21fcmlnaHRfeCAtIHJvb21feDtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fbWF4X3kgPSBjb3JyLnkgLSB0aGlzLnlfZGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fbWluX3kgPSBNYXRoLm1heCgyLCBwb3NzaWJsZS5yb29tLnksIGNvcnIueSArIGNvcnIuaCArIHRoaXMueV9kaXN0IC0gdGhpcy5yb29tX21heF9oKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb21feSA9IHRoaXMubmV4dFJhbmdlKHJvb21fbWluX3ksIHJvb21fbWF4X3kpO1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9taW5fYm90dG9tX3kgPSBjb3JyLnkgKyBjb3JyLmggKyB0aGlzLnlfZGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fbWF4X2JvdHRvbV95ID0gTWF0aC5taW4ocG9zc2libGUucm9vbS55ICsgcG9zc2libGUucm9vbS5oLCByb29tX3kgKyB0aGlzLnJvb21fbWF4X2gpO1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9ib3R0b21feSA9IHRoaXMubmV4dFJhbmdlKHJvb21fbWluX2JvdHRvbV95LCByb29tX21heF9ib3R0b21feSk7XG4gICAgICAgICAgICBjb25zdCByb29tX2ggPSByb29tX2JvdHRvbV95IC0gcm9vbV95O1xuICAgICAgICAgICAgY29uc3Qgcm9vbSA9IG5ldyBJbW11dGFibGVSZWN0KHJvb21feCwgcm9vbV95LCByb29tX3csIHJvb21faCk7XG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZChyb29tLmV4cGFuZCgpKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFkZCByaWdodCByb29tXCIsIGNvcnIsIHJvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ycmlkb3JzSC5wdXNoKGNvcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMucm9vbXMucHVzaChyb29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RXaXRoT3RoZXJzKHJvb20pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInJpZ2h0IHJvb20gbm90IHZhbGlkXCIsIGNvcnIsIHJvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwicmlnaHQgY29ycmlkb3Igbm90IHZhbGlkXCIsIGNvcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2VuZXJhdGVMZWZ0Um9vbShwb3NzaWJsZSkge1xuICAgICAgICBjb25zdCBjb3JyX2ggPSB0aGlzLm5leHRSYW5nZSgxLCBNYXRoLm1pbih0aGlzLm1heF9jb3JyX3dpZHRoLCBwb3NzaWJsZS5jb3JyaWRvci5oKSk7XG4gICAgICAgIGNvbnN0IGNvcnJfdyA9IHRoaXMubmV4dFJhbmdlKHRoaXMubWluX2NvcnJfZGlzdF94LCBwb3NzaWJsZS5jb3JyaWRvci53KTtcbiAgICAgICAgY29uc3QgY29ycl94ID0gcG9zc2libGUuY29ycmlkb3IueCArIChwb3NzaWJsZS5jb3JyaWRvci53IC0gY29ycl93KTtcbiAgICAgICAgY29uc3QgY29ycl95ID0gdGhpcy5uZXh0UmFuZ2UocG9zc2libGUuY29ycmlkb3IueSwgcG9zc2libGUuY29ycmlkb3IueSArIHBvc3NpYmxlLmNvcnJpZG9yLmggLSBjb3JyX2gpO1xuICAgICAgICBjb25zdCBjb3JyID0gbmV3IEltbXV0YWJsZVJlY3QoY29ycl94LCBjb3JyX3ksIGNvcnJfdywgY29ycl9oKTtcbiAgICAgICAgaWYgKHRoaXMudmFsaWQoY29yci5leHBhbmRIKCkpKSB7XG4gICAgICAgICAgICBjb25zdCByb29tX21pbl94ID0gTWF0aC5tYXgoMiwgcG9zc2libGUucm9vbS54LCBjb3JyLnggLSB0aGlzLnJvb21fbWF4X3cpO1xuICAgICAgICAgICAgY29uc3Qgcm9vbV94ID0gdGhpcy5uZXh0UmFuZ2Uocm9vbV9taW5feCwgY29yci54IC0gdGhpcy5yb29tX21pbl93KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fdyA9IGNvcnIueCAtIHJvb21feDtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fbWF4X3kgPSBjb3JyLnkgLSB0aGlzLnlfZGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fbWluX3kgPSBNYXRoLm1heCgzLCBwb3NzaWJsZS5yb29tLnksIGNvcnIueSArIGNvcnIuaCArIHRoaXMueV9kaXN0IC0gdGhpcy5yb29tX21heF9oKTtcbiAgICAgICAgICAgIGNvbnN0IHJvb21feSA9IHRoaXMubmV4dFJhbmdlKHJvb21fbWluX3ksIHJvb21fbWF4X3kpO1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9taW5fYm90dG9tX3kgPSBjb3JyLnkgKyBjb3JyLmggKyB0aGlzLnlfZGlzdDtcbiAgICAgICAgICAgIGNvbnN0IHJvb21fbWF4X2JvdHRvbV95ID0gTWF0aC5taW4ocG9zc2libGUucm9vbS55ICsgcG9zc2libGUucm9vbS5oLCByb29tX3kgKyB0aGlzLnJvb21fbWF4X2gpO1xuICAgICAgICAgICAgY29uc3Qgcm9vbV9ib3R0b21feSA9IHRoaXMubmV4dFJhbmdlKHJvb21fbWluX2JvdHRvbV95LCByb29tX21heF9ib3R0b21feSk7XG4gICAgICAgICAgICBjb25zdCByb29tX2ggPSByb29tX2JvdHRvbV95IC0gcm9vbV95O1xuICAgICAgICAgICAgY29uc3Qgcm9vbSA9IG5ldyBJbW11dGFibGVSZWN0KHJvb21feCwgcm9vbV95LCByb29tX3csIHJvb21faCk7XG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZChyb29tLmV4cGFuZCgpKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFkZCBsZWZ0IHJvb21cIiwgY29yciwgcm9vbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3JyaWRvcnNILnB1c2goY29ycik7XG4gICAgICAgICAgICAgICAgdGhpcy5yb29tcy5wdXNoKHJvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFdpdGhPdGhlcnMocm9vbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwibGVmdCByb29tIG5vdCB2YWxpZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcImxlZnQgY29ycmlkb3Igbm90IHZhbGlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29ubmVjdFdpdGhPdGhlcnMocm9vbSkge1xuICAgICAgICBjb25zdCBhID0gcm9vbTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvb21zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgbGV0IGIgPSB0aGlzLnJvb21zW2ldO1xuICAgICAgICAgICAgY29uc3QgbWF4X3ggPSBNYXRoLm1heChhLngsIGIueCk7XG4gICAgICAgICAgICBjb25zdCBtaW5feF93ID0gTWF0aC5taW4oYS54ICsgYS53LCBiLnggKyBiLncpO1xuICAgICAgICAgICAgaWYgKG1heF94ICsgNSA8PSBtaW5feF93KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3Q7XG4gICAgICAgICAgICAgICAgaWYgKGEueSArIGEuaCA8IGIueSkge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gbmV3IEltbXV0YWJsZVJlY3QobWF4X3ggKyAyLCBhLnkgKyBhLmgsIG1pbl94X3cgLSBtYXhfeCAtIDQsIGIueSAtIGEueSAtIGEuaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0gbmV3IEltbXV0YWJsZVJlY3QobWF4X3ggKyAyLCBiLnkgKyBiLmgsIG1pbl94X3cgLSBtYXhfeCAtIDQsIGEueSAtIGIueSAtIGIuaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlc3QgdiBjb3JyXCIsIHJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LncgPCB0aGlzLm1heF9jb3JyX2Rpc3QgJiYgdGhpcy52YWxpZChyZWN0LmV4cGFuZFYoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFkZCB2IGNvcnJcIiwgcmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ycmlkb3JzVi5wdXNoKHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1heF95ID0gTWF0aC5tYXgoYS55LCBiLnkpO1xuICAgICAgICAgICAgY29uc3QgbWluX3lfaCA9IE1hdGgubWluKGEueSArIGEuaCwgYi55ICsgYi5oKTtcbiAgICAgICAgICAgIGlmIChtYXhfeSArIDMgPD0gbWluX3lfaCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0O1xuICAgICAgICAgICAgICAgIGlmIChhLnggKyBhLncgPCBiLngpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IG5ldyBJbW11dGFibGVSZWN0KGEueCArIGEudywgbWF4X3kgKyAxLCBiLnggLSBhLnggLSBhLncsIG1pbl95X2ggLSBtYXhfeSAtIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IG5ldyBJbW11dGFibGVSZWN0KGIueCArIGIudywgbWF4X3kgKyAxLCBhLnggLSBiLnggLSBiLncsIG1pbl95X2ggLSBtYXhfeSAtIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZXN0IGggY29yclwiLCByZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5oIDwgdGhpcy5tYXhfY29ycl9kaXN0ICYmIHRoaXMudmFsaWQocmVjdC5leHBhbmRIKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZGQgaCBjb3JyXCIsIHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcnJpZG9yc0gucHVzaChyZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dFJhbmdlKG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMucm5nLm5leHROb3JtYWwobWluLCBtYXgsIHRoaXMuc2tldykpO1xuICAgIH1cbn1cbnZhciBEaXJlY3Rpb247XG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJUT1BcIl0gPSAwXSA9IFwiVE9QXCI7XG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJJR0hUXCJdID0gMV0gPSBcIlJJR0hUXCI7XG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkJPVFRPTVwiXSA9IDJdID0gXCJCT1RUT01cIjtcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiTEVGVFwiXSA9IDNdID0gXCJMRUZUXCI7XG59KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5jbGFzcyBQb3NzaWJsZSB7XG4gICAgY29uc3RydWN0b3Iocm9vbSwgY29ycmlkb3IsIGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnJvb20gPSByb29tO1xuICAgICAgICB0aGlzLmNvcnJpZG9yID0gY29ycmlkb3I7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBJbmRleGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlcXVhbGl0eSkge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLmVxdWFsaXR5ID0gZXF1YWxpdHk7XG4gICAgfVxuICAgIGluZGV4KHZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsaXR5KHZhbHVlLCB0aGlzLnZhbHVlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGdldChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tuXTtcbiAgICB9XG4gICAgc3RhdGljIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZXIoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGlkZW50aXR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZXIoKGEsIGIpID0+IGEgPT09IGIpO1xuICAgIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuICAgIHBsdXModGhhdCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoYXQueCwgdGhpcy55ICsgdGhhdC55KTtcbiAgICB9XG4gICAgbWludXModGhhdCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHRoYXQueCwgdGhpcy55IC0gdGhhdC55KTtcbiAgICB9XG4gICAgbXVsdGlwbHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiB2YWx1ZSwgdGhpcy55ICogdmFsdWUpO1xuICAgIH1cbiAgICBnZXQgbmVnYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoLXRoaXMueCwgLXRoaXMueSk7XG4gICAgfVxuICAgIGVxdWFsKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0geCAmJiB0aGlzLnkgPT09IHk7XG4gICAgfVxuICAgIGVxdWFscyh0aGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHRoYXQueCAmJiB0aGlzLnkgPT09IHRoYXQueTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBge3g6ICR7dGhpcy54fSwgeTogJHt0aGlzLnl9fWA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfVxufVxuUG9pbnQuTk9SVEggPSBuZXcgUG9pbnQoLTEsIDApO1xuUG9pbnQuU09VVEggPSBuZXcgUG9pbnQoMSwgMCk7XG5Qb2ludC5FQVNUID0gbmV3IFBvaW50KDAsIDEpO1xuUG9pbnQuV0VTVCA9IG5ldyBQb2ludCgwLCAtMSk7XG5Qb2ludC5OT1JUSF9FQVNUID0gbmV3IFBvaW50KC0xLCAxKTtcblBvaW50LlNPVVRIX0VBU1QgPSBuZXcgUG9pbnQoMSwgMSk7XG5Qb2ludC5TT1VUSF9XRVNUID0gbmV3IFBvaW50KDEsIC0xKTtcblBvaW50Lk5PUlRIX1dFU1QgPSBuZXcgUG9pbnQoLTEsIC0xKTtcblBvaW50LlpFUk8gPSBuZXcgUG9pbnQoMCwgMCk7XG5leHBvcnQgdmFyIERpcmVjdGlvbjtcbihmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIk5PUlRIXCJdID0gMF0gPSBcIk5PUlRIXCI7XG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkVBU1RcIl0gPSAxXSA9IFwiRUFTVFwiO1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJTT1VUSFwiXSA9IDJdID0gXCJTT1VUSFwiO1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJXRVNUXCJdID0gM10gPSBcIldFU1RcIjtcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiTk9SVEhfRUFTVFwiXSA9IDRdID0gXCJOT1JUSF9FQVNUXCI7XG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlNPVVRIX0VBU1RcIl0gPSA1XSA9IFwiU09VVEhfRUFTVFwiO1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJTT1VUSF9XRVNUXCJdID0gNl0gPSBcIlNPVVRIX1dFU1RcIjtcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiTk9SVEhfV0VTVFwiXSA9IDddID0gXCJOT1JUSF9XRVNUXCI7XG59KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5leHBvcnQgdmFyIFR1bm5lbGVyQ2VsbFR5cGU7XG4oZnVuY3Rpb24gKFR1bm5lbGVyQ2VsbFR5cGUpIHtcbiAgICBUdW5uZWxlckNlbGxUeXBlW1R1bm5lbGVyQ2VsbFR5cGVbXCJPUEVOXCJdID0gMF0gPSBcIk9QRU5cIjtcbiAgICBUdW5uZWxlckNlbGxUeXBlW1R1bm5lbGVyQ2VsbFR5cGVbXCJDTE9TRURcIl0gPSAxXSA9IFwiQ0xPU0VEXCI7XG4gICAgVHVubmVsZXJDZWxsVHlwZVtUdW5uZWxlckNlbGxUeXBlW1wiR1VBUkFOVEVFRF9PUEVOXCJdID0gMl0gPSBcIkdVQVJBTlRFRURfT1BFTlwiO1xuICAgIFR1bm5lbGVyQ2VsbFR5cGVbVHVubmVsZXJDZWxsVHlwZVtcIkdVQVJBTlRFRURfQ0xPU0VEXCJdID0gM10gPSBcIkdVQVJBTlRFRURfQ0xPU0VEXCI7XG4gICAgVHVubmVsZXJDZWxsVHlwZVtUdW5uZWxlckNlbGxUeXBlW1wiTk9OX0pPSU5fT1BFTlwiXSA9IDRdID0gXCJOT05fSk9JTl9PUEVOXCI7XG4gICAgVHVubmVsZXJDZWxsVHlwZVtUdW5uZWxlckNlbGxUeXBlW1wiTk9OX0pPSU5fQ0xPU0VEXCJdID0gNV0gPSBcIk5PTl9KT0lOX0NMT1NFRFwiO1xuICAgIFR1bm5lbGVyQ2VsbFR5cGVbVHVubmVsZXJDZWxsVHlwZVtcIk5PTl9KT0lOX0dVQVJBTlRFRURfT1BFTlwiXSA9IDZdID0gXCJOT05fSk9JTl9HVUFSQU5URUVEX09QRU5cIjtcbiAgICBUdW5uZWxlckNlbGxUeXBlW1R1bm5lbGVyQ2VsbFR5cGVbXCJOT05fSk9JTl9HVUFSQU5URUVEX0NMT1NFRFwiXSA9IDddID0gXCJOT05fSk9JTl9HVUFSQU5URUVEX0NMT1NFRFwiO1xuICAgIFR1bm5lbGVyQ2VsbFR5cGVbVHVubmVsZXJDZWxsVHlwZVtcIklOU0lERV9ST09NX09QRU5cIl0gPSA4XSA9IFwiSU5TSURFX1JPT01fT1BFTlwiO1xuICAgIFR1bm5lbGVyQ2VsbFR5cGVbVHVubmVsZXJDZWxsVHlwZVtcIklOU0lERV9UVU5ORUxfT1BFTlwiXSA9IDldID0gXCJJTlNJREVfVFVOTkVMX09QRU5cIjtcbiAgICBUdW5uZWxlckNlbGxUeXBlW1R1bm5lbGVyQ2VsbFR5cGVbXCJJTlNJREVfQU5URVJPT01fT1BFTlwiXSA9IDEwXSA9IFwiSU5TSURFX0FOVEVST09NX09QRU5cIjtcbiAgICBUdW5uZWxlckNlbGxUeXBlW1R1bm5lbGVyQ2VsbFR5cGVbXCJIX0RPT1JcIl0gPSAxMV0gPSBcIkhfRE9PUlwiO1xuICAgIFR1bm5lbGVyQ2VsbFR5cGVbVHVubmVsZXJDZWxsVHlwZVtcIlZfRE9PUlwiXSA9IDEyXSA9IFwiVl9ET09SXCI7XG4gICAgVHVubmVsZXJDZWxsVHlwZVtUdW5uZWxlckNlbGxUeXBlW1wiQ09MVU1OXCJdID0gMTNdID0gXCJDT0xVTU5cIjtcbn0pKFR1bm5lbGVyQ2VsbFR5cGUgfHwgKFR1bm5lbGVyQ2VsbFR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBSb29tU2l6ZTtcbihmdW5jdGlvbiAoUm9vbVNpemUpIHtcbiAgICBSb29tU2l6ZVtSb29tU2l6ZVtcIlNNQUxMXCJdID0gMF0gPSBcIlNNQUxMXCI7XG4gICAgUm9vbVNpemVbUm9vbVNpemVbXCJNRURJVU1cIl0gPSAxXSA9IFwiTUVESVVNXCI7XG4gICAgUm9vbVNpemVbUm9vbVNpemVbXCJMQVJHRVwiXSA9IDJdID0gXCJMQVJHRVwiO1xufSkoUm9vbVNpemUgfHwgKFJvb21TaXplID0ge30pKTtcbmV4cG9ydCBjbGFzcyBSb29tIHtcbiAgICBjb25zdHJ1Y3RvcihpbnNpZGUgPSBbXSkge1xuICAgICAgICB0aGlzLmluc2lkZSA9IGluc2lkZTtcbiAgICAgICAgdGhpcy5pbkR1bmdlb24gPSBmYWxzZTtcbiAgICB9XG4gICAgcmFuZG9tU3F1YXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNpZGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5pbnNpZGUubGVuZ3RoKV07XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Lmluc2lkZS5sZW5ndGggLSBzZWNvbmQuaW5zaWRlLmxlbmd0aDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRmlsbFJlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCB0eXBlKSB7XG4gICAgICAgIHRoaXMuc3RhcnRYID0gc3RhcnRYO1xuICAgICAgICB0aGlzLnN0YXJ0WSA9IHN0YXJ0WTtcbiAgICAgICAgdGhpcy5lbmRYID0gZW5kWDtcbiAgICAgICAgdGhpcy5lbmRZID0gZW5kWTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUdW5uZWxlckNlbGxUeXBlLCBQb2ludCB9IGZyb20gXCIuL21vZGVsXCI7XG5leHBvcnQgY2xhc3MgQ3Jhd2xlciB7XG4gICAgY29uc3RydWN0b3Iocm5nLCBkdW5nZW9uQ3Jhd2xlciwgbG9jYXRpb24sIGRpcmVjdGlvbiwgYWdlLCBtYXhBZ2UsIGdlbmVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5ybmcgPSBybmc7XG4gICAgICAgIHRoaXMuZHVuZ2VvbkNyYXdsZXIgPSBkdW5nZW9uQ3Jhd2xlcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBkdW5nZW9uQ3Jhd2xlci5jb25maWc7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuYWdlID0gYWdlO1xuICAgICAgICB0aGlzLm1heEFnZSA9IG1heEFnZTtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uID0gZ2VuZXJhdGlvbjtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy52YWxpZChsb2NhdGlvbikpO1xuICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLnZhbGlkRGlyZWN0aW9uKGRpcmVjdGlvbikpO1xuICAgIH1cbiAgICByaWdodERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uLnggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5kaXJlY3Rpb24ueSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24ueSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgwLCAtdGhpcy5kaXJlY3Rpb24ueCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcImlsbGVnYWwgZGlyZWN0aW9uXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWQocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPj0gMCAmJiBwb2ludC55ID49IDAgJiYgcG9pbnQueCA8IHRoaXMuY29uZmlnLndpZHRoICYmIHBvaW50LnkgPCB0aGlzLmNvbmZpZy5oZWlnaHQ7XG4gICAgfVxuICAgIHZhbGlkRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gKGRpcmVjdGlvbi54ID09PSAwICYmIChkaXJlY3Rpb24ueSA9PT0gLTEgfHwgZGlyZWN0aW9uLnkgPT09IDEpKSB8fCAoZGlyZWN0aW9uLnkgPT09IDAgJiYgKGRpcmVjdGlvbi54ID09PSAtMSB8fCBkaXJlY3Rpb24ueCA9PT0gMSkpO1xuICAgIH1cbiAgICBmcm9udEZyZWUocG9zaXRpb24sIGhlYWRpbmcsIGxlZnRGcmVlLCByaWdodEZyZWUpIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoKGxlZnRGcmVlID49IDEpICYmIChyaWdodEZyZWUgPj0gMSkpO1xuICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLnZhbGlkKHBvc2l0aW9uKSk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGhlYWRpbmcueCA9PT0gMCAmJiAoKGhlYWRpbmcueSA9PT0gMSkgfHwgKGhlYWRpbmcueSA9PT0gLTEpKSB8fCBoZWFkaW5nLnkgPT09IDAgJiYgKChoZWFkaW5nLnggPT09IDEpIHx8IChoZWFkaW5nLnggPT09IC0xKSkpO1xuICAgICAgICBsZXQgcmlnaHQ7XG4gICAgICAgIGlmIChoZWFkaW5nLnggPT09IDApIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gbmV3IFBvaW50KGhlYWRpbmcueSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGVhZGluZy55ID09PSAwKSB7XG4gICAgICAgICAgICByaWdodCA9IG5ldyBQb2ludCgwLCAtaGVhZGluZy54KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiaW52YWxpZCBoZWFkaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbnRGcmVlID0gdGhpcy5maW5kRnJvbnRGcmVlKGxlZnRGcmVlLCByaWdodEZyZWUsIHBvc2l0aW9uLCByaWdodCwgaGVhZGluZyk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZyb250RnJlZSA+PSAwKTtcbiAgICAgICAgaWYgKGZyb250RnJlZSA+IDApIHtcbiAgICAgICAgICAgIGxlZnRGcmVlID0gdGhpcy5maW5kTGVmdEZyZWUobGVmdEZyZWUsIGZyb250RnJlZSwgcG9zaXRpb24sIHJpZ2h0LCBoZWFkaW5nKTtcbiAgICAgICAgICAgIHJpZ2h0RnJlZSA9IHRoaXMuZmluZFJpZ2h0RnJlZShyaWdodEZyZWUsIGZyb250RnJlZSwgcG9zaXRpb24sIHJpZ2h0LCBoZWFkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Zyb250RnJlZSwgbGVmdEZyZWUsIHJpZ2h0RnJlZV07XG4gICAgfVxuICAgIGZpbmRGcm9udEZyZWUobGVmdEZyZWUsIHJpZ2h0RnJlZSwgcG9zaXRpb24sIHJpZ2h0LCBoZWFkaW5nKSB7XG4gICAgICAgIGxldCBmcm9udEZyZWUgPSAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZnJvbnRGcmVlKys7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gLWxlZnRGcmVlOyBpIDw9IHJpZ2h0RnJlZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHBvc2l0aW9uLnBsdXMocmlnaHQubXVsdGlwbHkoaSkpLnBsdXMoaGVhZGluZy5tdWx0aXBseShmcm9udEZyZWUpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmFsaWQoY2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGZyb250RnJlZSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmVlUHJlZGljYXRlKHRoaXMuZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKGNlbGwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgZnJvbnRGcmVlIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRMZWZ0RnJlZShsZWZ0RnJlZSwgZnJvbnRGcmVlLCBwb3NpdGlvbiwgcmlnaHQsIGhlYWRpbmcpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxlZnRGcmVlKys7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBmcm9udEZyZWU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBwb3NpdGlvbi5taW51cyhyaWdodC5tdWx0aXBseShsZWZ0RnJlZSkpLnBsdXMoaGVhZGluZy5tdWx0aXBseShpKSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkKGNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0RnJlZSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZyZWVQcmVkaWNhdGUodGhpcy5kdW5nZW9uQ3Jhd2xlci5nZXRNYXAoY2VsbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0RnJlZSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRSaWdodEZyZWUocmlnaHRGcmVlLCBmcm9udEZyZWUsIHBvc2l0aW9uLCByaWdodCwgaGVhZGluZykge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcmlnaHRGcmVlKys7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBmcm9udEZyZWU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBwb3NpdGlvbi5wbHVzKHJpZ2h0Lm11bHRpcGx5KHJpZ2h0RnJlZSkpLnBsdXMoaGVhZGluZy5tdWx0aXBseShpKSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkKGNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodEZyZWUgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmVlUHJlZGljYXRlKHRoaXMuZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKGNlbGwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRGcmVlIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJlZVByZWRpY2F0ZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiAodHlwZSAhPT0gVHVubmVsZXJDZWxsVHlwZS5DTE9TRUQpICYmICh0eXBlICE9PSBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX0NMT1NFRCk7XG4gICAgfVxuICAgIGNvbnRhaW5zKHZhbHVlLCAuLi5vcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gb3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFR1bm5lbGVyQ2VsbFR5cGUsIFBvaW50IH0gZnJvbSBcIi4vbW9kZWxcIjtcbmltcG9ydCB7IENyYXdsZXIgfSBmcm9tIFwiLi9jcmF3bGVyXCI7XG5leHBvcnQgY2xhc3MgV2FsbENyYXdsZXIgZXh0ZW5kcyBDcmF3bGVyIHtcbiAgICBjb25zdHJ1Y3RvcihybmcsIGR1bmdlb25DcmF3bGVyLCBsb2NhdGlvbiwgZGlyZWN0aW9uLCBhZ2UsIG1heEFnZSwgZ2VuZXJhdGlvbiwgaW50ZW5kZWREaXJlY3Rpb24sIHN0ZXBMZW5ndGgsIG9wZW5pbmcsIGNvcnJpZG9yV2lkdGgsIHN0cmFpZ2h0U2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgc3RyYWlnaHREb3VibGVTcGF3blByb2JhYmlsaXR5LCB0dXJuU2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgdHVybkRvdWJsZVNwYXduUHJvYmFiaWxpdHksIGNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5KSB7XG4gICAgICAgIHN1cGVyKHJuZywgZHVuZ2VvbkNyYXdsZXIsIGxvY2F0aW9uLCBkaXJlY3Rpb24sIGFnZSwgbWF4QWdlLCBnZW5lcmF0aW9uKTtcbiAgICAgICAgdGhpcy5pbnRlbmRlZERpcmVjdGlvbiA9IGludGVuZGVkRGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnN0ZXBMZW5ndGggPSBzdGVwTGVuZ3RoO1xuICAgICAgICB0aGlzLm9wZW5pbmcgPSBvcGVuaW5nO1xuICAgICAgICB0aGlzLmNvcnJpZG9yV2lkdGggPSBjb3JyaWRvcldpZHRoO1xuICAgICAgICB0aGlzLnN0cmFpZ2h0U2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSA9IHN0cmFpZ2h0U2luZ2xlU3Bhd25Qcm9iYWJpbGl0eTtcbiAgICAgICAgdGhpcy5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHkgPSBzdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHk7XG4gICAgICAgIHRoaXMudHVyblNpbmdsZVNwYXduUHJvYmFiaWxpdHkgPSB0dXJuU2luZ2xlU3Bhd25Qcm9iYWJpbGl0eTtcbiAgICAgICAgdGhpcy50dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSA9IHR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5O1xuICAgICAgICB0aGlzLmNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5ID0gY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNvcnJpZG9yV2lkdGggPj0gMCk7XG4gICAgfVxuICAgIGZyZWVQcmVkaWNhdGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuY3Jhd2xlcnNJblR1bm5lbHMgJiYgdGhpcy5jb25maWcuY3Jhd2xlcnNJbkFudGVyb29tcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5zKHR5cGUsIFR1bm5lbGVyQ2VsbFR5cGUuT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLkdVQVJBTlRFRURfT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX0FOVEVST09NX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuTk9OX0pPSU5fR1VBUkFOVEVFRF9PUEVOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLmNyYXdsZXJzSW5UdW5uZWxzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbnModHlwZSwgVHVubmVsZXJDZWxsVHlwZS5PUEVOLCBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9HVUFSQU5URUVEX09QRU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbnModHlwZSwgVHVubmVsZXJDZWxsVHlwZS5PUEVOLCBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX0dVQVJBTlRFRURfT1BFTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0ZXBBaGVhZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGlvbiAhPT0gdGhpcy5kdW5nZW9uQ3Jhd2xlci5hY3RpdmVHZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLmdlbmVyYXRpb24gPiB0aGlzLmR1bmdlb25DcmF3bGVyLmFjdGl2ZUdlbmVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZ2UrKztcbiAgICAgICAgaWYgKHRoaXMuYWdlID49IHRoaXMubWF4QWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hZ2UgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgW2Zyb250RnJlZSwgbGVmdEZyZWUsIHJpZ2h0RnJlZV0gPSB0aGlzLmZyb250RnJlZSh0aGlzLmxvY2F0aW9uLCB0aGlzLmRpcmVjdGlvbiwgdGhpcy5jb3JyaWRvcldpZHRoLCB0aGlzLmNvcnJpZG9yV2lkdGgpO1xuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IHJpZ2h0Lm5lZ2F0aXZlO1xuICAgICAgICBsZXQgdGVzdCA9IHJpZ2h0O1xuICAgICAgICBpZiAoKHRoaXMub3BlbmluZyA9PT0gMCkgJiYgKGZyb250RnJlZSA8IHRoaXMuY29uZmlnLmpvaW5EaXN0YW5jZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmpvaW4oZnJvbnRGcmVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGlsZXNMYWlkID0gdGhpcy5zdGVwTGVuZ3RoO1xuICAgICAgICBpZiAoZnJvbnRGcmVlID4gdGhpcy5jb3JyaWRvcldpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGZyb250RnJlZSAtIHRoaXMuY29ycmlkb3JXaWR0aCkgPCB0aGlzLnN0ZXBMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aWxlc0xhaWQgPSBmcm9udEZyZWUgLSB0aGlzLmNvcnJpZG9yV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aWxlc0xhaWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHRlc3QgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoaSkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZW5pbmcgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kdW5nZW9uQ3Jhd2xlci5zZXRNYXAodGVzdCwgVHVubmVsZXJDZWxsVHlwZS5DTE9TRUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5vcGVuaW5nID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kdW5nZW9uQ3Jhd2xlci5zZXRNYXAodGVzdCwgVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9DTE9TRUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB0ZXN0O1xuICAgICAgICAgICAgbGV0IGRpY2VSb2xsID0gdGhpcy5ybmcuaW50ICUgMTAwO1xuICAgICAgICAgICAgbGV0IGNoaWxkR2VuZXJhdGlvbiA9IHRoaXMuZ2VuZXJhdGlvbiArIDE7XG4gICAgICAgICAgICBsZXQgc3VtbWVkUHJvYmFiaWxpdHkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTA7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bW1lZFByb2JhYmlsaXR5ID0gc3VtbWVkUHJvYmFiaWxpdHkgKyB0aGlzLmdldENoaWxkRGVsYXlQcm9iYWJpbGl0eUZvckdlbmVyYXRpb25DcmF3bGVycyhpKTtcbiAgICAgICAgICAgICAgICBpZiAoZGljZVJvbGwgPCBzdW1tZWRQcm9iYWJpbGl0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEdlbmVyYXRpb24gPSB0aGlzLmdlbmVyYXRpb24gKyBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHN0cmFpZ2h0U2luZ2xlU3Bhd25Qcm9iYWJpbGl0eTogdGhpcy5kdW5nZW9uQ3Jhd2xlci5tdXRhdGUodGhpcy5zdHJhaWdodFNpbmdsZVNwYXduUHJvYmFiaWxpdHkpLFxuICAgICAgICAgICAgICAgIHN0cmFpZ2h0RG91YmxlU3Bhd25Qcm9iYWJpbGl0eTogdGhpcy5kdW5nZW9uQ3Jhd2xlci5tdXRhdGUodGhpcy5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHkpLFxuICAgICAgICAgICAgICAgIHR1cm5TaW5nbGVTcGF3blByb2JhYmlsaXR5OiB0aGlzLmR1bmdlb25DcmF3bGVyLm11dGF0ZSh0aGlzLnR1cm5TaW5nbGVTcGF3blByb2JhYmlsaXR5KSxcbiAgICAgICAgICAgICAgICB0dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eTogdGhpcy5kdW5nZW9uQ3Jhd2xlci5tdXRhdGUodGhpcy50dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSksXG4gICAgICAgICAgICAgICAgY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHk6IHRoaXMuZHVuZ2VvbkNyYXdsZXIubXV0YXRlKHRoaXMuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IHRoaXMuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2xkRGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKCgodGhpcy5pbnRlbmRlZERpcmVjdGlvbi54ID09PSAwKSAmJiAodGhpcy5pbnRlbmRlZERpcmVjdGlvbi55ID09PSAwKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKCh0aGlzLmludGVuZGVkRGlyZWN0aW9uLnggPT09IHRoaXMuZGlyZWN0aW9uLngpICYmICh0aGlzLmludGVuZGVkRGlyZWN0aW9uLnkgPT09IHRoaXMuZGlyZWN0aW9uLnkpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tID0gdGhpcy5ybmcuaW50ICUgNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmRvbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5kb20gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmlnaHRGcmVlID4gbGVmdEZyZWUpIHx8ICgocmlnaHRGcmVlID09PSBsZWZ0RnJlZSkgJiYgdGhpcy5ybmcuYm9vbGVhbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuaW50ZW5kZWREaXJlY3Rpb24ueCA9PT0gMCkgfHwgKHRoaXMuaW50ZW5kZWREaXJlY3Rpb24ueSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5pbnRlbmRlZERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCF0aGlzLmludGVuZGVkRGlyZWN0aW9uLmVxdWFsKDAsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5pbnRlbmRlZERpcmVjdGlvbi5taW51cyh0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnJuZy5pbnQgJSAxMDApIDwgdGhpcy50dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYXduV2FsbENyYXdsZXIodGhpcy5kaXJlY3Rpb24ubmVnYXRpdmUsIHRoaXMuZGlyZWN0aW9uLm5lZ2F0aXZlLCBjaGlsZEdlbmVyYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYXduV2FsbENyYXdsZXIob2xkRGlyZWN0aW9uLCBvbGREaXJlY3Rpb24sIGNoaWxkR2VuZXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh0aGlzLnJuZy5pbnQgJSAxMDApIDwgdGhpcy50dXJuU2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYXduV2FsbENyYXdsZXIodGhpcy5kaXJlY3Rpb24ubmVnYXRpdmUsIHRoaXMuZGlyZWN0aW9uLm5lZ2F0aXZlLCBjaGlsZEdlbmVyYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IHRoaXMuc3RyYWlnaHREb3VibGVTcGF3blByb2JhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bhd25XYWxsQ3Jhd2xlcihyaWdodCwgcmlnaHQsIGNoaWxkR2VuZXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bhd25XYWxsQ3Jhd2xlcihsZWZ0LCBsZWZ0LCBjaGlsZEdlbmVyYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IHRoaXMuc3RyYWlnaHRTaW5nbGVTcGF3blByb2JhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0RnJlZSA+IHJpZ2h0RnJlZSB8fCBsZWZ0RnJlZSA9PT0gcmlnaHRGcmVlICYmIHRoaXMucm5nLmJvb2xlYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5ybmcuaW50ICUgMykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSB0ZXN0Lm5lZ2F0aXZlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bhd25XYWxsQ3Jhd2xlcih0ZXN0LCB0ZXN0LCBjaGlsZEdlbmVyYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbi5lcXVhbHModGhpcy5pbnRlbmRlZERpcmVjdGlvbikgfHwgdGhpcy5pbnRlbmRlZERpcmVjdGlvbi5lcXVhbCgwLCAwKSkge1xuICAgICAgICAgICAgICAgIGxldCBbcmlnaHRGcmVlXSA9IHRoaXMuZnJvbnRGcmVlKHRoaXMubG9jYXRpb24sIHJpZ2h0LCB0aGlzLmNvcnJpZG9yV2lkdGgsIHRoaXMuY29ycmlkb3JXaWR0aCk7XG4gICAgICAgICAgICAgICAgbGV0IFtsZWZ0RnJlZV0gPSB0aGlzLmZyb250RnJlZSh0aGlzLmxvY2F0aW9uLCBsZWZ0LCB0aGlzLmNvcnJpZG9yV2lkdGgsIHRoaXMuY29ycmlkb3JXaWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKChyaWdodEZyZWUgPD0gdGhpcy5jb3JyaWRvcldpZHRoKSAmJiAobGVmdEZyZWUgPD0gdGhpcy5jb3JyaWRvcldpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChyaWdodEZyZWUgPiAyICogdGhpcy5jb3JyaWRvcldpZHRoICsgMSkgJiYgKGxlZnRGcmVlID4gMiAqIHRoaXMuY29ycmlkb3JXaWR0aCArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJuZy5ib29sZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0RnJlZSA+IGxlZnRGcmVlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRGcmVlID4gcmlnaHRGcmVlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5ybmcuYm9vbGVhbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBsZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5pbnRlbmRlZERpcmVjdGlvbi54ID09PSAwKSB8fCAodGhpcy5pbnRlbmRlZERpcmVjdGlvbi55ID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgW2RpcmVjdGlvbkZyZWVdID0gdGhpcy5mcm9udEZyZWUodGhpcy5sb2NhdGlvbiwgdGhpcy5pbnRlbmRlZERpcmVjdGlvbiwgdGhpcy5jb3JyaWRvcldpZHRoLCB0aGlzLmNvcnJpZG9yV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uRnJlZSA+IHRoaXMuY29ycmlkb3JXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLmludGVuZGVkRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCghdGhpcy5pbnRlbmRlZERpcmVjdGlvbi5lcXVhbCgwLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3QgPSB0aGlzLmludGVuZGVkRGlyZWN0aW9uLm1pbnVzKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IFt0ZXN0RnJlZV0gPSB0aGlzLmZyb250RnJlZSh0aGlzLmxvY2F0aW9uLCB0ZXN0LCB0aGlzLmNvcnJpZG9yV2lkdGgsIHRoaXMuY29ycmlkb3JXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0RnJlZSA+IHRoaXMuY29ycmlkb3JXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0ZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGF3bldhbGxDcmF3bGVyKGRpcmVjdGlvbiwgaW50ZW5kZWREaXJlY3Rpb24sIGdlbmVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCh0aGlzLnJuZy5pbnQgJSAxMDApIDwgdGhpcy5jb25maWcubm9IZWFkaW5nUHJvYmFiaWxpdHkpIHtcbiAgICAgICAgICAgIGludGVuZGVkRGlyZWN0aW9uID0gUG9pbnQuWkVSTztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLmNyZWF0ZVdhbGxDcmF3bGVyKHRoaXMubG9jYXRpb24sIGRpcmVjdGlvbiwgMCwgdGhpcy5kdW5nZW9uQ3Jhd2xlci5nZXRNYXhBZ2VDcmF3bGVycyhnZW5lcmF0aW9uKSwgZ2VuZXJhdGlvbiwgaW50ZW5kZWREaXJlY3Rpb24sIHRoaXMuZHVuZ2VvbkNyYXdsZXIuZ2V0U3RlcExlbmd0aChnZW5lcmF0aW9uKSwgMSwgdGhpcy5kdW5nZW9uQ3Jhd2xlci5nZXRDb3JyaWRvcldpZHRoKGdlbmVyYXRpb24pLCBvcHRpb25zLnN0cmFpZ2h0U2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgb3B0aW9ucy5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIG9wdGlvbnMudHVyblNpbmdsZVNwYXduUHJvYmFiaWxpdHksIG9wdGlvbnMudHVybkRvdWJsZVNwYXduUHJvYmFiaWxpdHksIG9wdGlvbnMuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpO1xuICAgIH1cbiAgICBqb2luKGZyb250RnJlZSkge1xuICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLnJpZ2h0RGlyZWN0aW9uKCk7XG4gICAgICAgIGxldCB0ZXN0ID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGZyb250RnJlZSArIDEpKTtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKHRlc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLmR1bmdlb25DcmF3bGVyLmdldE1hcCh0ZXN0KTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnModHlwZSwgVHVubmVsZXJDZWxsVHlwZS5DTE9TRUQsIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9DTE9TRUQpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBmcm9udEZyZWU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGkpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmFsaWQocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kdW5nZW9uQ3Jhd2xlci5zZXRNYXAocG9pbnQsIFR1bm5lbGVyQ2VsbFR5cGUuTk9OX0pPSU5fQ0xPU0VEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGFpbnModHlwZSwgVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9DTE9TRUQsIFR1bm5lbGVyQ2VsbFR5cGUuTk9OX0pPSU5fR1VBUkFOVEVFRF9DTE9TRUQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhbGwgPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgbGV0IHNpZGVzdGVwID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5jb3JyaWRvcldpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwb2ludCA9IHRoaXMubG9jYXRpb24ucGx1cyhyaWdodC5tdWx0aXBseShpKSkucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShmcm9udEZyZWUgKyAxKSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsaWQocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMuZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHBvaW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKHR5cGUsIFR1bm5lbGVyQ2VsbFR5cGUuQ0xPU0VELCBUdW5uZWxlckNlbGxUeXBlLkdVQVJBTlRFRURfQ0xPU0VELCBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX0NMT1NFRCwgVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9HVUFSQU5URUVEX0NMT1NFRCkpIHtcbiAgICAgICAgICAgICAgICB3YWxsID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgc2lkZXN0ZXAgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnQgPSB0aGlzLmxvY2F0aW9uLm1pbnVzKHJpZ2h0Lm11bHRpcGx5KGkpLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoZnJvbnRGcmVlICsgMSkpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZChwb2ludCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5kdW5nZW9uQ3Jhd2xlci5nZXRNYXAocG9pbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbnModHlwZSwgVHVubmVsZXJDZWxsVHlwZS5DTE9TRUQsIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9DTE9TRUQsIFR1bm5lbGVyQ2VsbFR5cGUuTk9OX0pPSU5fQ0xPU0VELCBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX0dVQVJBTlRFRURfQ0xPU0VEKSkge1xuICAgICAgICAgICAgICAgIHdhbGwgPSBwb2ludDtcbiAgICAgICAgICAgICAgICBzaWRlc3RlcCA9IC1pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgod2FsbC54ICE9PSAwKSB8fCAod2FsbC55ICE9PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWRlc3RlcCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKHR5cGUsIFR1bm5lbGVyQ2VsbFR5cGUuTk9OX0pPSU5fQ0xPU0VELCBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX0dVQVJBTlRFRURfQ0xPU0VEKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWRlc3RlcCA8IDApIHtcbiAgICAgICAgICAgIHRlc3QgPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRlc3QgPSByaWdodC5uZWdhdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgW2ZyZWVdID0gdGhpcy5mcm9udEZyZWUod2FsbCwgdGVzdCwgMSwgMSk7XG4gICAgICAgIGxldCBhYnNfc2lkZXN0ZXA7XG4gICAgICAgIGxldCBmYWN0b3Jfc2lkZXN0ZXA7XG4gICAgICAgIGlmIChzaWRlc3RlcCA+IDApIHtcbiAgICAgICAgICAgIGFic19zaWRlc3RlcCA9IHNpZGVzdGVwO1xuICAgICAgICAgICAgZmFjdG9yX3NpZGVzdGVwID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFic19zaWRlc3RlcCA9IC1zaWRlc3RlcDtcbiAgICAgICAgICAgIGZhY3Rvcl9zaWRlc3RlcCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmVlIDwgYWJzX3NpZGVzdGVwICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGZyb250RnJlZSArIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoaSkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkKHBvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHVuZ2VvbkNyYXdsZXIuc2V0TWFwKHBvaW50LCBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX0NMT1NFRCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhYnNfc2lkZXN0ZXA7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmxvY2F0aW9uLnBsdXMocmlnaHQubXVsdGlwbHkoaSAqIGZhY3Rvcl9zaWRlc3RlcCkpLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoZnJvbnRGcmVlICsgMSkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkKHBvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHVuZ2VvbkNyYXdsZXIuc2V0TWFwKHBvaW50LCBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX0NMT1NFRCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldENoaWxkRGVsYXlQcm9iYWJpbGl0eUZvckdlbmVyYXRpb25DcmF3bGVycyhnZW5lcmF0aW9uKSB7XG4gICAgICAgIGlmICgoMCA8PSBnZW5lcmF0aW9uKSAmJiAoZ2VuZXJhdGlvbiA8PSAxMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5jaGlsZERlbGF5UHJvYmFiaWxpdHlGb3JHZW5lcmF0aW9uQ3Jhd2xlcnNbZ2VuZXJhdGlvbl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFR1bm5lbGVyQ2VsbFR5cGUsIFBvaW50LCBSb29tU2l6ZSB9IGZyb20gXCIuL21vZGVsXCI7XG5pbXBvcnQgeyBDcmF3bGVyIH0gZnJvbSBcIi4vY3Jhd2xlclwiO1xuZXhwb3J0IGNsYXNzIFR1bm5lbENyYXdsZXIgZXh0ZW5kcyBDcmF3bGVyIHtcbiAgICBjb25zdHJ1Y3RvcihybmcsIGR1bmdlb25DcmF3bGVyLCBsb2NhdGlvbiwgZGlyZWN0aW9uLCBhZ2UsIG1heEFnZSwgZ2VuZXJhdGlvbiwgaW50ZW5kZWREaXJlY3Rpb24sIHN0ZXBMZW5ndGgsIHR1bm5lbFdpZHRoLCBzdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5LCBjaGFuZ2VEaXJlY3Rpb25Qcm9iYWJpbGl0eSwgbWFrZVJvb21zUmlnaHRQcm9iYWJpbGl0eSwgbWFrZVJvb21zTGVmdFByb2JhYmlsaXR5LCBqb2luUHJlZmVyZW5jZSkge1xuICAgICAgICBzdXBlcihybmcsIGR1bmdlb25DcmF3bGVyLCBsb2NhdGlvbiwgZGlyZWN0aW9uLCBhZ2UsIG1heEFnZSwgZ2VuZXJhdGlvbik7XG4gICAgICAgIHRoaXMuaW50ZW5kZWREaXJlY3Rpb24gPSBpbnRlbmRlZERpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5zdGVwTGVuZ3RoID0gc3RlcExlbmd0aDtcbiAgICAgICAgdGhpcy50dW5uZWxXaWR0aCA9IHR1bm5lbFdpZHRoO1xuICAgICAgICB0aGlzLnN0cmFpZ2h0RG91YmxlU3Bhd25Qcm9iYWJpbGl0eSA9IHN0cmFpZ2h0RG91YmxlU3Bhd25Qcm9iYWJpbGl0eTtcbiAgICAgICAgdGhpcy50dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSA9IHR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5O1xuICAgICAgICB0aGlzLmNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5ID0gY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHk7XG4gICAgICAgIHRoaXMubWFrZVJvb21zUmlnaHRQcm9iYWJpbGl0eSA9IG1ha2VSb29tc1JpZ2h0UHJvYmFiaWxpdHk7XG4gICAgICAgIHRoaXMubWFrZVJvb21zTGVmdFByb2JhYmlsaXR5ID0gbWFrZVJvb21zTGVmdFByb2JhYmlsaXR5O1xuICAgICAgICB0aGlzLmpvaW5QcmVmZXJlbmNlID0gam9pblByZWZlcmVuY2U7XG4gICAgfVxuICAgIHN0ZXBBaGVhZCgpIHtcbiAgICAgICAgY29uc3QgZHVuZ2VvbkNyYXdsZXIgPSB0aGlzLmR1bmdlb25DcmF3bGVyO1xuICAgICAgICBpZiAodGhpcy5nZW5lcmF0aW9uICE9PSBkdW5nZW9uQ3Jhd2xlci5hY3RpdmVHZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLmdlbmVyYXRpb24gPiBkdW5nZW9uQ3Jhd2xlci5hY3RpdmVHZW5lcmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWdlKys7XG4gICAgICAgIGlmICh0aGlzLmFnZSA+PSB0aGlzLm1heEFnZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hZ2UgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMudHVubmVsV2lkdGggPj0gMCk7XG4gICAgICAgIGxldCBbZnJvbnRGcmVlLCBsZWZ0RnJlZSwgcmlnaHRGcmVlXSA9IHRoaXMuZnJvbnRGcmVlKHRoaXMubG9jYXRpb24sIHRoaXMuZGlyZWN0aW9uLCB0aGlzLnR1bm5lbFdpZHRoICsgMSwgdGhpcy50dW5uZWxXaWR0aCArIDEpO1xuICAgICAgICBpZiAoZnJvbnRGcmVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFtzaXplU2lkZXdheXMsIHNpemVCcmFuY2hpbmddID0gdGhpcy5zaWRld2F5c0JyYW5jaGluZ1Jvb21TaXplcygpO1xuICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLnJpZ2h0RGlyZWN0aW9uKCk7XG4gICAgICAgIGxldCBsZWZ0ID0gcmlnaHQubmVnYXRpdmU7XG4gICAgICAgIGNvbnN0IHJvb21HZW5lcmF0aW9uID0gdGhpcy5yb29tR2VuZXJhdGlvbigpO1xuICAgICAgICBpZiAoKGZyb250RnJlZSA8ICgyICogdGhpcy5zdGVwTGVuZ3RoKSkgfHwgKCh0aGlzLm1heEFnZSAtIDEpID09PSB0aGlzLmFnZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW5PckJ1aWxkVGVybWluYXRpbmdSb29tKHNpemVCcmFuY2hpbmcsIGZyb250RnJlZSwgbGVmdEZyZWUsIHJpZ2h0RnJlZSwgcmlnaHQsIGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZyb250RnJlZSA+PSAyICogdGhpcy5zdGVwTGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5zdGVwTGVuZ3RoID4gMCk7XG4gICAgICAgIHRoaXMuYnVpbGRUdW5uZWwodGhpcy5zdGVwTGVuZ3RoLCB0aGlzLnR1bm5lbFdpZHRoKTtcbiAgICAgICAgaWYgKCh0aGlzLnJuZy5pbnQgJSAxMDApIDwgdGhpcy5tYWtlUm9vbXNSaWdodFByb2JhYmlsaXR5KSB7XG4gICAgICAgICAgICBsZXQgc3Bhd25Qb2ludCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseSgodGhpcy5zdGVwTGVuZ3RoID4+IDEgKyAxKSkpLnBsdXMocmlnaHQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCkpO1xuICAgICAgICAgICAgdGhpcy5zcGF3blJvb21DcmF3bGVyKHNwYXduUG9pbnQsIHJpZ2h0LCAtMSwgMiwgcm9vbUdlbmVyYXRpb24sIHNpemVTaWRld2F5cywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IHRoaXMubWFrZVJvb21zTGVmdFByb2JhYmlsaXR5KSB7XG4gICAgICAgICAgICBsZXQgc3Bhd25Qb2ludCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseSgodGhpcy5zdGVwTGVuZ3RoID4+IDEgKyAxKSkpLnBsdXMobGVmdC5tdWx0aXBseSh0aGlzLnR1bm5lbFdpZHRoKSk7XG4gICAgICAgICAgICB0aGlzLnNwYXduUm9vbUNyYXdsZXIoc3Bhd25Qb2ludCwgbGVmdCwgLTEsIDIsIHJvb21HZW5lcmF0aW9uLCBzaXplU2lkZXdheXMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2F0aW9uID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KHRoaXMuc3RlcExlbmd0aCkpO1xuICAgICAgICBjb25zdCBzbWFsbEFudGVyb29tUG9zc2libGUgPSB0aGlzLmlzQW50ZXJvb21Qb3NzaWJsZShyaWdodCwgdGhpcy50dW5uZWxXaWR0aCArIDIsIHRoaXMudHVubmVsV2lkdGggKyAyLCAyICogdGhpcy50dW5uZWxXaWR0aCArIDUpO1xuICAgICAgICBjb25zdCBsYXJnZUFudGVyb29tUG9zc2libGUgPSB0aGlzLmlzQW50ZXJvb21Qb3NzaWJsZShyaWdodCwgdGhpcy50dW5uZWxXaWR0aCArIDMsIHRoaXMudHVubmVsV2lkdGggKyAzLCAyICogdGhpcy50dW5uZWxXaWR0aCArIDcpO1xuICAgICAgICBsZXQgc2l6ZVVwVHVubmVsID0gZmFsc2U7XG4gICAgICAgIGxldCBzaXplRG93blR1bm5lbCA9IGZhbHNlO1xuICAgICAgICBsZXQgZGljZVJvbGwgPSB0aGlzLnJuZy5pbnQgJSAxMDA7XG4gICAgICAgIGNvbnN0IHNpemVVcFByb2JhYmlsaXR5ID0gdGhpcy5nZXRTaXplVXBQcm9iYWJpbGl0eSh0aGlzLmdlbmVyYXRpb24pO1xuICAgICAgICBsZXQgc2l6ZURvd25Qcm9iYWJpbGl0eSA9IHNpemVVcFByb2JhYmlsaXR5ICsgdGhpcy5nZXRTaXplRG93blByb2JhYmlsaXR5KHRoaXMuZ2VuZXJhdGlvbik7XG4gICAgICAgIGlmIChkaWNlUm9sbCA8IHNpemVVcFByb2JhYmlsaXR5KSB7XG4gICAgICAgICAgICBzaXplVXBUdW5uZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpY2VSb2xsIDwgc2l6ZURvd25Qcm9iYWJpbGl0eSkge1xuICAgICAgICAgICAgc2l6ZURvd25UdW5uZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplVXBUdW5uZWwgJiYgIWxhcmdlQW50ZXJvb21Qb3NzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlRGlyZWN0aW9uID0gdGhpcy5pc0NoYW5nZURpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBkb1NwYXduID0gdGhpcy5pc1NwYXduKGNoYW5nZURpcmVjdGlvbik7XG4gICAgICAgIGlmICghY2hhbmdlRGlyZWN0aW9uICYmICFkb1NwYXduKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb1NwYXduUm9vbSA9IHRoaXMuaXNTcGF3blJvb20oZG9TcGF3bik7XG4gICAgICAgIGNvbnN0IGRpY2VSb2xsU3Bhd24gPSB0aGlzLnJuZy5pbnQgJSAxMDA7XG4gICAgICAgIGxldCBjaGlsZEdlbmVyYXRpb24gPSB0aGlzLmdlbmVyYXRpb24gKyAxO1xuICAgICAgICBpZiAoZG9TcGF3bikge1xuICAgICAgICAgICAgaWYgKCFzaXplVXBUdW5uZWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VtbWVkUHJvYmFiaWxpdHkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDEwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtbWVkUHJvYmFiaWxpdHkgPSBzdW1tZWRQcm9iYWJpbGl0eSArIHRoaXMuZ2V0Q2hpbGREZWxheVByb2JhYmlsaXR5Rm9yR2VuZXJhdGlvblR1bm5lbENyYXdsZXJzKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGljZVJvbGxTcGF3biA8IHN1bW1lZFByb2JhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEdlbmVyYXRpb24gPSB0aGlzLmdlbmVyYXRpb24gKyBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZEdlbmVyYXRpb24gPSB0aGlzLmdlbmVyYXRpb24gKyB0aGlzLmNvbmZpZy5zaXplVXBHZW5EZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5tdXRhdGVPcHRpb25zKCk7XG4gICAgICAgIGxldCBzcGF3blBvaW50cyA9IHRoaXMuZGV0ZXJtaW5lU3Bhd25Qb2ludHMoc2l6ZVVwVHVubmVsLCBkb1NwYXduLCBzbWFsbEFudGVyb29tUG9zc2libGUsIHJpZ2h0LCBsZWZ0KTtcbiAgICAgICAgaWYgKHNwYXduUG9pbnRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbc3Bhd25Qb2ludERpcmVjdGlvbiwgc3Bhd25Qb2ludFJpZ2h0LCBzcGF3blBvaW50TGVmdCwgYnVpbHRBbnRlcm9vbV0gPSBzcGF3blBvaW50cztcbiAgICAgICAgbGV0IHVzZWRSaWdodCA9IGZhbHNlO1xuICAgICAgICBsZXQgdXNlZExlZnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG9sZERpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uO1xuICAgICAgICBsZXQgZ29TdHJhaWdodCA9IGZhbHNlO1xuICAgICAgICBpZiAoY2hhbmdlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgW2Zyb250RnJlZVJpZ2h0XSA9IHRoaXMuZnJvbnRGcmVlKHNwYXduUG9pbnRSaWdodCwgcmlnaHQsIHRoaXMudHVubmVsV2lkdGggKyAxLCB0aGlzLnR1bm5lbFdpZHRoICsgMSk7XG4gICAgICAgICAgICBsZXQgW2Zyb250RnJlZUxlZnRdID0gdGhpcy5mcm9udEZyZWUoc3Bhd25Qb2ludExlZnQsIGxlZnQsIHRoaXMudHVubmVsV2lkdGggKyAxLCB0aGlzLnR1bm5lbFdpZHRoICsgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlbmRlZERpcmVjdGlvbi5lcXVhbCgwLCAwKSB8fCB0aGlzLmludGVuZGVkRGlyZWN0aW9uLmVxdWFscyh0aGlzLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoKCFzaXplVXBUdW5uZWwpIHx8ICghZG9TcGF3bikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmcm9udEZyZWVSaWdodCA+IGZyb250RnJlZUxlZnQpIHx8ICgoZnJvbnRGcmVlUmlnaHQgPT09IGZyb250RnJlZUxlZnQpICYmIHRoaXMucm5nLmJvb2xlYW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbnRGcmVlUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHNwYXduUG9pbnRSaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRSaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnJvbnRGcmVlTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBzcGF3blBvaW50TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoZG9TcGF3bik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZnJvbnRGcmVlUmlnaHQgPCBmcm9udEZyZWVMZWZ0KSB8fCAoKGZyb250RnJlZVJpZ2h0ID09PSBmcm9udEZyZWVMZWZ0KSAmJiB0aGlzLnJuZy5ib29sZWFuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb250RnJlZVJpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBzcGF3blBvaW50UmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkUmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyb250RnJlZUxlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gc3Bhd25Qb2ludExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VkTGVmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuaW50ZW5kZWREaXJlY3Rpb24ueCA9PT0gMCkgfHwgKHRoaXMuaW50ZW5kZWREaXJlY3Rpb24ueSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLmludGVuZGVkRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZGlyZWN0aW9uLmVxdWFscyhyaWdodCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbnRGcmVlUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZFJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gc3Bhd25Qb2ludFJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyb250RnJlZUxlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLmRpcmVjdGlvbi5lcXVhbHMobGVmdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHNwYXduUG9pbnRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlZExlZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCghdGhpcy5pbnRlbmRlZERpcmVjdGlvbi5lcXVhbCgwLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5pbnRlbmRlZERpcmVjdGlvbi5taW51cyh0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbi5lcXVhbHMocmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbnRGcmVlUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZFJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gc3Bhd25Qb2ludFJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZyb250RnJlZUxlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLmRpcmVjdGlvbi5lcXVhbHMobGVmdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHNwYXduUG9pbnRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlZExlZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvU3Bhd24pIHtcbiAgICAgICAgICAgICAgICBsZXQgc3Bhd25Qb2ludCA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICAgICAgbGV0IHNwYXduRGlyZWN0aW9uID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgICAgICBpZiAodXNlZExlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25Qb2ludCA9IHNwYXduUG9pbnRSaWdodDtcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25EaXJlY3Rpb24gPSByaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXNlZFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYXduUG9pbnQgPSBzcGF3blBvaW50TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25EaXJlY3Rpb24gPSBsZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ29TdHJhaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZ29TdHJhaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGljZVJvbGwgPSB0aGlzLnJuZy5pbnQgJSAxMDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb1NwYXduUm9vbSAmJiAoZGljZVJvbGwgPCA1MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Bhd25Sb29tQ3Jhd2xlcihzcGF3blBvaW50LCBzcGF3bkRpcmVjdGlvbiwgMCwgMiwgcm9vbUdlbmVyYXRpb24sIHNpemVCcmFuY2hpbmcsIGJ1aWx0QW50ZXJvb20pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGF3blR1bm5lbENyYXdsZXIoc2l6ZVVwVHVubmVsLCBzaXplRG93blR1bm5lbCwgc3Bhd25Qb2ludCwgc3Bhd25EaXJlY3Rpb24sIGNoaWxkR2VuZXJhdGlvbiwgc3Bhd25EaXJlY3Rpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb1NwYXduUm9vbSAmJiAoZGljZVJvbGwgPj0gNTApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYXduUm9vbUNyYXdsZXIoc3Bhd25Qb2ludERpcmVjdGlvbiwgb2xkRGlyZWN0aW9uLCAwLCAyLCByb29tR2VuZXJhdGlvbiwgc2l6ZUJyYW5jaGluZywgYnVpbHRBbnRlcm9vbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYXduVHVubmVsQ3Jhd2xlcihzaXplVXBUdW5uZWwsIHNpemVEb3duVHVubmVsLCBzcGF3blBvaW50RGlyZWN0aW9uLCBvbGREaXJlY3Rpb24sIGNoaWxkR2VuZXJhdGlvbiwgb2xkRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdvU3RyYWlnaHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnb1N0cmFpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gc3Bhd25Qb2ludERpcmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGRpY2VSb2xsID0gdGhpcy5ybmcuaW50ICUgMTAwO1xuICAgICAgICAgICAgaWYgKGRvU3Bhd25Sb29tICYmIChkaWNlUm9sbCA8IDUwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Bhd25Sb29tQ3Jhd2xlcihzcGF3blBvaW50UmlnaHQsIHJpZ2h0LCAwLCAyLCByb29tR2VuZXJhdGlvbiwgc2l6ZUJyYW5jaGluZywgYnVpbHRBbnRlcm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwYXduVHVubmVsQ3Jhd2xlcihzaXplVXBUdW5uZWwsIHNpemVEb3duVHVubmVsLCBzcGF3blBvaW50UmlnaHQsIHJpZ2h0LCBjaGlsZEdlbmVyYXRpb24sIHJpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb1NwYXduUm9vbSAmJiAoZGljZVJvbGwgPj0gNTApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGF3blJvb21DcmF3bGVyKHNwYXduUG9pbnRSaWdodCwgbGVmdCwgMCwgMiwgcm9vbUdlbmVyYXRpb24sIHNpemVCcmFuY2hpbmcsIGJ1aWx0QW50ZXJvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGF3blR1bm5lbENyYXdsZXIoc2l6ZVVwVHVubmVsLCBzaXplRG93blR1bm5lbCwgc3Bhd25Qb2ludExlZnQsIGxlZnQsIGNoaWxkR2VuZXJhdGlvbiwgbGVmdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzQW50ZXJvb21Qb3NzaWJsZShyaWdodCwgbGVmdEZyZWUsIHJpZ2h0RnJlZSwgbWluRnJvbnRGcmVlKSB7XG4gICAgICAgIGNvbnN0IGR1bmdlb25DcmF3bGVyID0gdGhpcy5kdW5nZW9uQ3Jhd2xlcjtcbiAgICAgICAgbGV0IGFudGVyb29tUG9zc2libGUgPSBmYWxzZTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy50dW5uZWxXaWR0aCA+PSAwKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRoaXMubG9jYXRpb24pID09PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTik7XG4gICAgICAgIGR1bmdlb25DcmF3bGVyLnNldE1hcCh0aGlzLmxvY2F0aW9uLCBUdW5uZWxlckNlbGxUeXBlLkNMT1NFRCk7XG4gICAgICAgIGZvciAobGV0IG0gPSAxOyBtIDw9IHRoaXMudHVubmVsV2lkdGg7IG0rKykge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRoaXMubG9jYXRpb24ucGx1cyhyaWdodC5tdWx0aXBseShtKSkpID09PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTik7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChkdW5nZW9uQ3Jhd2xlci5nZXRNYXAodGhpcy5sb2NhdGlvbi5taW51cyhyaWdodC5tdWx0aXBseShtKSkpID09PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTik7XG4gICAgICAgICAgICBkdW5nZW9uQ3Jhd2xlci5zZXRNYXAodGhpcy5sb2NhdGlvbi5wbHVzKHJpZ2h0Lm11bHRpcGx5KG0pKSwgVHVubmVsZXJDZWxsVHlwZS5DTE9TRUQpO1xuICAgICAgICAgICAgZHVuZ2VvbkNyYXdsZXIuc2V0TWFwKHRoaXMubG9jYXRpb24ubWludXMocmlnaHQubXVsdGlwbHkobSkpLCBUdW5uZWxlckNlbGxUeXBlLkNMT1NFRCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFtmcm9udEZyZWVdID0gdGhpcy5mcm9udEZyZWUodGhpcy5sb2NhdGlvbi5taW51cyh0aGlzLmRpcmVjdGlvbiksIHRoaXMuZGlyZWN0aW9uLCBsZWZ0RnJlZSwgcmlnaHRGcmVlKTtcbiAgICAgICAgaWYgKGZyb250RnJlZSA+PSBtaW5Gcm9udEZyZWUpIHtcbiAgICAgICAgICAgIGFudGVyb29tUG9zc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGR1bmdlb25DcmF3bGVyLnNldE1hcCh0aGlzLmxvY2F0aW9uLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTik7XG4gICAgICAgIGZvciAobGV0IG0gPSAxOyBtIDw9IHRoaXMudHVubmVsV2lkdGg7IG0rKykge1xuICAgICAgICAgICAgZHVuZ2VvbkNyYXdsZXIuc2V0TWFwKHRoaXMubG9jYXRpb24ucGx1cyhyaWdodC5tdWx0aXBseShtKSksIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOKTtcbiAgICAgICAgICAgIGR1bmdlb25DcmF3bGVyLnNldE1hcCh0aGlzLmxvY2F0aW9uLm1pbnVzKHJpZ2h0Lm11bHRpcGx5KG0pKSwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbnRlcm9vbVBvc3NpYmxlO1xuICAgIH1cbiAgICBkZXRlcm1pbmVTcGF3blBvaW50cyhzaXplVXBUdW5uZWwsIGRvU3Bhd24sIHNtYWxsQW50ZXJvb21Qb3NzaWJsZSwgcmlnaHQsIGxlZnQpIHtcbiAgICAgICAgY29uc3QgZHVuZ2VvbkNyYXdsZXIgPSB0aGlzLmR1bmdlb25DcmF3bGVyO1xuICAgICAgICBpZiAoc2l6ZVVwVHVubmVsKSB7XG4gICAgICAgICAgICBpZiAoKCh0aGlzLnJuZy5pbnQgJSAxMDApIDwgdGhpcy5nZXRBbnRlcm9vbVByb2JhYmlsaXR5KHRoaXMudHVubmVsV2lkdGgpKSB8fCBkb1NwYXduKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWlsZEFudGVyb29tKDIgKiB0aGlzLnR1bm5lbFdpZHRoICsgNSwgdGhpcy50dW5uZWxXaWR0aCArIDIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Bhd25EaXJlY3Rpb24gPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoMiAqIHRoaXMudHVubmVsV2lkdGggKyA1KSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Bhd25SaWdodCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseSh0aGlzLnR1bm5lbFdpZHRoICsgMykpLnBsdXMocmlnaHQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCArIDIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGF3bkxlZnQgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCArIDMpKS5wbHVzKGxlZnQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCArIDIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NwYXduRGlyZWN0aW9uLCBzcGF3blJpZ2h0LCBzcGF3bkxlZnQsIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCgodGhpcy5ybmcuaW50ICUgMTAwKSA8IHRoaXMuZ2V0QW50ZXJvb21Qcm9iYWJpbGl0eSh0aGlzLnR1bm5lbFdpZHRoKSkgJiYgc21hbGxBbnRlcm9vbVBvc3NpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWlsZEFudGVyb29tKDIgKiB0aGlzLnR1bm5lbFdpZHRoICsgMywgdGhpcy50dW5uZWxXaWR0aCArIDEpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Bhd25EaXJlY3Rpb24gPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoMiAqIHRoaXMudHVubmVsV2lkdGggKyAzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Bhd25SaWdodCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseSh0aGlzLnR1bm5lbFdpZHRoICsgMikpLnBsdXMocmlnaHQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCArIDEpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGF3bkxlZnQgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCArIDIpKS5wbHVzKGxlZnQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCArIDEpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NwYXduRGlyZWN0aW9uLCBzcGF3blJpZ2h0LCBzcGF3bkxlZnQsIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwYXduRGlyZWN0aW9uID0gdGhpcy5sb2NhdGlvbjtcbiAgICAgICAgY29uc3Qgc3Bhd25SaWdodCA9IHRoaXMubG9jYXRpb24ubWludXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCkpLnBsdXMocmlnaHQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCkpO1xuICAgICAgICBjb25zdCBzcGF3bkxlZnQgPSB0aGlzLmxvY2F0aW9uLm1pbnVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KHRoaXMudHVubmVsV2lkdGgpKS5wbHVzKGxlZnQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCkpO1xuICAgICAgICBpZiAodGhpcy5kdW5nZW9uQ3Jhd2xlci5nZXRNYXAoc3Bhd25SaWdodCkgIT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOIHx8XG4gICAgICAgICAgICBkdW5nZW9uQ3Jhd2xlci5nZXRNYXAoc3Bhd25MZWZ0KSAhPT0gVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzcGF3bkRpcmVjdGlvbiwgc3Bhd25SaWdodCwgc3Bhd25MZWZ0LCBmYWxzZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgam9pbk9yQnVpbGRUZXJtaW5hdGluZ1Jvb20oc2l6ZUJyYW5jaGluZywgZnJvbnRGcmVlLCBsZWZ0RnJlZSwgcmlnaHRGcmVlLCByaWdodCwgbGVmdCkge1xuICAgICAgICBjb25zdCBkdW5nZW9uQ3Jhd2xlciA9IHRoaXMuZHVuZ2VvbkNyYXdsZXI7XG4gICAgICAgIGxldCBndWFyYW50ZWVkQ2xvc2VkQWhlYWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG9wZW5BaGVhZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcm9vbUFoZWFkID0gZmFsc2U7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAtdGhpcy50dW5uZWxXaWR0aDsgaSA8PSB0aGlzLnR1bm5lbFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3QgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoZnJvbnRGcmVlICsgMSkpLnBsdXMocmlnaHQubXVsdGlwbHkoaSkpO1xuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGR1bmdlb25DcmF3bGVyLmdldE1hcCh0ZXN0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKGNlbGwsIFR1bm5lbGVyQ2VsbFR5cGUuT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9BTlRFUk9PTV9PUEVOKSkge1xuICAgICAgICAgICAgICAgIG9wZW5BaGVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGFpbnMoY2VsbCwgVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX0NMT1NFRCwgVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9HVUFSQU5URUVEX0NMT1NFRCkpIHtcbiAgICAgICAgICAgICAgICBndWFyYW50ZWVkQ2xvc2VkQWhlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNlbGwgPT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1JPT01fT1BFTikge1xuICAgICAgICAgICAgICAgIHJvb21BaGVhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCgodGhpcy5ybmcuaW50ICUgMTAwKSA8PSB0aGlzLmpvaW5QcmVmZXJlbmNlKSAmJlxuICAgICAgICAgICAgKCh0aGlzLmFnZSA8IHRoaXMubWF4QWdlIC0gMSkgfHwgKGZyb250RnJlZSA8PSB0aGlzLmNvbmZpZy50dW5uZWxKb2luRGlzdCkpKSB8fCAoZnJvbnRGcmVlIDwgNSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuam9pbk90aGVyVHVubmVsKGNvdW50LCBmcm9udEZyZWUsIGxlZnRGcmVlLCByaWdodEZyZWUsIG9wZW5BaGVhZCwgcm9vbUFoZWFkLCBndWFyYW50ZWVkQ2xvc2VkQWhlYWQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR1bmdlb25DcmF3bGVyLmlzTW9yZVJvb21zRHVuZ2VvbihzaXplQnJhbmNoaW5nKSkge1xuICAgICAgICAgICAgdGhpcy5zcGF3blJvb21DcmF3bGVyKHRoaXMubG9jYXRpb24sIHRoaXMuZGlyZWN0aW9uLCAwLCAyLCB0aGlzLmdlbmVyYXRpb24sIHNpemVCcmFuY2hpbmcsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgam9pblByZWZlcmVuY2UgPSAodGhpcy5ybmcuaW50ICUgMTEpICogMTA7XG4gICAgICAgIGlmICgodGhpcy5qb2luUHJlZmVyZW5jZSAhPT0gMTAwKSB8fCAodGhpcy5tYWtlUm9vbXNMZWZ0UHJvYmFiaWxpdHkgIT09IHRoaXMuY29uZmlnLmxhc3RDaGFuY2VUdW5uZWxDcmF3bGVyLm1ha2VSb29tc0xlZnRQcm9iYWJpbGl0eSkgfHxcbiAgICAgICAgICAgICh0aGlzLm1ha2VSb29tc1JpZ2h0UHJvYmFiaWxpdHkgIT09IHRoaXMuY29uZmlnLmxhc3RDaGFuY2VUdW5uZWxDcmF3bGVyLm1ha2VSb29tc1JpZ2h0UHJvYmFiaWxpdHkpIHx8XG4gICAgICAgICAgICAodGhpcy5jaGFuZ2VEaXJlY3Rpb25Qcm9iYWJpbGl0eSAhPT0gdGhpcy5jb25maWcubGFzdENoYW5jZVR1bm5lbENyYXdsZXIuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpIHx8XG4gICAgICAgICAgICAodGhpcy5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHkgIT09IHRoaXMuY29uZmlnLmxhc3RDaGFuY2VUdW5uZWxDcmF3bGVyLnN0cmFpZ2h0RG91YmxlU3Bhd25Qcm9iYWJpbGl0eSkgfHxcbiAgICAgICAgICAgICh0aGlzLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5ICE9PSB0aGlzLmNvbmZpZy5sYXN0Q2hhbmNlVHVubmVsQ3Jhd2xlci50dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSkgfHxcbiAgICAgICAgICAgICh0aGlzLnR1bm5lbFdpZHRoICE9PSAwKSkge1xuICAgICAgICAgICAgbGV0IFtmcm9udEZyZWVSaWdodF0gPSB0aGlzLmZyb250RnJlZSh0aGlzLmxvY2F0aW9uLnBsdXMocmlnaHQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCkpLCByaWdodCwgdGhpcy50dW5uZWxXaWR0aCArIDEsIHRoaXMudHVubmVsV2lkdGggKyAxKTtcbiAgICAgICAgICAgIGxldCBbZnJvbnRGcmVlTGVmdF0gPSB0aGlzLmZyb250RnJlZSh0aGlzLmxvY2F0aW9uLm1pbnVzKHJpZ2h0Lm11bHRpcGx5KHRoaXMudHVubmVsV2lkdGgpKSwgbGVmdCwgdGhpcy50dW5uZWxXaWR0aCArIDEsIHRoaXMudHVubmVsV2lkdGggKyAxKTtcbiAgICAgICAgICAgIGxldCBbZnJvbnRGcmVlQmFja10gPSB0aGlzLmZyb250RnJlZSh0aGlzLmxvY2F0aW9uLCB0aGlzLmRpcmVjdGlvbi5uZWdhdGl2ZSwgdGhpcy50dW5uZWxXaWR0aCArIDEsIHRoaXMudHVubmVsV2lkdGggKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcmsgPSAobG9jYXRpb24sIGRpcmVjdGlvbiwgZ2VuZXJhdGlvbiwgaW50ZW5kZWREaXJlY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLmNyZWF0ZVR1bm5lbENyYXdsZXIobG9jYXRpb24sIGRpcmVjdGlvbiwgMCwgdGhpcy5tYXhBZ2UsIGdlbmVyYXRpb24sIGludGVuZGVkRGlyZWN0aW9uLCAzLCAwLCB0aGlzLmNvbmZpZy5sYXN0Q2hhbmNlVHVubmVsQ3Jhd2xlci5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHRoaXMuY29uZmlnLmxhc3RDaGFuY2VUdW5uZWxDcmF3bGVyLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5LCB0aGlzLmNvbmZpZy5sYXN0Q2hhbmNlVHVubmVsQ3Jhd2xlci5jaGFuZ2VEaXJlY3Rpb25Qcm9iYWJpbGl0eSwgdGhpcy5jb25maWcubGFzdENoYW5jZVR1bm5lbENyYXdsZXIubWFrZVJvb21zUmlnaHRQcm9iYWJpbGl0eSwgdGhpcy5jb25maWcubGFzdENoYW5jZVR1bm5lbENyYXdsZXIubWFrZVJvb21zTGVmdFByb2JhYmlsaXR5LCBqb2luUHJlZmVyZW5jZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMudHVubmVsV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMubWFrZVJvb21zTGVmdFByb2JhYmlsaXR5ID09PSB0aGlzLmNvbmZpZy5sYXN0Q2hhbmNlVHVubmVsQ3Jhd2xlci5tYWtlUm9vbXNMZWZ0UHJvYmFiaWxpdHkpICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm1ha2VSb29tc1JpZ2h0UHJvYmFiaWxpdHkgPT09IHRoaXMuY29uZmlnLmxhc3RDaGFuY2VUdW5uZWxDcmF3bGVyLm1ha2VSb29tc1JpZ2h0UHJvYmFiaWxpdHkpICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5ID09PSB0aGlzLmNvbmZpZy5sYXN0Q2hhbmNlVHVubmVsQ3Jhd2xlci5jaGFuZ2VEaXJlY3Rpb25Qcm9iYWJpbGl0eSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3RyYWlnaHREb3VibGVTcGF3blByb2JhYmlsaXR5ID09PSB0aGlzLmNvbmZpZy5sYXN0Q2hhbmNlVHVubmVsQ3Jhd2xlci5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHkpICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5ID09PSB0aGlzLmNvbmZpZy5sYXN0Q2hhbmNlVHVubmVsQ3Jhd2xlci50dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChmcm9udEZyZWUgPj0gZnJvbnRGcmVlUmlnaHQpICYmIChmcm9udEZyZWUgPj0gZnJvbnRGcmVlTGVmdCkgJiYgKGZyb250RnJlZSA+PSBmcm9udEZyZWVCYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yayh0aGlzLmxvY2F0aW9uLCB0aGlzLmRpcmVjdGlvbiwgdGhpcy5nZW5lcmF0aW9uICsgMSwgdGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChmcm9udEZyZWVCYWNrID49IGZyb250RnJlZVJpZ2h0KSAmJiAoZnJvbnRGcmVlQmFjayA+PSBmcm9udEZyZWVMZWZ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yayh0aGlzLmxvY2F0aW9uLCB0aGlzLmRpcmVjdGlvbi5uZWdhdGl2ZSwgdGhpcy5nZW5lcmF0aW9uICsgdGhpcy5jb25maWcuZ2VuRGVsYXlMYXN0Q2hhbmNlLCB0aGlzLmRpcmVjdGlvbi5uZWdhdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGZyb250RnJlZVJpZ2h0ID49IGZyb250RnJlZUxlZnQpIHx8ICgoZnJvbnRGcmVlUmlnaHQgPT09IGZyb250RnJlZUxlZnQpICYmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IDUwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmsodGhpcy5sb2NhdGlvbiwgcmlnaHQsIHRoaXMuZ2VuZXJhdGlvbiArIHRoaXMuY29uZmlnLmdlbkRlbGF5TGFzdENoYW5jZSwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yayh0aGlzLmxvY2F0aW9uLCBsZWZ0LCB0aGlzLmdlbmVyYXRpb24gKyB0aGlzLmNvbmZpZy5nZW5EZWxheUxhc3RDaGFuY2UsIGxlZnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JrKHRoaXMubG9jYXRpb24sIHRoaXMuZGlyZWN0aW9uLCB0aGlzLmdlbmVyYXRpb24gKyB0aGlzLmNvbmZpZy5nZW5EZWxheUxhc3RDaGFuY2UsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3VhcmFudGVlZENsb3NlZEFoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmsodGhpcy5sb2NhdGlvbi5wbHVzKHJpZ2h0Lm11bHRpcGx5KHRoaXMudHVubmVsV2lkdGgpKSwgcmlnaHQsIHRoaXMuZ2VuZXJhdGlvbiArIHRoaXMuY29uZmlnLmdlbkRlbGF5TGFzdENoYW5jZSwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JrKHRoaXMubG9jYXRpb24ubWludXMocmlnaHQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCkpLCBsZWZ0LCB0aGlzLmdlbmVyYXRpb24gKyB0aGlzLmNvbmZpZy5nZW5EZWxheUxhc3RDaGFuY2UsIGxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoZnJvbnRGcmVlUmlnaHQgPj0gZnJvbnRGcmVlTGVmdCkgfHwgKChmcm9udEZyZWVSaWdodCA9PT0gZnJvbnRGcmVlTGVmdCkgJiYgKCh0aGlzLnJuZy5pbnQgJSAxMDApIDwgNTApKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JrKHRoaXMubG9jYXRpb24ucGx1cyhyaWdodC5tdWx0aXBseSh0aGlzLnR1bm5lbFdpZHRoKSksIHJpZ2h0LCB0aGlzLmdlbmVyYXRpb24gKyB0aGlzLmNvbmZpZy5nZW5EZWxheUxhc3RDaGFuY2UsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yayh0aGlzLmxvY2F0aW9uLm1pbnVzKHJpZ2h0Lm11bHRpcGx5KHRoaXMudHVubmVsV2lkdGgpKSwgdGhpcy5kaXJlY3Rpb24sIHRoaXMuZ2VuZXJhdGlvbiArIHRoaXMuY29uZmlnLmdlbkRlbGF5TGFzdENoYW5jZSwgdGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yayh0aGlzLmxvY2F0aW9uLnBsdXMocmlnaHQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCkpLCB0aGlzLmRpcmVjdGlvbiwgdGhpcy5nZW5lcmF0aW9uICsgdGhpcy5jb25maWcuZ2VuRGVsYXlMYXN0Q2hhbmNlLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGZvcmsodGhpcy5sb2NhdGlvbi5taW51cyhyaWdodC5tdWx0aXBseSh0aGlzLnR1bm5lbFdpZHRoKSksIHRoaXMuZGlyZWN0aW9uLCB0aGlzLmdlbmVyYXRpb24gKyB0aGlzLmNvbmZpZy5nZW5EZWxheUxhc3RDaGFuY2UsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBqb2luT3RoZXJUdW5uZWwoY291bnQsIGZyb250RnJlZSwgbGVmdEZyZWUsIHJpZ2h0RnJlZSwgb3BlbkFoZWFkLCByb29tQWhlYWQsIGd1YXJhbnRlZWRDbG9zZWRBaGVhZCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgZHVuZ2VvbkNyYXdsZXIgPSB0aGlzLmR1bmdlb25DcmF3bGVyO1xuICAgICAgICBpZiAoKDIgKiB0aGlzLnR1bm5lbFdpZHRoICsgMSkgPT09IGNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkVHVubmVsKGZyb250RnJlZSwgdGhpcy50dW5uZWxXaWR0aCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW5BaGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTbWFsbGVyVHVubmVsKGZyb250RnJlZSwgZHVuZ2VvbkNyYXdsZXIsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vbUFoZWFkICYmICh0aGlzLnR1bm5lbFdpZHRoID09PSAwKSkge1xuICAgICAgICAgICAgaWYgKGZyb250RnJlZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGZyb250RnJlZSArIDEpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRlc3QpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNlbGwgPT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1JPT01fT1BFTik7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFR1bm5lbChmcm9udEZyZWUgLSAxLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24ueCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgZHVuZ2VvbkNyYXdsZXIuc2V0TWFwKHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShmcm9udEZyZWUpKSwgVHVubmVsZXJDZWxsVHlwZS5WX0RPT1IpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLmRpcmVjdGlvbi55ID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgZHVuZ2VvbkNyYXdsZXIuc2V0TWFwKHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShmcm9udEZyZWUpKSwgVHVubmVsZXJDZWxsVHlwZS5IX0RPT1IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGd1YXJhbnRlZWRDbG9zZWRBaGVhZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHVubmVsV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5qb2luUHJlZmVyZW5jZSAhPT0gMTAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVJvb21zTGVmdFByb2JhYmlsaXR5ICE9PSAyMCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ha2VSb29tc1JpZ2h0UHJvYmFiaWxpdHkgIT09IDIwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkgIT09IDMwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyYWlnaHREb3VibGVTcGF3blByb2JhYmlsaXR5ICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHVybkRvdWJsZVNwYXduUHJvYmFiaWxpdHkgIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50dW5uZWxXaWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqb2luUHJlZmVyZW5jZSA9ICh0aGlzLnJuZy5pbnQgJSAxMSkgKiAxMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gbGVmdEZyZWUgPj0gcmlnaHRGcmVlID8gcmlnaHQubmVnYXRpdmUgOiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZHVuZ2VvbkNyYXdsZXIuY3JlYXRlVHVubmVsQ3Jhd2xlcih0aGlzLmxvY2F0aW9uLCBkaXJlY3Rpb24sIDAsIHRoaXMubWF4QWdlLCB0aGlzLmdlbmVyYXRpb24gKyAxLCBkaXJlY3Rpb24sIDMsIDAsIDAsIDAsIDMwLCAyMCwgMjAsIGpvaW5QcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghb3BlbkFoZWFkICYmICFndWFyYW50ZWVkQ2xvc2VkQWhlYWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3BlY2lhbENhc2UoZnJvbnRGcmVlLCByaWdodCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0pvaW5lZCA9IHRoaXMuYnVpbGRUdW5uZWwoZnJvbnRGcmVlLCB0aGlzLnR1bm5lbFdpZHRoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChpc0pvaW5lZCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC10aGlzLnR1bm5lbFdpZHRoOyBpIDw9IHRoaXMudHVubmVsV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkdW5nZW9uQ3Jhd2xlci5zZXRNYXAodGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGZyb250RnJlZSArIDEpKS5wbHVzKHJpZ2h0Lm11bHRpcGx5KGkpKSwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGlyZWN0aW9uTGVuZ3RoID0gZnJvbnRGcmVlICsgMjtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFjdEluTmV4dFJvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHJvd0FmdGVySXNPSyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbnRhY3RJbk5leHRSb3cgJiYgcm93QWZ0ZXJJc09LKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAtdGhpcy50dW5uZWxXaWR0aDsgaSA8PSB0aGlzLnR1bm5lbFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoZGlyZWN0aW9uTGVuZ3RoKSkucGx1cyhyaWdodC5tdWx0aXBseShpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwgIT09IFR1bm5lbGVyQ2VsbFR5cGUuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdEluTmV4dFJvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXN0UmlnaHQgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoZGlyZWN0aW9uTGVuZ3RoKSkucGx1cyhyaWdodC5tdWx0aXBseSh0aGlzLnR1bm5lbFdpZHRoICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGVzdExlZnQgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoZGlyZWN0aW9uTGVuZ3RoKSkubWludXMocmlnaHQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0Q2VsbCA9IGR1bmdlb25DcmF3bGVyLmdldE1hcCh0ZXN0UmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGVmdENlbGwgPSBkdW5nZW9uQ3Jhd2xlci5nZXRNYXAodGVzdExlZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbnMocmlnaHRDZWxsLCBUdW5uZWxlckNlbGxUeXBlLk9QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfQU5URVJPT01fT1BFTikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLmNvbnRhaW5zKGxlZnRDZWxsLCBUdW5uZWxlckNlbGxUeXBlLk9QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfQU5URVJPT01fT1BFTikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RJbk5leHRSb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgocmlnaHRDZWxsID09PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9ST09NX09QRU4pIHx8IChsZWZ0Q2VsbCA9PT0gVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfUk9PTV9PUEVOKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdEluTmV4dFJvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC10aGlzLnR1bm5lbFdpZHRoOyBpIDw9IHRoaXMudHVubmVsV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShkaXJlY3Rpb25MZW5ndGggKyAxKSkucGx1cyhyaWdodC5tdWx0aXBseShpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwgIT09IFR1bm5lbGVyQ2VsbFR5cGUuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93QWZ0ZXJJc09LID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVzdFJpZ2h0ID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGRpcmVjdGlvbkxlbmd0aCArIDEpKS5wbHVzKHJpZ2h0Lm11bHRpcGx5KHRoaXMudHVubmVsV2lkdGggKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RMZWZ0ID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGRpcmVjdGlvbkxlbmd0aCArIDEpKS5taW51cyhyaWdodC5tdWx0aXBseSh0aGlzLnR1bm5lbFdpZHRoICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICByaWdodENlbGwgPSBkdW5nZW9uQ3Jhd2xlci5nZXRNYXAodGVzdFJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdENlbGwgPSBkdW5nZW9uQ3Jhd2xlci5nZXRNYXAodGVzdExlZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbnMocmlnaHRDZWxsLCBUdW5uZWxlckNlbGxUeXBlLk9QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfQU5URVJPT01fT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5DTE9TRUQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5jb250YWlucyhsZWZ0Q2VsbCwgVHVubmVsZXJDZWxsVHlwZS5PUEVOLCBUdW5uZWxlckNlbGxUeXBlLkdVQVJBTlRFRURfT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX0FOVEVST09NX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuQ0xPU0VEKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93QWZ0ZXJJc09LID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChyaWdodENlbGwgPT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1JPT01fT1BFTikgfHwgKGxlZnRDZWxsID09PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9ST09NX09QRU4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93QWZ0ZXJJc09LID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGxPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC10aGlzLnR1bm5lbFdpZHRoIC0gMTsgaSA8PSB0aGlzLnR1bm5lbFdpZHRoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGRpcmVjdGlvbkxlbmd0aCArIDEpKS5wbHVzKHJpZ2h0Lm11bHRpcGx5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBkdW5nZW9uQ3Jhd2xlci5nZXRNYXAodGVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNlbGwgIT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOKSAmJiAoY2VsbCAhPT0gVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfQU5URVJPT01fT1BFTikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbE9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0FmdGVySXNPSyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3RJbk5leHRSb3cgJiYgcm93QWZ0ZXJJc09LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gLXRoaXMudHVubmVsV2lkdGg7IGkgPD0gdGhpcy50dW5uZWxXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVuZ2VvbkNyYXdsZXIuc2V0TWFwKHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShkaXJlY3Rpb25MZW5ndGgpKS5wbHVzKHJpZ2h0Lm11bHRpcGx5KGkpKSwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbkxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50dW5uZWxXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChkdW5nZW9uQ3Jhd2xlci5nZXRNYXAodGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGZyb250RnJlZSArIDEpKSkgPT09IFR1bm5lbGVyQ2VsbFR5cGUuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkdW5nZW9uQ3Jhd2xlci5nZXRNYXAodGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGZyb250RnJlZSArIDEpKS5wbHVzKHJpZ2h0KSkgPT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1JPT01fT1BFTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSByaWdodC5uZWdhdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbi5lcXVhbHModGhpcy5pbnRlbmRlZERpcmVjdGlvbi5uZWdhdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMuaW50ZW5kZWREaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkdW5nZW9uQ3Jhd2xlci5nZXRNYXAodGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGZyb250RnJlZSArIDEpKS5taW51cyhyaWdodCkpID09PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9ST09NX09QRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24uZXF1YWxzKHRoaXMuaW50ZW5kZWREaXJlY3Rpb24ubmVnYXRpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLmludGVuZGVkRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlzU3BlY2lhbENhc2UoZnJvbnRGcmVlLCByaWdodCkge1xuICAgICAgICBjb25zdCBkdW5nZW9uQ3Jhd2xlciA9IHRoaXMuZHVuZ2VvbkNyYXdsZXI7XG4gICAgICAgIGxldCBpc1NwZWNpYWxDYXNlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IC10aGlzLnR1bm5lbFdpZHRoOyBpIDw9IHRoaXMudHVubmVsV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGVzdCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShmcm9udEZyZWUgKyAxKSkucGx1cyhyaWdodC5tdWx0aXBseShpKSk7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRlc3QpO1xuICAgICAgICAgICAgaWYgKGNlbGwgIT09IFR1bm5lbGVyQ2VsbFR5cGUuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgaXNTcGVjaWFsQ2FzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXN0UmlnaHQgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoZnJvbnRGcmVlICsgMSkpLnBsdXMocmlnaHQubXVsdGlwbHkodGhpcy50dW5uZWxXaWR0aCArIDEpKTtcbiAgICAgICAgbGV0IHRlc3RMZWZ0ID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGZyb250RnJlZSArIDEpKS5taW51cyhyaWdodC5tdWx0aXBseSh0aGlzLnR1bm5lbFdpZHRoICsgMSkpO1xuICAgICAgICBsZXQgcmlnaHRDZWxsID0gZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRlc3RSaWdodCk7XG4gICAgICAgIGxldCBsZWZ0Q2VsbCA9IGR1bmdlb25DcmF3bGVyLmdldE1hcCh0ZXN0TGVmdCk7XG4gICAgICAgIGlmICghdGhpcy5jb250YWlucyhyaWdodENlbGwsIFR1bm5lbGVyQ2VsbFR5cGUuT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9BTlRFUk9PTV9PUEVOKSAmJlxuICAgICAgICAgICAgIXRoaXMuY29udGFpbnMobGVmdENlbGwsIFR1bm5lbGVyQ2VsbFR5cGUuT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9BTlRFUk9PTV9PUEVOKSkge1xuICAgICAgICAgICAgaXNTcGVjaWFsQ2FzZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocmlnaHRDZWxsID09PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9ST09NX09QRU4pIHx8IChsZWZ0Q2VsbCA9PT0gVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfUk9PTV9PUEVOKSkge1xuICAgICAgICAgICAgaXNTcGVjaWFsQ2FzZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAtdGhpcy50dW5uZWxXaWR0aCAtIDE7IGkgPD0gdGhpcy50dW5uZWxXaWR0aCArIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGVzdCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShmcm9udEZyZWUgKyAyKSkucGx1cyhyaWdodC5tdWx0aXBseShpKSk7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRlc3QpO1xuICAgICAgICAgICAgaWYgKGNlbGwgPT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1JPT01fT1BFTikge1xuICAgICAgICAgICAgICAgIGlzU3BlY2lhbENhc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTcGVjaWFsQ2FzZTtcbiAgICB9XG4gICAgc3Bhd25UdW5uZWxDcmF3bGVyKHNpemVVcFR1bm5lbCwgc2l6ZURvd25UdW5uZWwsIGxvY2F0aW9uLCBkaXJlY3Rpb24sIGdlbmVyYXRpb24sIGludGVuZGVkRGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCB0dW5uZWxXaWR0aCA9IHRoaXMudHVubmVsV2lkdGg7XG4gICAgICAgIGxldCBzdGVwTGVuZ3RoID0gdGhpcy5zdGVwTGVuZ3RoO1xuICAgICAgICBpZiAoc2l6ZVVwVHVubmVsKSB7XG4gICAgICAgICAgICB0dW5uZWxXaWR0aCsrO1xuICAgICAgICAgICAgc3RlcExlbmd0aCA9IHN0ZXBMZW5ndGggKyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemVEb3duVHVubmVsKSB7XG4gICAgICAgICAgICB0dW5uZWxXaWR0aC0tO1xuICAgICAgICAgICAgaWYgKHR1bm5lbFdpZHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIHR1bm5lbFdpZHRoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ZXBMZW5ndGggPSBzdGVwTGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIGlmIChzdGVwTGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgIHN0ZXBMZW5ndGggPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHVuZ2VvbkNyYXdsZXIuY3JlYXRlVHVubmVsQ3Jhd2xlcihsb2NhdGlvbiwgZGlyZWN0aW9uLCAwLCB0aGlzLmdldE1heEFnZVR1bm5lbENyYXdsZXJzKGdlbmVyYXRpb24pLCBnZW5lcmF0aW9uLCBpbnRlbmRlZERpcmVjdGlvbiwgc3RlcExlbmd0aCwgdHVubmVsV2lkdGgsIG9wdGlvbnMuc3RyYWlnaHREb3VibGVTcGF3blByb2JhYmlsaXR5LCBvcHRpb25zLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5LCBvcHRpb25zLmNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5LCBvcHRpb25zLm1ha2VSb29tc1JpZ2h0UHJvYmFiaWxpdHksIG9wdGlvbnMubWFrZVJvb21zTGVmdFByb2JhYmlsaXR5LCBvcHRpb25zLmpvaW5QcmVmZXJlbmNlKTtcbiAgICB9XG4gICAgc3Bhd25Sb29tQ3Jhd2xlcihsb2NhdGlvbiwgZGlyZWN0aW9uLCBhZ2UsIG1heEFnZSwgZ2VuZXJhdGlvbiwgc2l6ZSwgYnVpbHRBbnRlcm9vbSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0V2lkdGggPSBNYXRoLm1heCgxLCAyICogdGhpcy50dW5uZWxXaWR0aCk7XG4gICAgICAgIGlmIChidWlsdEFudGVyb29tKSB7XG4gICAgICAgICAgICBnZW5lcmF0aW9uID0gdGhpcy5nZW5lcmF0aW9uICsgTWF0aC5mbG9vcigoZ2VuZXJhdGlvbiAtIHRoaXMuZ2VuZXJhdGlvbikgLyAodGhpcy5jb25maWcuZ2VuU3BlZWRVcE9uQW50ZXJvb20pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLmNyZWF0ZVJvb21DcmF3bGVyKGxvY2F0aW9uLCBkaXJlY3Rpb24sIGFnZSwgbWF4QWdlLCBnZW5lcmF0aW9uLCBkZWZhdWx0V2lkdGgsIHNpemUpO1xuICAgIH1cbiAgICBidWlsZFNtYWxsZXJUdW5uZWwoZnJvbnRGcmVlLCBkdW5nZW9uQ3Jhd2xlciwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgdGVzdCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShmcm9udEZyZWUgKyAxKSk7XG4gICAgICAgIGNvbnN0IGNlbGwgPSBkdW5nZW9uQ3Jhd2xlci5nZXRNYXAodGVzdCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKGNlbGwsIFR1bm5lbGVyQ2VsbFR5cGUuT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX09QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9BTlRFUk9PTV9PUEVOKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJ1aWxkVHVubmVsKGZyb250RnJlZSwgMCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwib3BlbkFoZWFkLCBmYWlsZWQgdG8gam9pbiwgZnJvbnRGcmVlID0gXCIgKyBmcm9udEZyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLnR1bm5lbFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RQID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGZyb250RnJlZSArIDEpKS5wbHVzKHJpZ2h0Lm11bHRpcGx5KGkpKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxQID0gZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRlc3RQKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKGNlbGxQLCBUdW5uZWxlckNlbGxUeXBlLk9QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfQU5URVJPT01fT1BFTikpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGVzdE0gPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoZnJvbnRGcmVlICsgMSkpLm1pbnVzKHJpZ2h0Lm11bHRpcGx5KGkpKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxNID0gZHVuZ2VvbkNyYXdsZXIuZ2V0TWFwKHRlc3RNKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKGNlbGxNLCBUdW5uZWxlckNlbGxUeXBlLk9QRU4sIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTiwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfQU5URVJPT01fT1BFTikpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmFzc2VydChvZmZzZXQgIT09IDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBmcm9udEZyZWU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24ubXVsdGlwbHkoaSkpLnBsdXMocmlnaHQubXVsdGlwbHkob2Zmc2V0KSk7XG4gICAgICAgICAgICBkdW5nZW9uQ3Jhd2xlci5zZXRNYXAocG9pbnQsIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJvb21HZW5lcmF0aW9uKCkge1xuICAgICAgICBsZXQgZGljZVJvbGwgPSB0aGlzLnJuZy5pbnQgJSAxMDA7XG4gICAgICAgIGxldCByb29tR2VuZXJhdGlvbiA9IHRoaXMuZ2VuZXJhdGlvbjtcbiAgICAgICAgbGV0IHN1bW1lZFByb2JhYmlsaXR5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTA7IGkrKykge1xuICAgICAgICAgICAgc3VtbWVkUHJvYmFiaWxpdHkgPSBzdW1tZWRQcm9iYWJpbGl0eSArIHRoaXMuZ2V0Q2hpbGREZWxheVByb2JhYmlsaXR5Rm9yR2VuZXJhdGlvblJvb21DcmF3bGVycyhpKTtcbiAgICAgICAgICAgIGlmIChkaWNlUm9sbCA8IHN1bW1lZFByb2JhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgcm9vbUdlbmVyYXRpb24gPSB0aGlzLmdlbmVyYXRpb24gKyBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb29tR2VuZXJhdGlvbjtcbiAgICB9XG4gICAgc2lkZXdheXNCcmFuY2hpbmdSb29tU2l6ZXMoKSB7XG4gICAgICAgIGxldCBzaXplU2lkZXdheXM7XG4gICAgICAgIGxldCBzaXplQnJhbmNoaW5nO1xuICAgICAgICBjb25zdCBwcm9iYWJpbGl0eU1lZGl1bVNpZGV3YXlzID0gdGhpcy5nZXRSb29tU2l6ZVByb2JhYmlsaXR5U2lkZXdheXModGhpcy50dW5uZWxXaWR0aCwgUm9vbVNpemUuTUVESVVNKTtcbiAgICAgICAgY29uc3QgcHJvYmFiaWxpdHlTbWFsbFNpZGV3YXlzID0gdGhpcy5nZXRSb29tU2l6ZVByb2JhYmlsaXR5U2lkZXdheXModGhpcy50dW5uZWxXaWR0aCwgUm9vbVNpemUuU01BTEwpO1xuICAgICAgICBjb25zdCBwcm9iYWJpbGl0eU1lZGl1bUJyYW5jaGluZyA9IHRoaXMuZ2V0Um9vbVNpemVQcm9iYWJpbGl0eUJyYW5jaGluZyh0aGlzLnR1bm5lbFdpZHRoLCBSb29tU2l6ZS5NRURJVU0pO1xuICAgICAgICBjb25zdCBwcm9iU21hbGxCcmFuY2hpbmcgPSB0aGlzLmdldFJvb21TaXplUHJvYmFiaWxpdHlCcmFuY2hpbmcodGhpcy50dW5uZWxXaWR0aCwgUm9vbVNpemUuU01BTEwpO1xuICAgICAgICBsZXQgZGljZVJvbGwgPSB0aGlzLnJuZy5pbnQgJSAxMDA7XG4gICAgICAgIGlmIChkaWNlUm9sbCA8IHByb2JhYmlsaXR5U21hbGxTaWRld2F5cylcbiAgICAgICAgICAgIHNpemVTaWRld2F5cyA9IFJvb21TaXplLlNNQUxMO1xuICAgICAgICBlbHNlIGlmIChkaWNlUm9sbCA8IChwcm9iYWJpbGl0eVNtYWxsU2lkZXdheXMgKyBwcm9iYWJpbGl0eU1lZGl1bVNpZGV3YXlzKSlcbiAgICAgICAgICAgIHNpemVTaWRld2F5cyA9IFJvb21TaXplLk1FRElVTTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2l6ZVNpZGV3YXlzID0gUm9vbVNpemUuTEFSR0U7XG4gICAgICAgIGlmIChkaWNlUm9sbCA8IHByb2JTbWFsbEJyYW5jaGluZylcbiAgICAgICAgICAgIHNpemVCcmFuY2hpbmcgPSBSb29tU2l6ZS5TTUFMTDtcbiAgICAgICAgZWxzZSBpZiAoZGljZVJvbGwgPCAocHJvYlNtYWxsQnJhbmNoaW5nICsgcHJvYmFiaWxpdHlNZWRpdW1CcmFuY2hpbmcpKVxuICAgICAgICAgICAgc2l6ZUJyYW5jaGluZyA9IFJvb21TaXplLk1FRElVTTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2l6ZUJyYW5jaGluZyA9IFJvb21TaXplLkxBUkdFO1xuICAgICAgICByZXR1cm4gW3NpemVTaWRld2F5cywgc2l6ZUJyYW5jaGluZ107XG4gICAgfVxuICAgIGlzQ2hhbmdlRGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucm5nLmludCAlIDEwMCkgPCB0aGlzLmNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5O1xuICAgIH1cbiAgICBpc1NwYXduKGNoYW5nZURpcmVjdGlvbikge1xuICAgICAgICBpZiAoY2hhbmdlRGlyZWN0aW9uICYmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IHRoaXMudHVybkRvdWJsZVNwYXduUHJvYmFiaWxpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY2hhbmdlRGlyZWN0aW9uICYmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IHRoaXMuc3RyYWlnaHREb3VibGVTcGF3blByb2JhYmlsaXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1NwYXduUm9vbShkb1NwYXduKSB7XG4gICAgICAgIHJldHVybiBkb1NwYXduICYmICgodGhpcy5ybmcuaW50ICUgMTAwKSA+IHRoaXMuY29uZmlnLnBhdGllbmNlKTtcbiAgICB9XG4gICAgYnVpbGRBbnRlcm9vbShsZW5ndGgsIHdpZHRoKSB7XG4gICAgICAgIGlmICgobGVuZ3RoIDwgMykgfHwgKHdpZHRoIDwgMSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBbnRlcm9vbSBtdXN0IGJlIGF0IGxlYXN0IDN4M1wiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgW2Zyb250RnJlZV0gPSB0aGlzLmZyb250RnJlZSh0aGlzLmxvY2F0aW9uLCB0aGlzLmRpcmVjdGlvbiwgd2lkdGggKyAxLCB3aWR0aCArIDEpO1xuICAgICAgICBpZiAoZnJvbnRGcmVlIDw9IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodERpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGxldCBkaXJlY3Rpb25MZW5ndGggPSAxOyBkaXJlY3Rpb25MZW5ndGggPD0gbGVuZ3RoOyBkaXJlY3Rpb25MZW5ndGgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2lkZSA9IC13aWR0aDsgc2lkZSA8PSB3aWR0aDsgc2lkZSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShkaXJlY3Rpb25MZW5ndGgpKS5wbHVzKHJpZ2h0Lm11bHRpcGx5KHNpZGUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLnNldE1hcChjdXJyZW50LCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9BTlRFUk9PTV9PUEVOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHdpZHRoID49IDMpICYmIChsZW5ndGggPj0gNykgJiYgdGhpcy5jb25maWcuY29sdW1uc0luVHVubmVscykge1xuICAgICAgICAgICAgbGV0IGRpcmVjdGlvbkxlbmd0aCA9IDI7XG4gICAgICAgICAgICB0aGlzLnBsYWNlQ29sdW1ucyh3aWR0aCwgZGlyZWN0aW9uTGVuZ3RoLCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJ1aWxkVHVubmVsKGxlbmd0aCwgd2lkdGgpIHtcbiAgICAgICAgaWYgKChsZW5ndGggPCAxKSB8fCAod2lkdGggPCAwKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRyeWluZyB0byBidWlsZCB6ZXJvIHNpemUgdHVubmVsIHdpdGggbGVuZ3RoID0gXCIgKyBsZW5ndGggKyBcIjsgd2lkdGggPSAgXCIgKyB3aWR0aCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFtmcm9udEZyZWVdID0gdGhpcy5mcm9udEZyZWUodGhpcy5sb2NhdGlvbiwgdGhpcy5kaXJlY3Rpb24sIHdpZHRoICsgMSwgd2lkdGggKyAxKTtcbiAgICAgICAgaWYgKGZyb250RnJlZSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodERpcmVjdGlvbigpO1xuICAgICAgICBmb3IgKGxldCBkaXJlY3Rpb25MZW5ndGggPSAxOyBkaXJlY3Rpb25MZW5ndGggPD0gbGVuZ3RoOyBkaXJlY3Rpb25MZW5ndGgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2lkZSA9IC13aWR0aDsgc2lkZSA8PSB3aWR0aDsgc2lkZSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShkaXJlY3Rpb25MZW5ndGgpKS5wbHVzKHJpZ2h0Lm11bHRpcGx5KHNpZGUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLnNldE1hcChjdXJyZW50LCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh3aWR0aCA+PSAzKSAmJiAobGVuZ3RoID49IDcpICYmIHRoaXMuY29uZmlnLmNvbHVtbnNJblR1bm5lbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bUNvbHMgPSBNYXRoLmZsb29yKChsZW5ndGggLSAxKSAvIDYpO1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobnVtQ29scyA+IDApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db2xzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlyZWN0aW9uTGVuZ3RoID0gMiArIGkgKiAzO1xuICAgICAgICAgICAgICAgIHRoaXMucGxhY2VDb2x1bW5zKHdpZHRoLCBkaXJlY3Rpb25MZW5ndGgsIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGxhY2VDb2x1bW5zKHdpZHRoLCBkaXJlY3Rpb25MZW5ndGgsIHJpZ2h0KSB7XG4gICAgICAgIGxldCBzaWRlID0gLXdpZHRoICsgMTtcbiAgICAgICAgbGV0IHBvaW50ID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGRpcmVjdGlvbkxlbmd0aCkpLnBsdXMocmlnaHQubXVsdGlwbHkoc2lkZSkpO1xuICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLnNldE1hcChwb2ludCwgVHVubmVsZXJDZWxsVHlwZS5DT0xVTU4pO1xuICAgICAgICBzaWRlID0gd2lkdGggLSAxO1xuICAgICAgICBwb2ludCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShkaXJlY3Rpb25MZW5ndGgpKS5wbHVzKHJpZ2h0Lm11bHRpcGx5KHNpZGUpKTtcbiAgICAgICAgdGhpcy5kdW5nZW9uQ3Jhd2xlci5zZXRNYXAocG9pbnQsIFR1bm5lbGVyQ2VsbFR5cGUuQ09MVU1OKTtcbiAgICAgICAgZGlyZWN0aW9uTGVuZ3RoID0gZGlyZWN0aW9uTGVuZ3RoIC0gMTtcbiAgICAgICAgc2lkZSA9IC13aWR0aCArIDE7XG4gICAgICAgIHBvaW50ID0gdGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uLm11bHRpcGx5KGRpcmVjdGlvbkxlbmd0aCkpLnBsdXMocmlnaHQubXVsdGlwbHkoc2lkZSkpO1xuICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLnNldE1hcChwb2ludCwgVHVubmVsZXJDZWxsVHlwZS5DT0xVTU4pO1xuICAgICAgICBzaWRlID0gd2lkdGggLSAxO1xuICAgICAgICBwb2ludCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShkaXJlY3Rpb25MZW5ndGgpKS5wbHVzKHJpZ2h0Lm11bHRpcGx5KHNpZGUpKTtcbiAgICAgICAgdGhpcy5kdW5nZW9uQ3Jhd2xlci5zZXRNYXAocG9pbnQsIFR1bm5lbGVyQ2VsbFR5cGUuQ09MVU1OKTtcbiAgICB9XG4gICAgZ2V0Q2hpbGREZWxheVByb2JhYmlsaXR5Rm9yR2VuZXJhdGlvblJvb21DcmF3bGVycyhnZW5lcmF0aW9uKSB7XG4gICAgICAgIGlmICgoMCA8PSBnZW5lcmF0aW9uKSAmJiAoZ2VuZXJhdGlvbiA8PSAxMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5jaGlsZERlbGF5UHJvYmFiaWxpdHlGb3JHZW5lcmF0aW9uUm9vbUNyYXdsZXJzW2dlbmVyYXRpb25dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hpbGREZWxheVByb2JhYmlsaXR5Rm9yR2VuZXJhdGlvblR1bm5lbENyYXdsZXJzKGdlbmVyYXRpb24pIHtcbiAgICAgICAgaWYgKCgwIDw9IGdlbmVyYXRpb24pICYmIChnZW5lcmF0aW9uIDw9IDEwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNoaWxkRGVsYXlQcm9iYWJpbGl0eUZvckdlbmVyYXRpb25UdW5uZWxDcmF3bGVyc1tnZW5lcmF0aW9uXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEFudGVyb29tUHJvYmFiaWxpdHkodHVubmVsV2lkdGgpIHtcbiAgICAgICAgaWYgKHR1bm5lbFdpZHRoID49IHRoaXMuY29uZmlnLmFudGVyb29tUHJvYmFiaWxpdHkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmFudGVyb29tUHJvYmFiaWxpdHlbdHVubmVsV2lkdGhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNpemVVcFByb2JhYmlsaXR5KGdlbmVyYXRpb24pIHtcbiAgICAgICAgaWYgKGdlbmVyYXRpb24gPj0gdGhpcy5jb25maWcuc2l6ZVVwUHJvYmFiaWxpdHkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc2l6ZVVwUHJvYmFiaWxpdHlbdGhpcy5jb25maWcuc2l6ZVVwUHJvYmFiaWxpdHkubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc2l6ZVVwUHJvYmFiaWxpdHlbZ2VuZXJhdGlvbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2l6ZURvd25Qcm9iYWJpbGl0eShnZW5lcmF0aW9uKSB7XG4gICAgICAgIGlmIChnZW5lcmF0aW9uID49IHRoaXMuY29uZmlnLnNpemVEb3duUHJvYmFiaWxpdHkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc2l6ZURvd25Qcm9iYWJpbGl0eVt0aGlzLmNvbmZpZy5zaXplRG93blByb2JhYmlsaXR5Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNpemVEb3duUHJvYmFiaWxpdHlbZ2VuZXJhdGlvbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWF4QWdlVHVubmVsQ3Jhd2xlcnMoZ2VuZXJhdGlvbikge1xuICAgICAgICBpZiAoZ2VuZXJhdGlvbiA+PSB0aGlzLmNvbmZpZy5tYXhBZ2VzVHVubmVsQ3Jhd2xlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWF4QWdlc1R1bm5lbENyYXdsZXJzW3RoaXMuY29uZmlnLm1heEFnZXNUdW5uZWxDcmF3bGVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXhBZ2VzVHVubmVsQ3Jhd2xlcnNbZ2VuZXJhdGlvbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Um9vbVNpemVQcm9iYWJpbGl0eVNpZGV3YXlzKHR1bm5lbFdpZHRoLCBzaXplKSB7XG4gICAgICAgIGlmICh0dW5uZWxXaWR0aCA+PSB0aGlzLmNvbmZpZy5yb29tU2l6ZVByb2JhYmlsaXR5U2lkZXdheXNSb29tcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChSb29tU2l6ZS5MQVJHRSA9PT0gc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgUm9vbVNpemUuTEFSR0U6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25maWcucm9vbVNpemVQcm9iYWJpbGl0eVNpZGV3YXlzUm9vbXNbdHVubmVsV2lkdGhdWzJdKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJvb21TaXplLk1FRElVTTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNvbmZpZy5yb29tU2l6ZVByb2JhYmlsaXR5U2lkZXdheXNSb29tc1t0dW5uZWxXaWR0aF1bMV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgUm9vbVNpemUuU01BTEw6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25maWcucm9vbVNpemVQcm9iYWJpbGl0eVNpZGV3YXlzUm9vbXNbdHVubmVsV2lkdGhdWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSb29tU2l6ZVByb2JhYmlsaXR5QnJhbmNoaW5nKHR1bm5lbFdpZHRoLCBzaXplKSB7XG4gICAgICAgIGlmICh0dW5uZWxXaWR0aCA+PSB0aGlzLmNvbmZpZy5yb29tU2l6ZVByb2JhYmlsaXR5QnJhbmNoaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKFJvb21TaXplLkxBUkdFID09PSBzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChzaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSb29tU2l6ZS5MQVJHRTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNvbmZpZy5yb29tU2l6ZVByb2JhYmlsaXR5QnJhbmNoaW5nW3R1bm5lbFdpZHRoXVsyXSk7XG4gICAgICAgICAgICAgICAgY2FzZSBSb29tU2l6ZS5NRURJVU06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25maWcucm9vbVNpemVQcm9iYWJpbGl0eUJyYW5jaGluZ1t0dW5uZWxXaWR0aF1bMV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgUm9vbVNpemUuU01BTEw6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25maWcucm9vbVNpemVQcm9iYWJpbGl0eUJyYW5jaGluZ1t0dW5uZWxXaWR0aF1bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG11dGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHk6IHRoaXMuZHVuZ2VvbkNyYXdsZXIubXV0YXRlKHRoaXMuc3RyYWlnaHREb3VibGVTcGF3blByb2JhYmlsaXR5KSxcbiAgICAgICAgICAgIHR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5OiB0aGlzLmR1bmdlb25DcmF3bGVyLm11dGF0ZSh0aGlzLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5KSxcbiAgICAgICAgICAgIGNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5OiB0aGlzLmR1bmdlb25DcmF3bGVyLm11dGF0ZSh0aGlzLmNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5KSxcbiAgICAgICAgICAgIG1ha2VSb29tc1JpZ2h0UHJvYmFiaWxpdHk6IHRoaXMuZHVuZ2VvbkNyYXdsZXIubXV0YXRlKHRoaXMubWFrZVJvb21zUmlnaHRQcm9iYWJpbGl0eSksXG4gICAgICAgICAgICBtYWtlUm9vbXNMZWZ0UHJvYmFiaWxpdHk6IHRoaXMuZHVuZ2VvbkNyYXdsZXIubXV0YXRlKHRoaXMubWFrZVJvb21zTGVmdFByb2JhYmlsaXR5KSxcbiAgICAgICAgICAgIGpvaW5QcmVmZXJlbmNlOiB0aGlzLmR1bmdlb25DcmF3bGVyLm11dGF0ZSh0aGlzLmpvaW5QcmVmZXJlbmNlKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUdW5uZWxlckNlbGxUeXBlLCBSb29tLCBSb29tU2l6ZSB9IGZyb20gXCIuL21vZGVsXCI7XG5pbXBvcnQgeyBDcmF3bGVyIH0gZnJvbSBcIi4vY3Jhd2xlclwiO1xuZXhwb3J0IGNsYXNzIFJvb21DcmF3bGVyIGV4dGVuZHMgQ3Jhd2xlciB7XG4gICAgY29uc3RydWN0b3Iocm5nLCBkdW5nZW9uQ3Jhd2xlciwgbG9jYXRpb24sIGRpcmVjdGlvbiwgYWdlLCBtYXhBZ2UsIGdlbmVyYXRpb24sIGRlZmF1bHRXaWR0aCwgc2l6ZSkge1xuICAgICAgICBzdXBlcihybmcsIGR1bmdlb25DcmF3bGVyLCBsb2NhdGlvbiwgZGlyZWN0aW9uLCBhZ2UsIG1heEFnZSwgZ2VuZXJhdGlvbik7XG4gICAgICAgIHRoaXMuZGVmYXVsdFdpZHRoID0gZGVmYXVsdFdpZHRoO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICBzdGVwQWhlYWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kdW5nZW9uQ3Jhd2xlci5pc01vcmVSb29tc0R1bmdlb24odGhpcy5zaXplKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRpb24gIT09IHRoaXMuZHVuZ2VvbkNyYXdsZXIuYWN0aXZlR2VuZXJhdGlvbikge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5nZW5lcmF0aW9uID4gdGhpcy5kdW5nZW9uQ3Jhd2xlci5hY3RpdmVHZW5lcmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWdlKys7XG4gICAgICAgIGlmICh0aGlzLmFnZSA+PSB0aGlzLm1heEFnZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hZ2UgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodERpcmVjdGlvbigpO1xuICAgICAgICBsZXQgZGVmYXVsdFdpZHRoID0gdGhpcy5kZWZhdWx0V2lkdGg7XG4gICAgICAgIGNvbnN0IG1pblNpemUgPSB0aGlzLmdldE1pblJvb21TaXplKHRoaXMuc2l6ZSk7XG4gICAgICAgIGNvbnN0IG1heFNpemUgPSB0aGlzLmdldE1heFJvb21TaXplKHRoaXMuc2l6ZSk7XG4gICAgICAgIGxldCBsZWZ0RnJlZTtcbiAgICAgICAgbGV0IHJpZ2h0RnJlZTtcbiAgICAgICAgbGV0IGZyb250RnJlZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgW2Zyb250RnJlZSwgbGVmdEZyZWUsIHJpZ2h0RnJlZV0gPSB0aGlzLmZyb250RnJlZSh0aGlzLmxvY2F0aW9uLCB0aGlzLmRpcmVjdGlvbiwgZGVmYXVsdFdpZHRoICsgMSwgZGVmYXVsdFdpZHRoICsgMSk7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gZnJvbnRGcmVlIC0gMjtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IGxlZnRGcmVlICsgcmlnaHRGcmVlIC0gMTtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2lkdGggLyBsZW5ndGggPCB0aGlzLmNvbmZpZy5yb29tQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBNYXRoLmZsb29yKHdpZHRoIC8gdGhpcy5jb25maWcucm9vbUFzcGVjdFJhdGlvKTtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggLyBsZW5ndGggPCB0aGlzLmNvbmZpZy5yb29tQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImxlbmd0aCA9IFwiICsgbGVuZ3RoICsgXCIsIHdpZHRoID0gXCIgKyB3aWR0aCArIFwiLCBidXQgd2lkdGgvbGVuZ3RoIHNob3VsZCBiZSA+PSBcIiArIHRoaXMuY29uZmlnLnJvb21Bc3BlY3RSYXRpbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCAvIHdpZHRoIDwgdGhpcy5jb25maWcucm9vbUFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBNYXRoLmZsb29yKGxlbmd0aCAvIHRoaXMuY29uZmlnLnJvb21Bc3BlY3RSYXRpbyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCAvIHdpZHRoIDwgdGhpcy5jb25maWcucm9vbUFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJsZW5ndGggPSBcIiArIGxlbmd0aCArIFwiLCB3aWR0aCA9IFwiICsgd2lkdGggKyBcIiwgYnV0IGxlbmd0aC93aWR0aCBzaG91bGQgYmUgPj0gXCIgKyB0aGlzLmNvbmZpZy5yb29tQXNwZWN0UmF0aW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAvIGxlbmd0aCA8IHRoaXMuY29uZmlnLnJvb21Bc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgRW1wZXJvciBzdWdnZXN0cyB5b3UgbWFrZSB5b3VyIHJvb21Bc3BlY3RSYXRpbyBpbiB0aGUgZGVzaWduIGZpbGUgc21hbGxlci4uLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoICogd2lkdGggPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA+IHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3aWR0aCA+IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgtLTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IDUwKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChsZW5ndGggKiB3aWR0aCA8PSBtYXhTaXplKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGggKiB3aWR0aCA+PSBtaW5TaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vbSA9IG5ldyBSb29tKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRGcmVlIDw9IHJpZ2h0RnJlZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDIgKiBsZWZ0RnJlZSAtIDEpID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoUm9vbShyb29tLCByaWdodCwgbGVuZ3RoLCAod2lkdGggPj4gMSkgLSB3aWR0aCArIDEsIHdpZHRoID4+IDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hSb29tKHJvb20sIHJpZ2h0LCBsZW5ndGgsIC1sZWZ0RnJlZSArIDEsIC1sZWZ0RnJlZSArIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24ueCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kdW5nZW9uQ3Jhd2xlci5zZXRNYXAodGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uKSwgVHVubmVsZXJDZWxsVHlwZS5WX0RPT1IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5kaXJlY3Rpb24ueSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLnNldE1hcCh0aGlzLmxvY2F0aW9uLnBsdXModGhpcy5kaXJlY3Rpb24pLCBUdW5uZWxlckNlbGxUeXBlLkhfRE9PUik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMiAqIHJpZ2h0RnJlZSAtIDEpID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoUm9vbShyb29tLCByaWdodCwgbGVuZ3RoLCAtKHdpZHRoID4+IDEpLCAtKHdpZHRoID4+IDEpICsgd2lkdGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoUm9vbShyb29tLCByaWdodCwgbGVuZ3RoLCByaWdodEZyZWUgLSB3aWR0aCwgcmlnaHRGcmVlIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uLnggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHVuZ2VvbkNyYXdsZXIuc2V0TWFwKHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbiksIFR1bm5lbGVyQ2VsbFR5cGUuVl9ET09SKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMuZGlyZWN0aW9uLnkgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kdW5nZW9uQ3Jhd2xlci5zZXRNYXAodGhpcy5sb2NhdGlvbi5wbHVzKHRoaXMuZGlyZWN0aW9uKSwgVHVubmVsZXJDZWxsVHlwZS5IX0RPT1IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZHVuZ2VvbkNyYXdsZXIuYnVpbHRSb29tRHVuZ2Vvbih0aGlzLnNpemUpO1xuICAgICAgICAgICAgICAgIHJvb20uaW5EdW5nZW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLmFkZFJvb20ocm9vbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdpZHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKChmcm9udEZyZWUgLSAyKSA+PSAoKDIgKiBkZWZhdWx0V2lkdGggKyAxKSAqIHRoaXMuY29uZmlnLnJvb21Bc3BlY3RSYXRpbykpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGF0dGFjaFJvb20ocm9vbSwgcmlnaHQsIGxlbmd0aCwgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgZGlyZWN0aW9uID0gMTsgZGlyZWN0aW9uIDw9IGxlbmd0aDsgZGlyZWN0aW9uKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNpZGVEaXN0YW5jZSA9IGZyb207IHNpZGVEaXN0YW5jZSA8PSB0bzsgc2lkZURpc3RhbmNlKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMubG9jYXRpb24ucGx1cyh0aGlzLmRpcmVjdGlvbi5tdWx0aXBseShkaXJlY3Rpb24gKyAxKSkucGx1cyhyaWdodC5tdWx0aXBseShzaWRlRGlzdGFuY2UpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmR1bmdlb25DcmF3bGVyLnNldE1hcChwb2ludCwgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfUk9PTV9PUEVOKTtcbiAgICAgICAgICAgICAgICByb29tLmluc2lkZS5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNaW5Sb29tU2l6ZShzaXplKSB7XG4gICAgICAgIHN3aXRjaCAoc2l6ZSkge1xuICAgICAgICAgICAgY2FzZSBSb29tU2l6ZS5TTUFMTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWluUm9vbVNpemU7XG4gICAgICAgICAgICBjYXNlIFJvb21TaXplLk1FRElVTTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWVkaXVtUm9vbVNpemU7XG4gICAgICAgICAgICBjYXNlIFJvb21TaXplLkxBUkdFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5sYXJnZVJvb21TaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1heFJvb21TaXplKHNpemUpIHtcbiAgICAgICAgc3dpdGNoIChzaXplKSB7XG4gICAgICAgICAgICBjYXNlIFJvb21TaXplLlNNQUxMOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25maWcubWVkaXVtUm9vbVNpemUgLSAxKTtcbiAgICAgICAgICAgIGNhc2UgUm9vbVNpemUuTUVESVVNOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25maWcubGFyZ2VSb29tU2l6ZSAtIDEpO1xuICAgICAgICAgICAgY2FzZSBSb29tU2l6ZS5MQVJHRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY29uZmlnLm1heFJvb21TaXplIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBQb2ludCwgVHVubmVsZXJDZWxsVHlwZSwgRGlyZWN0aW9uLCBSb29tU2l6ZSwgRmlsbFJlY3QsIFJvb20gfSBmcm9tIFwiLi9tb2RlbFwiO1xuaW1wb3J0IHsgV2FsbENyYXdsZXIgfSBmcm9tIFwiLi93YWxsLmNyYXdsZXJcIjtcbmltcG9ydCB7IFR1bm5lbENyYXdsZXIgfSBmcm9tIFwiLi90dW5uZWwuY3Jhd2xlclwiO1xuaW1wb3J0IHsgUm9vbUNyYXdsZXIgfSBmcm9tIFwiLi9yb29tLmNyYXdsZXJcIjtcbmV4cG9ydCBjbGFzcyBEdW5nZW9uQ3Jhd2xlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBybmcpIHtcbiAgICAgICAgdGhpcy5yb29tcyA9IFtdO1xuICAgICAgICB0aGlzLm1hcEZsYWdzRGlyZWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmNyYXdsZXJzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlR2VuZXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuY3VyclNtYWxsUm9vbXNMYWJ5cmludGggPSAwO1xuICAgICAgICB0aGlzLmN1cnJNZWRpdW1Sb29tc0xhYnlyaW50aCA9IDA7XG4gICAgICAgIHRoaXMuY3VyckxhcmdlUm9vbXNMYWJ5cmludGggPSAwO1xuICAgICAgICB0aGlzLmN1cnJTbWFsbFJvb21zRHVuZ2VvbiA9IDA7XG4gICAgICAgIHRoaXMuY3Vyck1lZGl1bVJvb21zRHVuZ2VvbiA9IDA7XG4gICAgICAgIHRoaXMuY3VyckxhcmdlUm9vbXNEdW5nZW9uID0gMDtcbiAgICAgICAgdGhpcy5ybmcgPSBybmc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBjb25zb2xlLmFzc2VydChjb25maWcuY2hpbGREZWxheVByb2JhYmlsaXR5Rm9yR2VuZXJhdGlvbkNyYXdsZXJzLmxlbmd0aCA9PT0gMTEpO1xuICAgICAgICBjb25zb2xlLmFzc2VydChjb25maWcuY2hpbGREZWxheVByb2JhYmlsaXR5Rm9yR2VuZXJhdGlvblJvb21DcmF3bGVycy5sZW5ndGggPT09IDExKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoY29uZmlnLnJvb21Bc3BlY3RSYXRpbyA+PSAwICYmIGNvbmZpZy5yb29tQXNwZWN0UmF0aW8gPD0gMSwgXCJyb29tQXNwZWN0UmF0aW8gbXVzdCBiZSBhIGRvdWJsZSBiZXR3ZWVuIDAgYW5kIDFcIik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNvbmZpZy5nZW5TcGVlZFVwT25BbnRlcm9vbSA+PSAxLCBcIlBsZWFzZSB1c2UgZ2VuU3BlZWRVcE9uQW50ZXJvb20gPj0gMTsgcGFyYW1ldGVyIHJlc2V0IHRvIDFcIik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KCFjb25maWcuY3Jhd2xlcnNJbkFudGVyb29tcyB8fCAoY29uZmlnLmNyYXdsZXJzSW5BbnRlcm9vbXMgJiYgY29uZmlnLmNyYXdsZXJzSW5UdW5uZWxzKSwgXCJ3aGVuIHlvdSBhbGxvdyBDcmF3bGVycyBpbiBBbnRlcm9vbXMsIHlvdSBtdXN0IGFsc28gYWxsb3cgdGhlbSBpbiBUdW5uZWxzXCIpO1xuICAgICAgICB0aGlzLm1hcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLndpZHRoICogdGhpcy5jb25maWcuaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubWFwW2ldID0gdGhpcy5jb25maWcuYmFja2dyb3VuZDtcbiAgICAgICAgICAgIHRoaXMubWFwRmxhZ3NEaXJlY3Rpb25zW2ldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY3Jhd2xlcnNbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UmVjdCgwLCAwLCB0aGlzLmNvbmZpZy53aWR0aCAtIDEsIDAsIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9DTE9TRUQpO1xuICAgICAgICB0aGlzLnNldFJlY3QoMCwgMCwgMCwgdGhpcy5jb25maWcuaGVpZ2h0IC0gMSwgVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX0NMT1NFRCk7XG4gICAgICAgIHRoaXMuc2V0UmVjdCh0aGlzLmNvbmZpZy53aWR0aCAtIDEsIDAsIHRoaXMuY29uZmlnLndpZHRoIC0gMSwgdGhpcy5jb25maWcuaGVpZ2h0IC0gMSwgVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX0NMT1NFRCk7XG4gICAgICAgIHRoaXMuc2V0UmVjdCgwLCB0aGlzLmNvbmZpZy5oZWlnaHQgLSAxLCB0aGlzLmNvbmZpZy53aWR0aCAtIDEsIHRoaXMuY29uZmlnLmhlaWdodCAtIDEsIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9DTE9TRUQpO1xuICAgICAgICBmb3IgKGNvbnN0IGRlcyBvZiB0aGlzLmNvbmZpZy5kZXNpZ24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVjdEZpbGwoZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuY29uZmlnLm9wZW5pbmdzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb24uTk9SVEg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVjdCgwLCBNYXRoLmZsb29yKHRoaXMuY29uZmlnLmhlaWdodCAvIDIpIC0gMSwgMiwgTWF0aC5mbG9vcih0aGlzLmNvbmZpZy5oZWlnaHQgLyAyKSArIDEsIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb24uV0VTVDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSZWN0KE1hdGguZmxvb3IodGhpcy5jb25maWcud2lkdGggLyAyKSAtIDEsIDAsIE1hdGguZmxvb3IodGhpcy5jb25maWcud2lkdGggLyAyKSArIDEsIDIsIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb24uRUFTVDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSZWN0KE1hdGguZmxvb3IodGhpcy5jb25maWcud2lkdGggLyAyKSAtIDEsIHRoaXMuY29uZmlnLmhlaWdodCAtIDMsIE1hdGguZmxvb3IodGhpcy5jb25maWcud2lkdGggLyAyKSArIDEsIHRoaXMuY29uZmlnLmhlaWdodCAtIDEsIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEaXJlY3Rpb24uU09VVEg6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVjdCh0aGlzLmNvbmZpZy53aWR0aCAtIDMsIE1hdGguZmxvb3IodGhpcy5jb25maWcuaGVpZ2h0IC8gMikgLSAxLCB0aGlzLmNvbmZpZy53aWR0aCAtIDEsIE1hdGguZmxvb3IodGhpcy5jb25maWcuaGVpZ2h0IC8gMikgKyAxLCBUdW5uZWxlckNlbGxUeXBlLkdVQVJBTlRFRURfT1BFTik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlyZWN0aW9uLk5PUlRIX1dFU1Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVjdCgwLCAwLCAyLCAyLCBUdW5uZWxlckNlbGxUeXBlLkdVQVJBTlRFRURfT1BFTik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlyZWN0aW9uLk5PUlRIX0VBU1Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVjdCgwLCB0aGlzLmNvbmZpZy5oZWlnaHQgLSAzLCAyLCB0aGlzLmNvbmZpZy5oZWlnaHQgLSAxLCBUdW5uZWxlckNlbGxUeXBlLkdVQVJBTlRFRURfT1BFTik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlyZWN0aW9uLlNPVVRIX1dFU1Q6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVjdCh0aGlzLmNvbmZpZy53aWR0aCAtIDMsIDAsIHRoaXMuY29uZmlnLndpZHRoIC0gMSwgMiwgVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX09QRU4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERpcmVjdGlvbi5TT1VUSF9FQVNUOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFJlY3QodGhpcy5jb25maWcud2lkdGggLSAzLCB0aGlzLmNvbmZpZy5oZWlnaHQgLSAzLCB0aGlzLmNvbmZpZy53aWR0aCAtIDEsIHRoaXMuY29uZmlnLmhlaWdodCAtIDEsIFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGF3blJhbmRvbVdhbGxDcmF3bGVyID0gKGxvY2F0aW9uLCBkaXJlY3Rpb24sIGdlbmVyYXRpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlV2FsbENyYXdsZXIobG9jYXRpb24sIGRpcmVjdGlvbiwgMCwgdGhpcy5nZXRNYXhBZ2VDcmF3bGVycyhnZW5lcmF0aW9uKSwgZ2VuZXJhdGlvbiwgZGlyZWN0aW9uLCB0aGlzLmdldFN0ZXBMZW5ndGgoZ2VuZXJhdGlvbiksIDEsIHRoaXMuZ2V0Q29ycmlkb3JXaWR0aChnZW5lcmF0aW9uKSwgdGhpcy5tdXRhdGUyKGNvbmZpZy5yYW5kQ3Jhd2xlci5zdHJhaWdodFNpbmdsZVNwYXduUHJvYmFiaWxpdHkpLCB0aGlzLm11dGF0ZTIoY29uZmlnLnJhbmRDcmF3bGVyLnN0cmFpZ2h0RG91YmxlU3Bhd25Qcm9iYWJpbGl0eSksIHRoaXMubXV0YXRlMihjb25maWcucmFuZENyYXdsZXIudHVyblNpbmdsZVNwYXduUHJvYmFiaWxpdHkpLCB0aGlzLm11dGF0ZTIoY29uZmlnLnJhbmRDcmF3bGVyLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5KSwgdGhpcy5tdXRhdGUyKGNvbmZpZy5yYW5kQ3Jhd2xlci5jaGFuZ2VEaXJlY3Rpb25Qcm9iYWJpbGl0eSkpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBnZW5lcmF0aW9uID0gMDsgZ2VuZXJhdGlvbiA8IGNvbmZpZy5yYW5kQ3Jhd2xlci5wZXJHZW5lcmF0aW9uLmxlbmd0aDsgZ2VuZXJhdGlvbisrKSB7XG4gICAgICAgICAgICBsZXQgY3Jhd2xlcnNQZXIxMDAwU3F1YXJlcyA9IGNvbmZpZy5yYW5kQ3Jhd2xlci5wZXJHZW5lcmF0aW9uW2dlbmVyYXRpb25dO1xuICAgICAgICAgICAgaWYgKGNyYXdsZXJzUGVyMTAwMFNxdWFyZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNyYXdsZXJzUGVyVG9wQm90dG9tV2FsbCA9IE1hdGguZmxvb3IoKHRoaXMuY29uZmlnLmhlaWdodCAqIGNyYXdsZXJzUGVyMTAwMFNxdWFyZXMpIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNyYXdsZXJzUGVyVG9wQm90dG9tV2FsbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ybmcuaW50ICUgMTAwMCA8ICh0aGlzLmNvbmZpZy5oZWlnaHQgKiBjcmF3bGVyc1BlcjEwMDBTcXVhcmVzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyYXdsZXJzUGVyVG9wQm90dG9tV2FsbCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB5SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZCA9IDA7IGluZCA8IGNyYXdsZXJzUGVyVG9wQm90dG9tV2FsbDsgaW5kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeUluZGV4ID0gMiArIHRoaXMucm5nLmludCAlICh0aGlzLmNvbmZpZy5oZWlnaHQgLSA0KTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25SYW5kb21XYWxsQ3Jhd2xlcihuZXcgUG9pbnQoMCwgeUluZGV4KSwgUG9pbnQuU09VVEgsIGdlbmVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB5SW5kZXggPSAyICsgdGhpcy5ybmcuaW50ICUgKHRoaXMuY29uZmlnLmhlaWdodCAtIDQpO1xuICAgICAgICAgICAgICAgICAgICBzcGF3blJhbmRvbVdhbGxDcmF3bGVyKG5ldyBQb2ludCh0aGlzLmNvbmZpZy53aWR0aCAtIDEsIHlJbmRleCksIFBvaW50Lk5PUlRILCBnZW5lcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNyYXdsZXJzUGVyTGVmdFJpZ2h0V2FsbCA9IE1hdGguZmxvb3IoKHRoaXMuY29uZmlnLndpZHRoICogY3Jhd2xlcnNQZXIxMDAwU3F1YXJlcykgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Jhd2xlcnNQZXJMZWZ0UmlnaHRXYWxsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJuZy5pbnQgJSAxMDAwIDwgKHRoaXMuY29uZmlnLndpZHRoICogY3Jhd2xlcnNQZXIxMDAwU3F1YXJlcykpXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmF3bGVyc1BlckxlZnRSaWdodFdhbGwgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgeEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNyYXdsZXJzUGVyTGVmdFJpZ2h0V2FsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHhJbmRleCA9IDIgKyB0aGlzLnJuZy5pbnQgJSAodGhpcy5jb25maWcud2lkdGggLSA0KTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25SYW5kb21XYWxsQ3Jhd2xlcihuZXcgUG9pbnQoeEluZGV4LCAwKSwgUG9pbnQuRUFTVCwgZ2VuZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHhJbmRleCA9IDIgKyB0aGlzLnJuZy5pbnQgJSAodGhpcy5jb25maWcud2lkdGggLSA0KTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhd25SYW5kb21XYWxsQ3Jhd2xlcihuZXcgUG9pbnQoeEluZGV4LCB0aGlzLmNvbmZpZy5oZWlnaHQgLSAxKSwgUG9pbnQuRUFTVCwgZ2VuZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2Qgb2YgY29uZmlnLmNyYXdsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVdhbGxDcmF3bGVyKGNkLmxvY2F0aW9uLCBjZC5kaXJlY3Rpb24sIC1jZC5hZ2UsIGNkLm1heEFnZSwgY2QuZ2VuZXJhdGlvbiwgY2QuaW50ZW5kZWREaXJlY3Rpb24sIGNkLnN0ZXBMZW5ndGgsIGNkLm9wZW5pbmcsIGNkLmNvcnJpZG9yV2lkdGgsIGNkLnN0cmFpZ2h0U2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgY2Quc3RyYWlnaHREb3VibGVTcGF3blByb2JhYmlsaXR5LCBjZC50dXJuU2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgY2QudHVybkRvdWJsZVNwYXduUHJvYmFiaWxpdHksIGNkLmNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBbZmlyc3QsIHNlY29uZF0gb2YgY29uZmlnLmNyYXdsZXJQYWlycykge1xuICAgICAgICAgICAgbGV0IGZpcnN0SXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJuZy5ib29sZWFuKVxuICAgICAgICAgICAgICAgIGZpcnN0SXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVdhbGxDcmF3bGVyKGZpcnN0LmxvY2F0aW9uLCBmaXJzdC5kaXJlY3Rpb24sIC1maXJzdC5hZ2UsIGZpcnN0Lm1heEFnZSwgZmlyc3QuZ2VuZXJhdGlvbiwgZmlyc3QuaW50ZW5kZWREaXJlY3Rpb24sIGZpcnN0LnN0ZXBMZW5ndGgsIChmaXJzdElzT3BlbiA/IDEgOiAwKSwgZmlyc3QuY29ycmlkb3JXaWR0aCwgZmlyc3Quc3RyYWlnaHRTaW5nbGVTcGF3blByb2JhYmlsaXR5LCBmaXJzdC5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIGZpcnN0LnR1cm5TaW5nbGVTcGF3blByb2JhYmlsaXR5LCBmaXJzdC50dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSwgZmlyc3QuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpO1xuICAgICAgICAgICAgdGhpcy5zZXRNYXAoZmlyc3QubG9jYXRpb24sIFR1bm5lbGVyQ2VsbFR5cGUuQ0xPU0VEKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlV2FsbENyYXdsZXIoc2Vjb25kLmxvY2F0aW9uLCBzZWNvbmQuZGlyZWN0aW9uLCAtc2Vjb25kLmFnZSwgc2Vjb25kLm1heEFnZSwgc2Vjb25kLmdlbmVyYXRpb24sIHNlY29uZC5pbnRlbmRlZERpcmVjdGlvbiwgc2Vjb25kLnN0ZXBMZW5ndGgsIChmaXJzdElzT3BlbiA/IDEgOiAwKSwgc2Vjb25kLmNvcnJpZG9yV2lkdGgsIHNlY29uZC5zdHJhaWdodFNpbmdsZVNwYXduUHJvYmFiaWxpdHksIHNlY29uZC5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHNlY29uZC50dXJuU2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgc2Vjb25kLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5LCBzZWNvbmQuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpO1xuICAgICAgICAgICAgdGhpcy5zZXRNYXAoc2Vjb25kLmxvY2F0aW9uLCBUdW5uZWxlckNlbGxUeXBlLkNMT1NFRCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdGQgb2YgY29uZmlnLnR1bm5lbENyYXdsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVR1bm5lbENyYXdsZXIodGQubG9jYXRpb24sIHRkLmRpcmVjdGlvbiwgLXRkLmFnZSwgdGQubWF4QWdlLCB0ZC5nZW5lcmF0aW9uLCB0ZC5pbnRlbmRlZERpcmVjdGlvbiwgdGQuc3RlcExlbmd0aCwgdGQudHVubmVsV2lkdGgsIHRkLnN0cmFpZ2h0RG91YmxlU3Bhd25Qcm9iYWJpbGl0eSwgdGQudHVybkRvdWJsZVNwYXduUHJvYmFiaWxpdHksIHRkLmNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5LCB0ZC5tYWtlUm9vbXNSaWdodFByb2JhYmlsaXR5LCB0ZC5tYWtlUm9vbXNMZWZ0UHJvYmFiaWxpdHksIHRkLmpvaW5QcmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc09wZW4ocG9zKSB7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5nZXRNYXAocG9zKTtcbiAgICAgICAgcmV0dXJuICh0eXBlID09PSBUdW5uZWxlckNlbGxUeXBlLk9QRU4pIHx8XG4gICAgICAgICAgICAodHlwZSA9PT0gVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9PUEVOKSB8fFxuICAgICAgICAgICAgKHR5cGUgPT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOKSB8fFxuICAgICAgICAgICAgKHR5cGUgPT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX0FOVEVST09NX09QRU4pIHx8XG4gICAgICAgICAgICAodHlwZSA9PT0gVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX09QRU4pIHx8XG4gICAgICAgICAgICAodHlwZSA9PT0gVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9HVUFSQU5URUVEX09QRU4pO1xuICAgIH1cbiAgICBzdGF0aWMgaXNBY3RpdmUocG9zLCBBY3RpdmUpIHtcbiAgICAgICAgZm9yIChsZXQgaSBvZiBBY3RpdmUpIHtcbiAgICAgICAgICAgIGlmICgocG9zLnggPT09IGkueCkgJiYgKHBvcy55ID09PSBpLnkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2V0TWFwKHBvaW50LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgICAgICBjb25zdCB5ID0gcG9pbnQueTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZGF0YSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoKHggPCB0aGlzLmNvbmZpZy53aWR0aCkgJiYgKHkgPCB0aGlzLmNvbmZpZy5oZWlnaHQpICYmICh4ID49IDApICYmICh5ID49IDApKTtcbiAgICAgICAgdGhpcy5tYXBbeCAqIHRoaXMuY29uZmlnLmhlaWdodCArIHldID0gZGF0YTtcbiAgICB9XG4gICAgZ2V0TWFwKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgICAgICBjb25zdCB5ID0gcG9pbnQueTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoKHggPCB0aGlzLmNvbmZpZy53aWR0aCkgJiYgKHkgPCB0aGlzLmNvbmZpZy5oZWlnaHQpICYmICh4ID49IDApICYmICh5ID49IDApKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwW3ggKiB0aGlzLmNvbmZpZy5oZWlnaHQgKyB5XTtcbiAgICB9XG4gICAgaXNNYXBPcGVuKHBvaW50KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5nZXRNYXAocG9pbnQpKSB7XG4gICAgICAgICAgICBjYXNlIFR1bm5lbGVyQ2VsbFR5cGUuT1BFTjpcbiAgICAgICAgICAgIGNhc2UgVHVubmVsZXJDZWxsVHlwZS5HVUFSQU5URUVEX09QRU46XG4gICAgICAgICAgICBjYXNlIFR1bm5lbGVyQ2VsbFR5cGUuTk9OX0pPSU5fT1BFTjpcbiAgICAgICAgICAgIGNhc2UgVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9HVUFSQU5URUVEX09QRU46XG4gICAgICAgICAgICBjYXNlIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1JPT01fT1BFTjpcbiAgICAgICAgICAgIGNhc2UgVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU46XG4gICAgICAgICAgICBjYXNlIFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX0FOVEVST09NX09QRU46XG4gICAgICAgICAgICBjYXNlIFR1bm5lbGVyQ2VsbFR5cGUuSF9ET09SOlxuICAgICAgICAgICAgY2FzZSBUdW5uZWxlckNlbGxUeXBlLlZfRE9PUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTW9yZVJvb21zTGFieXJpbnRoKHNpemUgPSBudWxsKSB7XG4gICAgICAgIGlmIChzaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpemUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJvb21TaXplLlNNQUxMOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY29uZmlnLm51bVNtYWxsUm9vbXNJbkxhYnlyaW50aCA+IHRoaXMuY3VyclNtYWxsUm9vbXNMYWJ5cmludGgpO1xuICAgICAgICAgICAgICAgIGNhc2UgUm9vbVNpemUuTUVESVVNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY29uZmlnLm51bU1lZGl1bVJvb21zSW5MYWJ5cmludGggPiB0aGlzLmN1cnJNZWRpdW1Sb29tc0xhYnlyaW50aCk7XG4gICAgICAgICAgICAgICAgY2FzZSBSb29tU2l6ZS5MQVJHRTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNvbmZpZy5udW1MYXJnZVJvb21zSW5MYWJ5cmludGggPiB0aGlzLmN1cnJMYXJnZVJvb21zTGFieXJpbnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pc01vcmVSb29tc0xhYnlyaW50aChSb29tU2l6ZS5TTUFMTCkgfHwgdGhpcy5pc01vcmVSb29tc0xhYnlyaW50aChSb29tU2l6ZS5NRURJVU0pIHx8IHRoaXMuaXNNb3JlUm9vbXNMYWJ5cmludGgoUm9vbVNpemUuTEFSR0UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc01vcmVSb29tc0R1bmdlb24oc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChzaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSb29tU2l6ZS5TTUFMTDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNvbmZpZy5udW1TbWFsbFJvb21zSW5EdW5nZW9uID4gdGhpcy5jdXJyU21hbGxSb29tc0R1bmdlb24pO1xuICAgICAgICAgICAgICAgIGNhc2UgUm9vbVNpemUuTUVESVVNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY29uZmlnLm51bU1lZGl1bVJvb21zSW5EdW5nZW9uID4gdGhpcy5jdXJyTWVkaXVtUm9vbXNEdW5nZW9uKTtcbiAgICAgICAgICAgICAgICBjYXNlIFJvb21TaXplLkxBUkdFOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY29uZmlnLm51bUxhcmdlUm9vbXNJbkR1bmdlb24gPiB0aGlzLmN1cnJMYXJnZVJvb21zRHVuZ2Vvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaXNNb3JlUm9vbXNEdW5nZW9uKFJvb21TaXplLlNNQUxMKSB8fCB0aGlzLmlzTW9yZVJvb21zRHVuZ2VvbihSb29tU2l6ZS5NRURJVU0pIHx8IHRoaXMuaXNNb3JlUm9vbXNEdW5nZW9uKFJvb21TaXplLkxBUkdFKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbHRSb29tRHVuZ2VvbihzaXplKSB7XG4gICAgICAgIGlmIChSb29tU2l6ZS5TTUFMTCA9PT0gc2l6ZSlcbiAgICAgICAgICAgIHRoaXMuY3VyclNtYWxsUm9vbXNEdW5nZW9uKys7XG4gICAgICAgIGVsc2UgaWYgKFJvb21TaXplLk1FRElVTSA9PT0gc2l6ZSlcbiAgICAgICAgICAgIHRoaXMuY3Vyck1lZGl1bVJvb21zRHVuZ2VvbisrO1xuICAgICAgICBlbHNlIGlmIChSb29tU2l6ZS5MQVJHRSA9PT0gc2l6ZSlcbiAgICAgICAgICAgIHRoaXMuY3VyckxhcmdlUm9vbXNEdW5nZW9uKys7XG4gICAgfVxuICAgIGdldFN0ZXBMZW5ndGgoZ2VuZXJhdGlvbikge1xuICAgICAgICBpZiAoZ2VuZXJhdGlvbiA+PSB0aGlzLmNvbmZpZy5zdGVwTGVuZ3Rocy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc3RlcExlbmd0aHNbdGhpcy5jb25maWcuc3RlcExlbmd0aHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5zdGVwTGVuZ3Roc1tnZW5lcmF0aW9uXTtcbiAgICB9XG4gICAgZ2V0Q29ycmlkb3JXaWR0aChnZW5lcmF0aW9uKSB7XG4gICAgICAgIGlmIChnZW5lcmF0aW9uID49IHRoaXMuY29uZmlnLmNvcnJpZG9yV2lkdGhzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5jb3JyaWRvcldpZHRoc1t0aGlzLmNvbmZpZy5jb3JyaWRvcldpZHRocy5sZW5ndGggLSAxXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNvcnJpZG9yV2lkdGhzW2dlbmVyYXRpb25dO1xuICAgIH1cbiAgICBnZXRNYXhBZ2VDcmF3bGVycyhnZW5lcmF0aW9uKSB7XG4gICAgICAgIGlmIChnZW5lcmF0aW9uID49IHRoaXMuY29uZmlnLm1heEFnZXNDcmF3bGVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWF4QWdlc0NyYXdsZXJzW3RoaXMuY29uZmlnLm1heEFnZXNDcmF3bGVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1heEFnZXNDcmF3bGVyc1tnZW5lcmF0aW9uXTtcbiAgICB9XG4gICAgYWRkUm9vbShyKSB7XG4gICAgICAgIHRoaXMucm9vbXMucHVzaChyKTtcbiAgICB9XG4gICAgaXNDaGVja2VkKHBvcykge1xuICAgICAgICBjb25zb2xlLmFzc2VydCgocG9zLnggPCB0aGlzLmNvbmZpZy53aWR0aCkgJiYgKHBvcy55IDwgdGhpcy5jb25maWcuaGVpZ2h0KSAmJiAocG9zLnggPj0gMCkgJiYgKHBvcy55ID49IDApKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRmxhZ3NEaXJlY3Rpb25zW3Bvcy54ICogdGhpcy5jb25maWcuaGVpZ2h0ICsgcG9zLnldO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDaGVja2VkTGlzdChwb3MsIGNoZWNrZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGVja2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKHBvcy54ID09PSBjaGVja2VkW2ldLngpICYmIChwb3MueSA9PT0gY2hlY2tlZFtpXS55KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldENoZWNrZWQocG9zKSB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KChwb3MueCA8IHRoaXMuY29uZmlnLndpZHRoKSAmJiAocG9zLnkgPCB0aGlzLmNvbmZpZy5oZWlnaHQpICYmIChwb3MueCA+PSAwKSAmJiAocG9zLnkgPj0gMCkpO1xuICAgICAgICB0aGlzLm1hcEZsYWdzRGlyZWN0aW9uc1twb3MueCAqIHRoaXMuY29uZmlnLmhlaWdodCArIHBvcy55XSA9IHRydWU7XG4gICAgfVxuICAgIHNldFJlY3RGaWxsKHJlY3QpIHtcbiAgICAgICAgdGhpcy5zZXRSZWN0KHJlY3Quc3RhcnRYLCByZWN0LnN0YXJ0WSwgcmVjdC5lbmRYLCByZWN0LmVuZFksIHJlY3QudHlwZSk7XG4gICAgfVxuICAgIHNldFJlY3Qoc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGRhdGEpIHtcbiAgICAgICAgaWYgKChlbmRYIDwgc3RhcnRYKSB8fCAoZW5kWSA8IHN0YXJ0WSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFJlZnVzZSB0byBzZXQgaW5jb3JyZWN0bHkgc3BlY2lmaWVkIHJlY3RhbmdsZTsgc1ggPSAke3N0YXJ0WH0gc1k9JHtzdGFydFl9IGVYPSR7ZW5kWH0gZW5kWT0ke2VuZFl9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gc3RhcnRYOyB4IDw9IGVuZFg7IHgrKylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gc3RhcnRZOyB5IDw9IGVuZFk7IHkrKylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRNYXAoeyB4OiB4LCB5OiB5IH0sIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVdhbGxDcmF3bGVyKGxvY2F0aW9uLCBkaXJlY3Rpb24sIGFnZSwgbWF4QWdlLCBnZW5lcmF0aW9uLCBpbnRlbmRlZERpcmVjdGlvbiwgc3RlcExlbmd0aCwgb3BlbmluZywgY29ycmlkb3JXaWR0aCwgc3RyYWlnaHRTaW5nbGVTcGF3blByb2JhYmlsaXR5LCBzdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHR1cm5TaW5nbGVTcGF3blByb2JhYmlsaXR5LCB0dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSwgY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpIHtcbiAgICAgICAgbGV0IGNyYXdsZXIgPSBuZXcgV2FsbENyYXdsZXIodGhpcy5ybmcsIHRoaXMsIFBvaW50LmZyb20obG9jYXRpb24pLCBQb2ludC5mcm9tKGRpcmVjdGlvbiksIGFnZSwgbWF4QWdlLCBnZW5lcmF0aW9uLCBQb2ludC5mcm9tKGludGVuZGVkRGlyZWN0aW9uKSwgc3RlcExlbmd0aCwgb3BlbmluZywgY29ycmlkb3JXaWR0aCwgc3RyYWlnaHRTaW5nbGVTcGF3blByb2JhYmlsaXR5LCBzdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHR1cm5TaW5nbGVTcGF3blByb2JhYmlsaXR5LCB0dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSwgY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY3Jhd2xlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNyYXdsZXJzW2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmF3bGVyc1tpXSA9IGNyYXdsZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Jhd2xlcnMucHVzaChjcmF3bGVyKTtcbiAgICB9XG4gICAgY3JlYXRlVHVubmVsQ3Jhd2xlcihsb2NhdGlvbiwgZGlyZWN0aW9uLCBhZ2UsIG1heEFnZSwgZ2VuZXJhdGlvbiwgaW50ZW5kZWREaXJlY3Rpb24sIHN0ZXBMZW5ndGgsIHR1bm5lbFdpZHRoLCBzdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5LCBjaGFuZ2VEaXJlY3Rpb25Qcm9iYWJpbGl0eSwgbWFrZVJvb21zUmlnaHRQcm9iYWJpbGl0eSwgbWFrZVJvb21zTGVmdFByb2JhYmlsaXR5LCBqb2luUHJlZmVyZW5jZSkge1xuICAgICAgICBsZXQgY3Jhd2xlciA9IG5ldyBUdW5uZWxDcmF3bGVyKHRoaXMucm5nLCB0aGlzLCBQb2ludC5mcm9tKGxvY2F0aW9uKSwgUG9pbnQuZnJvbShkaXJlY3Rpb24pLCBhZ2UsIG1heEFnZSwgZ2VuZXJhdGlvbiwgUG9pbnQuZnJvbShpbnRlbmRlZERpcmVjdGlvbiksIHN0ZXBMZW5ndGgsIHR1bm5lbFdpZHRoLCBzdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5LCBjaGFuZ2VEaXJlY3Rpb25Qcm9iYWJpbGl0eSwgbWFrZVJvb21zUmlnaHRQcm9iYWJpbGl0eSwgbWFrZVJvb21zTGVmdFByb2JhYmlsaXR5LCBqb2luUHJlZmVyZW5jZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jcmF3bGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Jhd2xlcnNbaV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyYXdsZXJzW2ldID0gY3Jhd2xlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmF3bGVycy5wdXNoKGNyYXdsZXIpO1xuICAgIH1cbiAgICBjcmVhdGVSb29tQ3Jhd2xlcihsb2NhdGlvbiwgZGlyZWN0aW9uLCBhZ2UsIG1heEFnZSwgZ2VuZXJhdGlvbiwgZGVmYXVsdFdpZHRoLCBzaXplKSB7XG4gICAgICAgIGNvbnN0IGNyYXdsZXIgPSBuZXcgUm9vbUNyYXdsZXIodGhpcy5ybmcsIHRoaXMsIFBvaW50LmZyb20obG9jYXRpb24pLCBQb2ludC5mcm9tKGRpcmVjdGlvbiksIGFnZSwgbWF4QWdlLCBnZW5lcmF0aW9uLCBkZWZhdWx0V2lkdGgsIHNpemUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY3Jhd2xlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNyYXdsZXJzW2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmF3bGVyc1tpXSA9IGNyYXdsZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Jhd2xlcnMucHVzaChjcmF3bGVyKTtcbiAgICB9XG4gICAgbXV0YXRlKGlucHV0KSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBpbnB1dCAtIHRoaXMuY29uZmlnLm11dGF0b3IgKyAodGhpcy5ybmcuaW50ICUgKDIgKiB0aGlzLmNvbmZpZy5tdXRhdG9yICsgMSkpO1xuICAgICAgICBpZiAob3V0cHV0IDwgMClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBtdXRhdGUyKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dCA8PSA1MCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMucm5nLmludCAlICgyICogaW5wdXQgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPiAxMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gKDIgKiBpbnB1dCAtIDEwMCArIHRoaXMucm5nLmludCAlICgyMDAgLSAyICogaW5wdXQgKyAxKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU2VlZENyYXdsZXJzSW5UdW5uZWxzKCkge1xuICAgICAgICBsZXQgbnVtYmVyRm91bmQgPSAwO1xuICAgICAgICBsZXQgdHJpZXMgPSAwO1xuICAgICAgICBuZXcgV2FsbENyYXdsZXIodGhpcy5ybmcsIHRoaXMsIG5ldyBQb2ludCgyLCAyKSwgUG9pbnQuU09VVEgsIDAsIDEsIDAsIFBvaW50LlNPVVRILCAxLCAwLCAxLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgd2hpbGUgKChudW1iZXJGb3VuZCA8IHRoaXMuY29uZmlnLnNlZWRDcmF3bGVyc0luVHVubmVscykgJiYgKHRyaWVzIDwgdGhpcy5jb25maWcud2lkdGggKiB0aGlzLmNvbmZpZy5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0cmllcysrO1xuICAgICAgICAgICAgbGV0IHN0YXJ0WCA9IDEgKyB0aGlzLnJuZy5pbnQgJSAodGhpcy5jb25maWcud2lkdGggLSA0KTtcbiAgICAgICAgICAgIGxldCBzdGFydFkgPSAxICsgdGhpcy5ybmcuaW50ICUgKHRoaXMuY29uZmlnLmhlaWdodCAtIDQpO1xuICAgICAgICAgICAgbGV0IHRlc3QgPSBuZXcgUG9pbnQoc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgaWYgKCh0aGlzLnJuZy5pbnQgJSAxMDApIDwgNTApXG4gICAgICAgICAgICAgICAgc3RhcnRYID0gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdGFydFkgPSAwO1xuICAgICAgICAgICAgaWYgKHN0YXJ0WCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IDUwKVxuICAgICAgICAgICAgICAgICAgICBzdGFydFkgPSAtMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzdGFydFkgPT09IDApO1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IDUwKVxuICAgICAgICAgICAgICAgICAgICBzdGFydFggPSAtMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gbmV3IFBvaW50KHN0YXJ0WCwgc3RhcnRZKTtcbiAgICAgICAgICAgIGxldCBvcnRob2dvbmFsO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbi54ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgb3J0aG9nb25hbCA9IG5ldyBQb2ludChkaXJlY3Rpb24ueSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24ueSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG9ydGhvZ29uYWwgPSBuZXcgUG9pbnQoMCwgLWRpcmVjdGlvbi54KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaWxsZWdhbCBkaXJlY3Rpb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBub3RGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAobm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICB0ZXN0ID0gdGVzdC5wbHVzKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCh0ZXN0LnggPCAyKSB8fCAodGVzdC55IDwgMikgfHwgKHRlc3QueCA+IHRoaXMuY29uZmlnLndpZHRoIC0gMykgfHwgKHRlc3QueSA+IHRoaXMuY29uZmlnLmhlaWdodCAtIDMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRNYXAodGVzdCkgIT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZ2V0TWFwKHRlc3QucGx1cyhkaXJlY3Rpb24pKSAhPT0gVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU4pIHx8ICh0aGlzLmdldE1hcCh0ZXN0Lm1pbnVzKGRpcmVjdGlvbikpICE9PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTikgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZ2V0TWFwKHRlc3QucGx1cyhvcnRob2dvbmFsKSkgIT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOKSB8fCAodGhpcy5nZXRNYXAodGVzdC5taW51cyhvcnRob2dvbmFsKSkgIT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOKSB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5nZXRNYXAodGVzdC5wbHVzKGRpcmVjdGlvbikucGx1cyhvcnRob2dvbmFsKSkgIT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOKSB8fCAodGhpcy5nZXRNYXAodGVzdC5taW51cyhkaXJlY3Rpb24pLnBsdXMob3J0aG9nb25hbCkpICE9PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTikgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZ2V0TWFwKHRlc3QucGx1cyhkaXJlY3Rpb24pLm1pbnVzKG9ydGhvZ29uYWwpKSAhPT0gVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU4pIHx8ICh0aGlzLmdldE1hcCh0ZXN0Lm1pbnVzKGRpcmVjdGlvbikubWludXMob3J0aG9nb25hbCkpICE9PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9UVU5ORUxfT1BFTikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWFwKHRlc3QsIFR1bm5lbGVyQ2VsbFR5cGUuQ0xPU0VEKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVdhbGxDcmF3bGVyKHRlc3QsIGRpcmVjdGlvbiwgMCwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLm1heEFnZSwgdGhpcy5hY3RpdmVHZW5lcmF0aW9uICsgMSwgZGlyZWN0aW9uLCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyU3RhdHMuc3RlcExlbmd0aCwgMSwgMSwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLnN0cmFpZ2h0U2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLnN0cmFpZ2h0RG91YmxlU3Bhd25Qcm9iYWJpbGl0eSwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLnR1cm5TaW5nbGVTcGF3blByb2JhYmlsaXR5LCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyU3RhdHMudHVybkRvdWJsZVNwYXduUHJvYmFiaWxpdHksIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5jaGFuZ2VEaXJlY3Rpb25Qcm9iYWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVXYWxsQ3Jhd2xlcih0ZXN0LCBvcnRob2dvbmFsLCAwLCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyU3RhdHMubWF4QWdlLCB0aGlzLmFjdGl2ZUdlbmVyYXRpb24gKyAxLCBkaXJlY3Rpb24sIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5zdGVwTGVuZ3RoLCAxLCAxLCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyU3RhdHMuc3RyYWlnaHRTaW5nbGVTcGF3blByb2JhYmlsaXR5LCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyU3RhdHMuc3RyYWlnaHREb3VibGVTcGF3blByb2JhYmlsaXR5LCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyU3RhdHMudHVyblNpbmdsZVNwYXduUHJvYmFiaWxpdHksIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy50dXJuRG91YmxlU3Bhd25Qcm9iYWJpbGl0eSwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLmNoYW5nZURpcmVjdGlvblByb2JhYmlsaXR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVdhbGxDcmF3bGVyKHRlc3QsIG9ydGhvZ29uYWwubmVnYXRpdmUsIDAsIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5tYXhBZ2UsIHRoaXMuYWN0aXZlR2VuZXJhdGlvbiArIDEsIGRpcmVjdGlvbiwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLnN0ZXBMZW5ndGgsIDEsIDEsIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5zdHJhaWdodFNpbmdsZVNwYXduUHJvYmFiaWxpdHksIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy50dXJuU2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5LCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyU3RhdHMuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpO1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5ybmcuaW50ICUgMTAwKSA8IHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJDbG9zZWRQcm9iYWJpbGl0eSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVXYWxsQ3Jhd2xlcih0ZXN0LCBkaXJlY3Rpb24ubmVnYXRpdmUsIDAsIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5tYXhBZ2UsIHRoaXMuYWN0aXZlR2VuZXJhdGlvbiArIDEsIGRpcmVjdGlvbiwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLnN0ZXBMZW5ndGgsIDAsIDEsIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5zdHJhaWdodFNpbmdsZVNwYXduUHJvYmFiaWxpdHksIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy50dXJuU2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5LCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyU3RhdHMuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVXYWxsQ3Jhd2xlcih0ZXN0LCBkaXJlY3Rpb24ubmVnYXRpdmUsIDAsIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5tYXhBZ2UsIHRoaXMuYWN0aXZlR2VuZXJhdGlvbiArIDEsIGRpcmVjdGlvbiwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLnN0ZXBMZW5ndGgsIDEsIDEsIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5zdHJhaWdodFNpbmdsZVNwYXduUHJvYmFiaWxpdHksIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy5zdHJhaWdodERvdWJsZVNwYXduUHJvYmFiaWxpdHksIHRoaXMuY29uZmlnLnR1bm5lbENyYXdsZXJTdGF0cy50dXJuU2luZ2xlU3Bhd25Qcm9iYWJpbGl0eSwgdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlclN0YXRzLnR1cm5Eb3VibGVTcGF3blByb2JhYmlsaXR5LCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyU3RhdHMuY2hhbmdlRGlyZWN0aW9uUHJvYmFiaWxpdHkpO1xuICAgICAgICAgICAgICAgIG5vdEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbnVtYmVyRm91bmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYWtlSXRlcmF0aW9uKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY3Jhd2xlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSB0aGlzLmNyYXdsZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNyYXdsZXJzW2ldLnN0ZXBBaGVhZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Jhd2xlcnNbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFkdmFuY2VHZW5lcmF0aW9uKCkge1xuICAgICAgICBsZXQgaXNDcmF3bGVyRXhpc3RzID0gZmFsc2U7XG4gICAgICAgIGxldCBoaWdoZXN0TmVnYXRpdmVBZ2UgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY3Jhd2xlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSB0aGlzLmNyYXdsZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgaXNDcmF3bGVyRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jcmF3bGVyc1tpXS5nZW5lcmF0aW9uID09PSB0aGlzLmFjdGl2ZUdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGEgPSB0aGlzLmNyYXdsZXJzW2ldLmFnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoaGlnaGVzdE5lZ2F0aXZlQWdlID09PSAwKSB8fCAoYSA+IGhpZ2hlc3ROZWdhdGl2ZUFnZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0TmVnYXRpdmVBZ2UgPSBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlnaGVzdE5lZ2F0aXZlQWdlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUdlbmVyYXRpb24rKztcbiAgICAgICAgICAgIHJldHVybiBpc0NyYXdsZXJFeGlzdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChoaWdoZXN0TmVnYXRpdmVBZ2UgPCAwKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jcmF3bGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSB0aGlzLmNyYXdsZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNyYXdsZXJzW2ldLmdlbmVyYXRpb24gPT09IHRoaXMuYWN0aXZlR2VuZXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3Jhd2xlcnNbaV0uYWdlIC09IGhpZ2hlc3ROZWdhdGl2ZUFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNDcmF3bGVyRXhpc3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVJvb20ocmVjdCkge1xuICAgICAgICBpZiAoKHRoaXMuY29uZmlnLndpZHRoIDwgMTApIHx8ICh0aGlzLmNvbmZpZy5oZWlnaHQgPCAxMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgocmVjdC5lbmRYIC0gcmVjdC5zdGFydFgpIDw9IDUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgocmVjdC5lbmRZIC0gcmVjdC5zdGFydFkpIDw9IDUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydFggPSByZWN0LnN0YXJ0WCArIDEgKyB0aGlzLnJuZy5pbnQgJSAocmVjdC5lbmRYIC0gcmVjdC5zdGFydFggLSAzKTtcbiAgICAgICAgbGV0IHN0YXJ0WSA9IHJlY3Quc3RhcnRZICsgMSArIHRoaXMucm5nLmludCAlIChyZWN0LmVuZFkgLSByZWN0LnN0YXJ0WSAtIDMpO1xuICAgICAgICBsZXQgc3RhcnQgPSBuZXcgUG9pbnQoc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKHN0YXJ0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNDaGVja2VkKHN0YXJ0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG1heFJTID0gdGhpcy5jb25maWcubWF4Um9vbVNpemU7XG4gICAgICAgIGlmICghdGhpcy5pc01vcmVSb29tc0xhYnlyaW50aChSb29tU2l6ZS5MQVJHRSkpXG4gICAgICAgICAgICBtYXhSUyA9IHRoaXMuY29uZmlnLmxhcmdlUm9vbVNpemU7XG4gICAgICAgIGlmICghdGhpcy5pc01vcmVSb29tc0xhYnlyaW50aChSb29tU2l6ZS5MQVJHRSkgJiYgIXRoaXMuaXNNb3JlUm9vbXNMYWJ5cmludGgoUm9vbVNpemUuTUVESVVNKSlcbiAgICAgICAgICAgIG1heFJTID0gdGhpcy5jb25maWcubWVkaXVtUm9vbVNpemU7XG4gICAgICAgIGlmICghdGhpcy5pc01vcmVSb29tc0xhYnlyaW50aCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RpbGxGaW5kaW5nTXVsdGlwbGVzID0gdHJ1ZTtcbiAgICAgICAgbGV0IFJvb21TcXVhcmVzQ2hlY2tlZCA9IFtdO1xuICAgICAgICBsZXQgUm9vbVNxdWFyZXNBY3RpdmUgPSBbXTtcbiAgICAgICAgbGV0IEFjdGl2ZUZvdW5kVGhpc1R1cm4gPSBbXTtcbiAgICAgICAgUm9vbVNxdWFyZXNBY3RpdmUucHVzaChzdGFydCk7XG4gICAgICAgIGxldCBudW1iZXJGb3VuZDtcbiAgICAgICAgd2hpbGUgKHN0aWxsRmluZGluZ011bHRpcGxlcykge1xuICAgICAgICAgICAgc3RpbGxGaW5kaW5nTXVsdGlwbGVzID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBhY3RJdCA9IDA7IGFjdEl0IDwgUm9vbVNxdWFyZXNBY3RpdmUubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIGxldCBDdXJyID0gUm9vbVNxdWFyZXNBY3RpdmVbYWN0SXRdO1xuICAgICAgICAgICAgICAgIG51bWJlckZvdW5kID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50Lk5PUlRIKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIKSwgUm9vbVNxdWFyZXNDaGVja2VkKSAmJlxuICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuTk9SVEgpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm91bmQrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50LlNPVVRIKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoQ3Vyci5wbHVzKFBvaW50LlNPVVRIKSwgUm9vbVNxdWFyZXNDaGVja2VkKSAmJlxuICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LlNPVVRIKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuU09VVEgpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm91bmQrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50LkVBU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuRUFTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5FQVNUKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuRUFTVCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKVxuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3VuZCsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihDdXJyLnBsdXMoUG9pbnQuV0VTVCkpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KEN1cnIucGx1cyhQb2ludC5XRVNUKSwgUm9vbVNxdWFyZXNDaGVja2VkKSAmJlxuICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LldFU1QpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5XRVNUKSwgQWN0aXZlRm91bmRUaGlzVHVybikpXG4gICAgICAgICAgICAgICAgICAgIG51bWJlckZvdW5kKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKEN1cnIucGx1cyhQb2ludC5OT1JUSF9FQVNUKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuTk9SVEhfRUFTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm91bmQrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX1dFU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuTk9SVEhfV0VTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5OT1JUSF9XRVNUKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuTk9SVEhfV0VTVCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKVxuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3VuZCsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihDdXJyLnBsdXMoUG9pbnQuU09VVEhfRUFTVCkpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KEN1cnIucGx1cyhQb2ludC5TT1VUSF9FQVNUKSwgUm9vbVNxdWFyZXNDaGVja2VkKSAmJlxuICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5TT1VUSF9FQVNUKSwgQWN0aXZlRm91bmRUaGlzVHVybikpXG4gICAgICAgICAgICAgICAgICAgIG51bWJlckZvdW5kKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKEN1cnIucGx1cyhQb2ludC5TT1VUSF9XRVNUKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoQ3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuU09VVEhfV0VTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm91bmQrKztcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyRm91bmQgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0aWxsRmluZGluZ011bHRpcGxlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihDdXJyLnBsdXMoUG9pbnQuTk9SVEgpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuTk9SVEgpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuTk9SVEgpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChDdXJyLnBsdXMoUG9pbnQuTk9SVEgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKEN1cnIucGx1cyhQb2ludC5TT1VUSCkpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KEN1cnIucGx1cyhQb2ludC5TT1VUSCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuU09VVEgpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5TT1VUSCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgQWN0aXZlRm91bmRUaGlzVHVybi5wdXNoKEN1cnIucGx1cyhQb2ludC5TT1VUSCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50LkVBU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuRUFTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuRUFTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LkVBU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChDdXJyLnBsdXMoUG9pbnQuRUFTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50LldFU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuV0VTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuV0VTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LldFU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChDdXJyLnBsdXMoUG9pbnQuV0VTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuTk9SVEhfRUFTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuTk9SVEhfRUFTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChDdXJyLnBsdXMoUG9pbnQuTk9SVEhfRUFTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX1dFU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuTk9SVEhfV0VTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuTk9SVEhfV0VTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX1dFU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChDdXJyLnBsdXMoUG9pbnQuTk9SVEhfV0VTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuU09VVEhfRUFTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuU09VVEhfRUFTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChDdXJyLnBsdXMoUG9pbnQuU09VVEhfRUFTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuU09VVEhfV0VTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuU09VVEhfV0VTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChDdXJyLnBsdXMoUG9pbnQuU09VVEhfV0VTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoQ3VyciwgUm9vbVNxdWFyZXNDaGVja2VkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm9vbVNxdWFyZXNDaGVja2VkLnB1c2goQ3Vycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENoZWNrZWQoQ3Vycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgUm9vbVNxdWFyZXNBY3RpdmUuc3BsaWNlKGFjdEl0LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0SXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobnVtYmVyRm91bmQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKEN1cnIucGx1cyhQb2ludC5OT1JUSCkpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KEN1cnIucGx1cyhQb2ludC5OT1JUSCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuTk9SVEgpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5OT1JUSCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBY3RpdmVGb3VuZFRoaXNUdXJuLnB1c2goQ3Vyci5wbHVzKFBvaW50Lk5PUlRIKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihDdXJyLnBsdXMoUG9pbnQuU09VVEgpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuU09VVEgpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LlNPVVRIKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuU09VVEgpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQWN0aXZlRm91bmRUaGlzVHVybi5wdXNoKEN1cnIucGx1cyhQb2ludC5TT1VUSCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oQ3Vyci5wbHVzKFBvaW50LkVBU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLnBsdXMoUG9pbnQuRUFTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuRUFTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LkVBU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQWN0aXZlRm91bmRUaGlzVHVybi5wdXNoKEN1cnIucGx1cyhQb2ludC5FQVNUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihDdXJyLnBsdXMoUG9pbnQuV0VTVCkpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KEN1cnIucGx1cyhQb2ludC5XRVNUKSwgUm9vbVNxdWFyZXNDaGVja2VkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5XRVNUKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLnBsdXMoUG9pbnQuV0VTVCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBY3RpdmVGb3VuZFRoaXNUdXJuLnB1c2goQ3Vyci5wbHVzKFBvaW50LldFU1QpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RJdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKEN1cnIucGx1cyhQb2ludC5OT1JUSF9FQVNUKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5OT1JUSF9FQVNUKSwgQWN0aXZlRm91bmRUaGlzVHVybikpXG4gICAgICAgICAgICAgICAgICAgICAgICBBY3RpdmVGb3VuZFRoaXNUdXJuLnB1c2goQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKEN1cnIucGx1cyhQb2ludC5OT1JUSF9XRVNUKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX1dFU1QpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX1dFU1QpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5OT1JUSF9XRVNUKSwgQWN0aXZlRm91bmRUaGlzVHVybikpXG4gICAgICAgICAgICAgICAgICAgICAgICBBY3RpdmVGb3VuZFRoaXNUdXJuLnB1c2goQ3Vyci5wbHVzKFBvaW50Lk5PUlRIX1dFU1QpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKEN1cnIucGx1cyhQb2ludC5TT1VUSF9FQVNUKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoQ3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5TT1VUSF9FQVNUKSwgQWN0aXZlRm91bmRUaGlzVHVybikpXG4gICAgICAgICAgICAgICAgICAgICAgICBBY3RpdmVGb3VuZFRoaXNUdXJuLnB1c2goQ3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKEN1cnIucGx1cyhQb2ludC5TT1VUSF9XRVNUKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoQ3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoQ3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKEN1cnIucGx1cyhQb2ludC5TT1VUSF9XRVNUKSwgQWN0aXZlRm91bmRUaGlzVHVybikpXG4gICAgICAgICAgICAgICAgICAgICAgICBBY3RpdmVGb3VuZFRoaXNUdXJuLnB1c2goQ3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KEN1cnIsIFJvb21TcXVhcmVzQ2hlY2tlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvb21TcXVhcmVzQ2hlY2tlZC5wdXNoKEN1cnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDaGVja2VkKEN1cnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFJvb21TcXVhcmVzQWN0aXZlLnNwbGljZShhY3RJdCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdEl0Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG51bWJlckZvdW5kID09XG4gICAgICAgICAgICAgICAgICAgIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0SXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG51bWJlckZvdW5kID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KEN1cnIsIFJvb21TcXVhcmVzQ2hlY2tlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvb21TcXVhcmVzQ2hlY2tlZC5wdXNoKEN1cnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDaGVja2VkKEN1cnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFJvb21TcXVhcmVzQWN0aXZlLnNwbGljZShhY3RJdCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdEl0Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChSb29tU3F1YXJlc0NoZWNrZWQubGVuZ3RoID4gbWF4UlMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IEN1cnIgb2YgQWN0aXZlRm91bmRUaGlzVHVybikge1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5nZXRNYXAoQ3VycikgPT09IFR1bm5lbGVyQ2VsbFR5cGUuR1VBUkFOVEVFRF9PUEVOKSB8fCAodGhpcy5nZXRNYXAoQ3VycikgPT09IFR1bm5lbGVyQ2VsbFR5cGUuTk9OX0pPSU5fR1VBUkFOVEVFRF9PUEVOKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChDdXJyLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShDdXJyLCBSb29tU3F1YXJlc0FjdGl2ZSkpXG4gICAgICAgICAgICAgICAgICAgIFJvb21TcXVhcmVzQWN0aXZlLnB1c2goQ3Vycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBY3RpdmVGb3VuZFRoaXNUdXJuLnNwbGljZSgwLCBBY3RpdmVGb3VuZFRoaXNUdXJuLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb2NlZWRpbmcgPSB0cnVlO1xuICAgICAgICBsZXQgc3F1YXJlc0ZpbmRpbmdNdWx0aXBsZXMgPSAwO1xuICAgICAgICBsZXQgY3VyciA9IFBvaW50LlpFUk87XG4gICAgICAgIHdoaWxlIChwcm9jZWVkaW5nKSB7XG4gICAgICAgICAgICBzcXVhcmVzRmluZGluZ011bHRpcGxlcyA9IDA7XG4gICAgICAgICAgICBwcm9jZWVkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBhY3RJdCA9IDA7IGFjdEl0IDwgUm9vbVNxdWFyZXNBY3RpdmUubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIGN1cnIgPSBSb29tU3F1YXJlc0FjdGl2ZVthY3RJdF07XG4gICAgICAgICAgICAgICAgbnVtYmVyRm91bmQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihjdXJyLnBsdXMoUG9pbnQuTk9SVEgpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuTk9SVEgpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuTk9SVEgpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKGN1cnIucGx1cyhQb2ludC5OT1JUSCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKVxuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3VuZCsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihjdXJyLnBsdXMoUG9pbnQuU09VVEgpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuU09VVEgpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuU09VVEgpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKGN1cnIucGx1cyhQb2ludC5TT1VUSCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKVxuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3VuZCsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihjdXJyLnBsdXMoUG9pbnQuRUFTVCkpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KGN1cnIucGx1cyhQb2ludC5FQVNUKSwgUm9vbVNxdWFyZXNDaGVja2VkKSAmJlxuICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50LkVBU1QpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKGN1cnIucGx1cyhQb2ludC5FQVNUKSwgQWN0aXZlRm91bmRUaGlzVHVybikpXG4gICAgICAgICAgICAgICAgICAgIG51bWJlckZvdW5kKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKGN1cnIucGx1cyhQb2ludC5XRVNUKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoY3Vyci5wbHVzKFBvaW50LldFU1QpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuV0VTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50LldFU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm91bmQrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuTk9SVEhfRUFTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKGN1cnIucGx1cyhQb2ludC5OT1JUSF9FQVNUKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuTk9SVEhfRUFTVCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKVxuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3VuZCsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihjdXJyLnBsdXMoUG9pbnQuTk9SVEhfV0VTVCkpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KGN1cnIucGx1cyhQb2ludC5OT1JUSF9XRVNUKSwgUm9vbVNxdWFyZXNDaGVja2VkKSAmJlxuICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50Lk5PUlRIX1dFU1QpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKGN1cnIucGx1cyhQb2ludC5OT1JUSF9XRVNUKSwgQWN0aXZlRm91bmRUaGlzVHVybikpXG4gICAgICAgICAgICAgICAgICAgIG51bWJlckZvdW5kKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKGN1cnIucGx1cyhQb2ludC5TT1VUSF9FQVNUKSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoY3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuU09VVEhfRUFTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyRm91bmQrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuU09VVEhfV0VTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKGN1cnIucGx1cyhQb2ludC5TT1VUSF9XRVNUKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuU09VVEhfV0VTVCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKVxuICAgICAgICAgICAgICAgICAgICBudW1iZXJGb3VuZCsrO1xuICAgICAgICAgICAgICAgIGlmIChudW1iZXJGb3VuZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlc0ZpbmRpbmdNdWx0aXBsZXMrKztcbiAgICAgICAgICAgICAgICAgICAgYWN0SXQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobnVtYmVyRm91bmQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VlZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbihjdXJyLnBsdXMoUG9pbnQuTk9SVEgpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuTk9SVEgpLCBSb29tU3F1YXJlc0NoZWNrZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50Lk5PUlRIKSwgUm9vbVNxdWFyZXNBY3RpdmUpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuTk9SVEgpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChjdXJyLnBsdXMoUG9pbnQuTk9SVEgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKGN1cnIucGx1cyhQb2ludC5TT1VUSCkpICYmICFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KGN1cnIucGx1cyhQb2ludC5TT1VUSCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuU09VVEgpLCBSb29tU3F1YXJlc0FjdGl2ZSkgJiYgIUR1bmdlb25DcmF3bGVyLmlzQWN0aXZlKGN1cnIucGx1cyhQb2ludC5TT1VUSCksIEFjdGl2ZUZvdW5kVGhpc1R1cm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgQWN0aXZlRm91bmRUaGlzVHVybi5wdXNoKGN1cnIucGx1cyhQb2ludC5TT1VUSCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50LkVBU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuRUFTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuRUFTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50LkVBU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChjdXJyLnBsdXMoUG9pbnQuRUFTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50LldFU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuV0VTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuV0VTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50LldFU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChjdXJyLnBsdXMoUG9pbnQuV0VTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuTk9SVEhfRUFTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuTk9SVEhfRUFTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50Lk5PUlRIX0VBU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChjdXJyLnBsdXMoUG9pbnQuTk9SVEhfRUFTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50Lk5PUlRIX1dFU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuTk9SVEhfV0VTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuTk9SVEhfV0VTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50Lk5PUlRIX1dFU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChjdXJyLnBsdXMoUG9pbnQuTk9SVEhfV0VTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuU09VVEhfRUFTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuU09VVEhfRUFTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50LlNPVVRIX0VBU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChjdXJyLnBsdXMoUG9pbnQuU09VVEhfRUFTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNDaGVja2VkTGlzdChjdXJyLnBsdXMoUG9pbnQuU09VVEhfV0VTVCksIFJvb21TcXVhcmVzQ2hlY2tlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEdW5nZW9uQ3Jhd2xlci5pc0FjdGl2ZShjdXJyLnBsdXMoUG9pbnQuU09VVEhfV0VTVCksIFJvb21TcXVhcmVzQWN0aXZlKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3Vyci5wbHVzKFBvaW50LlNPVVRIX1dFU1QpLCBBY3RpdmVGb3VuZFRoaXNUdXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2ZUZvdW5kVGhpc1R1cm4ucHVzaChjdXJyLnBsdXMoUG9pbnQuU09VVEhfV0VTVCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoY3VyciwgUm9vbVNxdWFyZXNDaGVja2VkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm9vbVNxdWFyZXNDaGVja2VkLnB1c2goY3Vycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENoZWNrZWQoY3Vycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgUm9vbVNxdWFyZXNBY3RpdmUuc3BsaWNlKGFjdEl0LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG51bWJlckZvdW5kID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFEdW5nZW9uQ3Jhd2xlci5pc0NoZWNrZWRMaXN0KGN1cnIsIFJvb21TcXVhcmVzQ2hlY2tlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvb21TcXVhcmVzQ2hlY2tlZC5wdXNoKGN1cnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDaGVja2VkKGN1cnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFJvb21TcXVhcmVzQWN0aXZlLnNwbGljZShhY3RJdCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjdXJyIG9mIEFjdGl2ZUZvdW5kVGhpc1R1cm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZ2V0TWFwKGN1cnIpID09PSBUdW5uZWxlckNlbGxUeXBlLkdVQVJBTlRFRURfT1BFTikgfHwgKHRoaXMuZ2V0TWFwKGN1cnIpID09PSBUdW5uZWxlckNlbGxUeXBlLk5PTl9KT0lOX0dVQVJBTlRFRURfT1BFTikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIUR1bmdlb25DcmF3bGVyLmlzQ2hlY2tlZExpc3QoY3VyciwgUm9vbVNxdWFyZXNDaGVja2VkKSAmJiAhRHVuZ2VvbkNyYXdsZXIuaXNBY3RpdmUoY3VyciwgUm9vbVNxdWFyZXNBY3RpdmUpKVxuICAgICAgICAgICAgICAgICAgICBSb29tU3F1YXJlc0FjdGl2ZS5wdXNoKGN1cnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQWN0aXZlRm91bmRUaGlzVHVybi5zcGxpY2UoMCwgQWN0aXZlRm91bmRUaGlzVHVybi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcXVhcmVzRmluZGluZ011bHRpcGxlcyA+IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKHNxdWFyZXNGaW5kaW5nTXVsdGlwbGVzID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChSb29tU3F1YXJlc0NoZWNrZWQubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZJTExJTkcgQ0xPU0VEIFJPT01cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gUm9vbVNxdWFyZXNDaGVja2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoKHRoaXMuZ2V0TWFwKFJvb21TcXVhcmVzQ2hlY2tlZFtpXSkgPT09IFR1bm5lbGVyQ2VsbFR5cGUuT1BFTikgfHwgKHRoaXMuZ2V0TWFwKFJvb21TcXVhcmVzQ2hlY2tlZFtpXSkgPT09IFR1bm5lbGVyQ2VsbFR5cGUuTk9OX0pPSU5fT1BFTikgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZ2V0TWFwKFJvb21TcXVhcmVzQ2hlY2tlZFtpXSkgPT09IFR1bm5lbGVyQ2VsbFR5cGUuSU5TSURFX1RVTk5FTF9PUEVOKSB8fCAodGhpcy5nZXRNYXAoUm9vbVNxdWFyZXNDaGVja2VkW2ldKSA9PT0gVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfQU5URVJPT01fT1BFTikpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWFwKFJvb21TcXVhcmVzQ2hlY2tlZFtpXSwgVHVubmVsZXJDZWxsVHlwZS5DTE9TRUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoc3F1YXJlc0ZpbmRpbmdNdWx0aXBsZXMgPT09IDEpO1xuICAgICAgICAgICAgaWYgKFJvb21TcXVhcmVzQ2hlY2tlZC5sZW5ndGggPCB0aGlzLmNvbmZpZy5taW5Sb29tU2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZGlmZlggPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkaWZmWSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgIT09IFJvb21TcXVhcmVzQ2hlY2tlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChSb29tU3F1YXJlc0NoZWNrZWRbaV0ueCAhPT0gUm9vbVNxdWFyZXNDaGVja2VkWzBdLngpXG4gICAgICAgICAgICAgICAgICAgIGRpZmZYID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoUm9vbVNxdWFyZXNDaGVja2VkW2ldLnkgIT09IFJvb21TcXVhcmVzQ2hlY2tlZFswXS55KVxuICAgICAgICAgICAgICAgICAgICBkaWZmWSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpZmZYIHx8ICFkaWZmWSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRNYXAoY3Vyci5wbHVzKFBvaW50LldFU1QpKSA9PT0gVHVubmVsZXJDZWxsVHlwZS5WX0RPT1IgfHwgdGhpcy5nZXRNYXAoY3Vyci5wbHVzKFBvaW50LkVBU1QpKSA9PT0gVHVubmVsZXJDZWxsVHlwZS5WX0RPT1IgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdldE1hcChjdXJyLnBsdXMoUG9pbnQuV0VTVCkpID09PSBUdW5uZWxlckNlbGxUeXBlLkhfRE9PUiB8fCB0aGlzLmdldE1hcChjdXJyLnBsdXMoUG9pbnQuRUFTVCkpID09PSBUdW5uZWxlckNlbGxUeXBlLkhfRE9PUiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TWFwKGN1cnIucGx1cyhQb2ludC5OT1JUSCkpID09PSBUdW5uZWxlckNlbGxUeXBlLlZfRE9PUiB8fCB0aGlzLmdldE1hcChjdXJyLnBsdXMoUG9pbnQuU09VVEgpKSA9PT0gVHVubmVsZXJDZWxsVHlwZS5WX0RPT1IgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdldE1hcChjdXJyLnBsdXMoUG9pbnQuTk9SVEgpKSA9PT0gVHVubmVsZXJDZWxsVHlwZS5IX0RPT1IgfHwgdGhpcy5nZXRNYXAoY3Vyci5wbHVzKFBvaW50LlNPVVRIKSkgPT09IFR1bm5lbGVyQ2VsbFR5cGUuSF9ET09SKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChSb29tU3F1YXJlc0NoZWNrZWQubGVuZ3RoIDwgdGhpcy5jb25maWcubWVkaXVtUm9vbVNpemUpXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTW9yZVJvb21zTGFieXJpbnRoKFJvb21TaXplLlNNQUxMKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyU21hbGxSb29tc0xhYnlyaW50aCsrO1xuICAgICAgICAgICAgZWxzZSBpZiAoUm9vbVNxdWFyZXNDaGVja2VkLmxlbmd0aCA8IHRoaXMuY29uZmlnLmxhcmdlUm9vbVNpemUpXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTW9yZVJvb21zTGFieXJpbnRoKFJvb21TaXplLk1FRElVTSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyck1lZGl1bVJvb21zTGFieXJpbnRoKys7XG4gICAgICAgICAgICBlbHNlIGlmIChSb29tU3F1YXJlc0NoZWNrZWQubGVuZ3RoIDwgdGhpcy5jb25maWcubWF4Um9vbVNpemUpXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTW9yZVJvb21zTGFieXJpbnRoKFJvb21TaXplLkxBUkdFKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyTGFyZ2VSb29tc0xhYnlyaW50aCsrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KFJvb21TcXVhcmVzQWN0aXZlLmxlbmd0aCA9PT0gMSk7XG4gICAgICAgICAgICBjdXJyID0gUm9vbVNxdWFyZXNBY3RpdmVbMF07XG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50Lk5PUlRIKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzLmlzT3BlbihjdXJyLnBsdXMoUG9pbnQuU09VVEgpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNYXAoY3VyciwgVHVubmVsZXJDZWxsVHlwZS5IX0RPT1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc09wZW4oY3Vyci5wbHVzKFBvaW50LldFU1QpKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMuaXNPcGVuKGN1cnIucGx1cyhQb2ludC5FQVNUKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWFwKGN1cnIsIFR1bm5lbGVyQ2VsbFR5cGUuVl9ET09SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdSb29tID0gbmV3IFJvb20oKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBSb29tU3F1YXJlc0NoZWNrZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydCgodGhpcy5nZXRNYXAoUm9vbVNxdWFyZXNDaGVja2VkW2ldKSA9PT0gVHVubmVsZXJDZWxsVHlwZS5PUEVOKSB8fCAodGhpcy5nZXRNYXAoUm9vbVNxdWFyZXNDaGVja2VkW2ldKSA9PT0gVHVubmVsZXJDZWxsVHlwZS5OT05fSk9JTl9PUEVOKSB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5nZXRNYXAoUm9vbVNxdWFyZXNDaGVja2VkW2ldKSA9PT0gVHVubmVsZXJDZWxsVHlwZS5JTlNJREVfVFVOTkVMX09QRU4pIHx8ICh0aGlzLmdldE1hcChSb29tU3F1YXJlc0NoZWNrZWRbaV0pID09PSBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9BTlRFUk9PTV9PUEVOKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNYXAoUm9vbVNxdWFyZXNDaGVja2VkW2ldLCBUdW5uZWxlckNlbGxUeXBlLklOU0lERV9ST09NX09QRU4pO1xuICAgICAgICAgICAgICAgIG5ld1Jvb20uaW5zaWRlLnB1c2goUm9vbVNxdWFyZXNDaGVja2VkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1Jvb20uaW5EdW5nZW9uID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJvb21zLnB1c2gobmV3Um9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdlbmVyYXRlKCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlR2VuZXJhdGlvbiA9PT0gdGhpcy5jb25maWcudHVubmVsQ3Jhd2xlckdlbmVyYXRpb24pXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTZWVkQ3Jhd2xlcnNJblR1bm5lbHMoKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLm1ha2VJdGVyYXRpb24oKSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFkdmFuY2VHZW5lcmF0aW9uKCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyR2VuZXJhdGlvbiA8IDApIHx8ICh0aGlzLmFjdGl2ZUdlbmVyYXRpb24gPCB0aGlzLmNvbmZpZy50dW5uZWxDcmF3bGVyR2VuZXJhdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2VlZENyYXdsZXJzSW5UdW5uZWxzKCk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm1ha2VJdGVyYXRpb24oKSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWR2YW5jZUdlbmVyYXRpb24oKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICBsZXQgbnVtYmVyID0gMDtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJhY2tncm91bmQgPT09IFR1bm5lbGVyQ2VsbFR5cGUuT1BFTikge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBuZXcgRmlsbFJlY3QoMCwgMCwgdGhpcy5jb25maWcud2lkdGgsIHRoaXMuY29uZmlnLmhlaWdodCwgdGhpcy5jb25maWcuYmFja2dyb3VuZCk7XG4gICAgICAgICAgICBjb3VudGVyID0gMDtcbiAgICAgICAgICAgIG51bWJlciA9IHRoaXMuY29uZmlnLndpZHRoICogdGhpcy5jb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNNb3JlUm9vbXNMYWJ5cmludGgoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNyZWF0ZVJvb20ocmVjdCkpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBudW1iZXIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHJlY3Qgb2YgdGhpcy5jb25maWcuZGVzaWduKSB7XG4gICAgICAgICAgICBpZiAocmVjdC50eXBlICE9PSBUdW5uZWxlckNlbGxUeXBlLk9QRU4pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb3VudGVyID0gMDtcbiAgICAgICAgICAgIG51bWJlciA9IChyZWN0LmVuZFggLSByZWN0LnN0YXJ0WCkgKiAocmVjdC5lbmRZIC0gcmVjdC5zdGFydFkpO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNNb3JlUm9vbXNMYWJ5cmludGgoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNyZWF0ZVJvb20ocmVjdCkpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBudW1iZXIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkge1xuICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkge1xuICAgICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgYnVmZmVyLCBNb2RlbCwgUmVzb2x1dGlvbiB9IGZyb20gXCIuL21vZGVsXCI7XG5pbXBvcnQgeyBSTkcgfSBmcm9tIFwiLi4vcm5nXCI7XG5pbXBvcnQgeyBUdW5uZWxpbmdBbGdvcml0aG0gfSBmcm9tIFwiLi4vdHVubmVsaW5nXCI7XG5pbXBvcnQgeyBJbmRleGVyIH0gZnJvbSBcIi4uL2luZGV4ZXJcIjtcbmltcG9ydCB7IER1bmdlb25DcmF3bGVyIH0gZnJvbSBcIi4uL3R1bm5lbGVyL2R1bmdlb24uY3Jhd2xlclwiO1xuaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiO1xuZXhwb3J0IHZhciBEaXJlY3Rpb247XG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJSSUdIVFwiXSA9IDJdID0gXCJSSUdIVFwiO1xuICAgIERpcmVjdGlvbltEaXJlY3Rpb25bXCJET1dOXCJdID0gMV0gPSBcIkRPV05cIjtcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbmV4cG9ydCB2YXIgQ2VsbFR5cGU7XG4oZnVuY3Rpb24gKENlbGxUeXBlKSB7XG4gICAgQ2VsbFR5cGVbQ2VsbFR5cGVbXCJFTVBUWVwiXSA9IDBdID0gXCJFTVBUWVwiO1xuICAgIENlbGxUeXBlW0NlbGxUeXBlW1wiRkxPT1JcIl0gPSAxXSA9IFwiRkxPT1JcIjtcbiAgICBDZWxsVHlwZVtDZWxsVHlwZVtcIkZMT09SX1dBTExfVE9QXCJdID0gMl0gPSBcIkZMT09SX1dBTExfVE9QXCI7XG4gICAgQ2VsbFR5cGVbQ2VsbFR5cGVbXCJXQUxMX01JRFwiXSA9IDNdID0gXCJXQUxMX01JRFwiO1xuICAgIENlbGxUeXBlW0NlbGxUeXBlW1wiV0FMTF9UT1BcIl0gPSA0XSA9IFwiV0FMTF9UT1BcIjtcbiAgICBDZWxsVHlwZVtDZWxsVHlwZVtcIldBTExfU0lERVwiXSA9IDVdID0gXCJXQUxMX1NJREVcIjtcbn0pKENlbGxUeXBlIHx8IChDZWxsVHlwZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgVGlsZXNldFJ1bGVzQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGlsZXNJbmRleCA9IEluZGV4ZXIuaWRlbnRpdHkoKTtcbiAgICAgICAgdGhpcy5jZWxsc0luZGV4ID0gSW5kZXhlci5hcnJheSgpO1xuICAgICAgICB0aGlzLnJpZ2h0SW5kZXggPSBJbmRleGVyLmFycmF5KCk7XG4gICAgICAgIHRoaXMuZG93bkluZGV4ID0gSW5kZXhlci5hcnJheSgpO1xuICAgIH1cbiAgICBhZGRDZWxsKGZsb29yLCB3YWxsLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IGZsb29ySWQgPSBmbG9vciA/IHRoaXMudGlsZXNJbmRleC5pbmRleChmbG9vcikgOiAtMTtcbiAgICAgICAgY29uc3Qgd2FsbElkID0gd2FsbCA/IHRoaXMudGlsZXNJbmRleC5pbmRleCh3YWxsKSA6IC0xO1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsc0luZGV4LmluZGV4KFtmbG9vcklkLCB3YWxsSWQsIHR5cGVdKTtcbiAgICB9XG4gICAgYWRkUnVsZVJpZ2h0KGZpcnN0LCBuZXh0KSB7XG4gICAgICAgIHRoaXMucmlnaHRJbmRleC5pbmRleChbZmlyc3QsIG5leHRdKTtcbiAgICB9XG4gICAgYWRkUnVsZURvd24oZmlyc3QsIG5leHQpIHtcbiAgICAgICAgdGhpcy5kb3duSW5kZXguaW5kZXgoW2ZpcnN0LCBuZXh0XSk7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2l6ZTogMTYsXG4gICAgICAgICAgICB0aWxlczogdGhpcy50aWxlc0luZGV4LnZhbHVlcyxcbiAgICAgICAgICAgIGNlbGxzOiB0aGlzLmNlbGxzSW5kZXgudmFsdWVzLFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMucmlnaHRJbmRleC52YWx1ZXMsXG4gICAgICAgICAgICBkb3duOiB0aGlzLmRvd25JbmRleC52YWx1ZXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEV2ZW5TaW1wbGVUaWxlZE1vZGVsIGV4dGVuZHMgTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKHJlc291cmNlcywgdGlsZXNldCwgcm5nLCB3aWR0aCwgaGVpZ2h0LCBjb25zdHJhaW50cykge1xuICAgICAgICBzdXBlcihybmcsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmFwcCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuICAgICAgICB0aGlzLndlaWdodHMgPSBbXTtcbiAgICAgICAgdGhpcy50aWxlc2V0ID0gdGlsZXNldDtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgICAgICB0aGlzLlQgPSB0aWxlc2V0LmNlbGxzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLlQ7IGkrKykge1xuICAgICAgICAgICAgdGhpcy53ZWlnaHRzW2ldID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0bXBQcm9wYWdhdG9yID0gW107XG4gICAgICAgIGZvciAobGV0IGRpcmVjdGlvbiA9IDA7IGRpcmVjdGlvbiA8IDQ7IGRpcmVjdGlvbisrKSB7XG4gICAgICAgICAgICB0bXBQcm9wYWdhdG9yW2RpcmVjdGlvbl0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNlbGwxID0gMDsgY2VsbDEgPCB0aGlzLlQ7IGNlbGwxKyspIHtcbiAgICAgICAgICAgICAgICB0bXBQcm9wYWdhdG9yW2RpcmVjdGlvbl1bY2VsbDFdID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2VsbDIgPSAwOyBjZWxsMiA8IHRoaXMuVDsgY2VsbDIrKykge1xuICAgICAgICAgICAgICAgICAgICB0bXBQcm9wYWdhdG9yW2RpcmVjdGlvbl1bY2VsbDFdW2NlbGwyXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBbZmlyc3QsIG5leHRdIG9mIHRpbGVzZXQucmlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wcG9zaXRlID0gTW9kZWwub3Bwb3NpdGVbRGlyZWN0aW9uLlJJR0hUXTtcbiAgICAgICAgICAgIHRtcFByb3BhZ2F0b3JbRGlyZWN0aW9uLlJJR0hUXVtmaXJzdF1bbmV4dF0gPSB0cnVlO1xuICAgICAgICAgICAgdG1wUHJvcGFnYXRvcltvcHBvc2l0ZV1bbmV4dF1bZmlyc3RdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBbZmlyc3QsIG5leHRdIG9mIHRpbGVzZXQuZG93bikge1xuICAgICAgICAgICAgY29uc3Qgb3Bwb3NpdGUgPSBNb2RlbC5vcHBvc2l0ZVtEaXJlY3Rpb24uRE9XTl07XG4gICAgICAgICAgICB0bXBQcm9wYWdhdG9yW0RpcmVjdGlvbi5ET1dOXVtmaXJzdF1bbmV4dF0gPSB0cnVlO1xuICAgICAgICAgICAgdG1wUHJvcGFnYXRvcltvcHBvc2l0ZV1bbmV4dF1bZmlyc3RdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BhZ2F0b3IgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZGlyZWN0aW9uID0gMDsgZGlyZWN0aW9uIDwgNDsgZGlyZWN0aW9uKyspIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRvcltkaXJlY3Rpb25dID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjZWxsMSA9IDA7IGNlbGwxIDwgdGhpcy5UOyBjZWxsMSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdG9yW2RpcmVjdGlvbl1bY2VsbDFdID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2VsbDIgPSAwOyBjZWxsMiA8IHRoaXMuVDsgY2VsbDIrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG1wUHJvcGFnYXRvcltkaXJlY3Rpb25dW2NlbGwxXVtjZWxsMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRvcltkaXJlY3Rpb25dW2NlbGwxXS5wdXNoKGNlbGwyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkJvdW5kYXJ5KHgsIHkpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnBlcmlvZGljICYmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID49IHRoaXMuRk1YIHx8IHkgPj0gdGhpcy5GTVkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgc3VwZXIuY2xlYXIoKTtcbiAgICAgICAgZm9yIChsZXQgY29uc3RyYWludCBvZiB0aGlzLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50Lm9uQ2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmFja3RyYWNrQ29uc3RyYWludChpbmRleCwgcGF0dGVybikge1xuICAgICAgICBmb3IgKGxldCBjb25zdHJhaW50IG9mIHRoaXMuY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQub25CYWNrdHJhY2soaW5kZXgsIHBhdHRlcm4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJhbkNvbnN0cmFpbnQoaW5kZXgsIHBhdHRlcm4pIHtcbiAgICAgICAgZm9yIChsZXQgY29uc3RyYWludCBvZiB0aGlzLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50Lm9uQmFuKGluZGV4LCBwYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0Q29uc3RyYWludCgpIHtcbiAgICAgICAgZm9yIChsZXQgY29uc3RyYWludCBvZiB0aGlzLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50LmluaXQodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT0gUmVzb2x1dGlvbi5VbmRlY2lkZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiZmFpbGVkIGluaXQgY29uc3RyYWludFwiLCB0aGlzLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0ZXBDb25zdHJhaW50KCkge1xuICAgICAgICBmb3IgKGxldCBjb25zdHJhaW50IG9mIHRoaXMuY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQuY2hlY2soKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPSBSZXNvbHV0aW9uLlVuZGVjaWRlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJmYWlsZWQgc3RlcCBjb25zdHJhaW50IGNoZWNrXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT0gUmVzb2x1dGlvbi5VbmRlY2lkZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiZmFpbGVkIHN0ZXAgY29uc3RyYWludCBwcm9wYWdhdGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmZXJyZWRDb25zdHJhaW50c1N0ZXAgPSBmYWxzZTtcbiAgICB9XG4gICAgdGVzdE9ic2VydmVkKGkpIHtcbiAgICAgICAgbGV0IHggPSBpICUgdGhpcy5GTVgsIHkgPSBNYXRoLmZsb29yKGkgLyB0aGlzLkZNWCk7XG4gICAgICAgIGlmICghdGhpcy5vbkJvdW5kYXJ5KHgsIHkpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJucyA9IHRoaXMud2F2ZVtpXS5maWx0ZXIodiA9PiB2KS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChwYXR0ZXJucyA9PT0gMSwgYHdhdmUgJHtpfSBwYXR0ZXJuIGNvdW50ICR7cGF0dGVybnN9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ3JhcGhpY3MobWFya3VwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gMTtcbiAgICAgICAgY29uc3QgdGlsZXNpemUgPSB0aGlzLnRpbGVzZXQuc2l6ZTtcbiAgICAgICAgY29uc29sZS5sb2coXCJ0aWxlc2l6ZVwiLCB0aWxlc2l6ZSwgdGhpcy50aWxlc2V0LCB0aGlzLnRpbGVzZXQuc2l6ZSk7XG4gICAgICAgIGlmICh0aGlzLmFwcCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFwcCA9IG5ldyBQSVhJLkFwcGxpY2F0aW9uKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5GTVggKiB0aWxlc2l6ZSAqIHNjYWxlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5GTVkgKiB0aWxlc2l6ZSAqIHNjYWxlLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICAgICAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdXRvU3RhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNoYXJlZFRpY2tlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hhcmVkTG9hZGVyOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYXBwLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuYXBwO1xuICAgICAgICB0aGlzLmFwcC5zdGFnZS5yZW1vdmVDaGlsZHJlbigpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBuZXcgUElYSS5Db250YWluZXIoKTtcbiAgICAgICAgY29udGFpbmVyLnNjYWxlLnNldChzY2FsZSwgc2NhbGUpO1xuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLkZNWDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLkZNWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBbZmxvb3IsIHdhbGxdID0gdGhpcy50aWxlc2V0LmNlbGxzW3RoaXMub2JzZXJ2ZWRbeCArIHkgKiB0aGlzLkZNWF1dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxvb3IgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gdGhpcy5yZXNvdXJjZXMuc3ByaXRlKHRoaXMudGlsZXNldC50aWxlc1tmbG9vcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCh4ICogdGlsZXNpemUsIHkgKiB0aWxlc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuekluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxsID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwcml0ZSA9IHRoaXMucmVzb3VyY2VzLnNwcml0ZSh0aGlzLnRpbGVzZXQudGlsZXNbd2FsbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCh4ICogdGlsZXNpemUsIHkgKiB0aWxlc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuekluZGV4ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLkZNWDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLkZNWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhID0gdGhpcy53YXZlW3ggKyB5ICogdGhpcy5GTVhdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2VpZ2h0c19zdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuVDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVt0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNfc3VtICs9IHRoaXMud2VpZ2h0c1t0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHBoYSA9IDEgLyB3ZWlnaHRzX3N1bTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLlQ7IHQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbZmxvb3IsIHdhbGxdID0gdGhpcy50aWxlc2V0LmNlbGxzW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVzID0gKGZsb29yID49IDAgPyAxIDogMCkgKyAod2FsbCA+PSAwID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbG9vciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwcml0ZSA9IHRoaXMucmVzb3VyY2VzLnNwcml0ZSh0aGlzLnRpbGVzZXQudGlsZXNbZmxvb3JdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCh4ICogdGlsZXNpemUsIHkgKiB0aWxlc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS56SW5kZXggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuYWxwaGEgPSBhbHBoYSAqICgxIC8gdGlsZXMpICogdGhpcy53ZWlnaHRzW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGwgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcHJpdGUgPSB0aGlzLnJlc291cmNlcy5zcHJpdGUodGhpcy50aWxlc2V0LnRpbGVzW3dhbGxdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCh4ICogdGlsZXNpemUsIHkgKiB0aWxlc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS56SW5kZXggPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuYWxwaGEgPSBhbHBoYSAqICgxIC8gdGlsZXMpICogdGhpcy53ZWlnaHRzW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JhcGhpY3MgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQoZ3JhcGhpY3MpO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoMSwgMHhGRjAwMDApO1xuICAgICAgICBmb3IgKGxldCBpIG9mIG1hcmt1cCkge1xuICAgICAgICAgICAgbGV0IHggPSBpICUgdGhpcy5GTVgsIHkgPSBNYXRoLmZsb29yKGkgLyB0aGlzLkZNWCk7XG4gICAgICAgICAgICBncmFwaGljcy5kcmF3UmVjdCh4ICogdGlsZXNpemUsIHkgKiB0aWxlc2l6ZSwgdGlsZXNpemUsIHRpbGVzaXplKTtcbiAgICAgICAgfVxuICAgICAgICBhcHAucmVuZGVyKCk7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGFwcC52aWV3O1xuICAgICAgICBjb25zb2xlLmxvZygnJWMgJywgYFxuICAgICAgZm9udC1zaXplOiAxcHg7XG4gICAgICBwYWRkaW5nOiAke2NhbnZhcy5oZWlnaHQgLyAyfXB4ICR7Y2FudmFzLndpZHRoIC8gMn1weDtcbiAgICAgIGJhY2tncm91bmQ6IG5vLXJlcGVhdCB1cmwoJHtjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKX0pO1xuICAgICAgYmFja2dyb3VuZC1zaXplOiAke2NhbnZhcy53aWR0aH1weCAke2NhbnZhcy5oZWlnaHR9cHg7XG4gICAgYCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJvcmRlckNvbnN0cmFpbnQge1xuICAgIGNvbnN0cnVjdG9yKGlzQm9yZGVyQ2VsbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0JvcmRlckNlbGwgPSBpc0JvcmRlckNlbGw7XG4gICAgfVxuICAgIGluaXQobW9kZWwpIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICBvbkNsZWFyKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9uIGNsZWFyXCIpO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBtb2RlbC5GTVggKiBtb2RlbC5GTVk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeCA9IGkgJSBtb2RlbC5GTVgsIHkgPSBNYXRoLmZsb29yKGkgLyBtb2RlbC5GTVgpO1xuICAgICAgICAgICAgaWYgKHggPT09IDAgfHwgeCA9PT0gbW9kZWwuRk1YIC0gMSB8fCB5ID09PSAwIHx8IHkgPT09IG1vZGVsLkZNWSAtIDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG1vZGVsLlQ7IHQrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwud2F2ZVtpXVt0XSAmJiAhdGhpcy5pc0JvcmRlckNlbGxbdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmJhbihpLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkJhbihfaW5kZXgsIF9wYXR0ZXJuKSB7XG4gICAgfVxuICAgIG9uQmFja3RyYWNrKF9pbmRleCwgX3BhdHRlcm4pIHtcbiAgICB9XG4gICAgY2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQYXRoQ29uc3RyYWludCB7XG4gICAgY29uc3RydWN0b3IoaXNQYXRoQ2VsbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5ncmFwaCA9IG51bGw7XG4gICAgICAgIHRoaXMuY291bGRCZVBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5tdXN0QmVQYXRoID0gW107XG4gICAgICAgIHRoaXMucmVmcmVzaCA9IFtdO1xuICAgICAgICB0aGlzLnJlZnJlc2hRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmlzUGF0aENlbGwgPSBpc1BhdGhDZWxsO1xuICAgIH1cbiAgICBpbml0KG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IG1vZGVsLkZNWCAqIG1vZGVsLkZNWTtcbiAgICAgICAgdGhpcy5jb3VsZEJlUGF0aCA9IGJ1ZmZlcihpbmRpY2VzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubXVzdEJlUGF0aCA9IGJ1ZmZlcihpbmRpY2VzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmcmVzaCA9IGJ1ZmZlcihpbmRpY2VzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoUXVldWUgPSBbXTtcbiAgICB9XG4gICAgb25DbGVhcigpIHtcbiAgICAgICAgbGV0IGluZGljZXMgPSB0aGlzLm1vZGVsLkZNWCAqIHRoaXMubW9kZWwuRk1ZO1xuICAgICAgICB0aGlzLmNvdWxkQmVQYXRoID0gYnVmZmVyKGluZGljZXMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tdXN0QmVQYXRoID0gYnVmZmVyKGluZGljZXMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoID0gYnVmZmVyKGluZGljZXMsIHRydWUpO1xuICAgICAgICB0aGlzLnJlZnJlc2hRdWV1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoUXVldWUucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2hBbGwoKTtcbiAgICAgICAgdGhpcy5ncmFwaCA9IHRoaXMuY3JlYXRlR3JhcGgoKTtcbiAgICB9XG4gICAgb25CYWNrdHJhY2soaW5kZXgsIF9wYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMuYWRkUmVmcmVzaChpbmRleCk7XG4gICAgfVxuICAgIG9uQmFuKGluZGV4LCBfcGF0dGVybikge1xuICAgICAgICB0aGlzLmFkZFJlZnJlc2goaW5kZXgpO1xuICAgIH1cbiAgICBhZGRSZWZyZXNoKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5yZWZyZXNoW2luZGV4XSkge1xuICAgICAgICAgICAgY29uc3QgRk1YID0gdGhpcy5tb2RlbC5GTVg7XG4gICAgICAgICAgICBjb25zdCBGTVkgPSB0aGlzLm1vZGVsLkZNWTtcbiAgICAgICAgICAgIGxldCB4ID0gaW5kZXggJSBGTVgsIHkgPSBNYXRoLmZsb29yKGluZGV4IC8gRk1YKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFtpbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoUXVldWUucHVzaChpbmRleCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkaXJlY3Rpb24gPSAwOyBkaXJlY3Rpb24gPCA0OyBkaXJlY3Rpb24rKykge1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IE1vZGVsLkRYW2RpcmVjdGlvbl0sIGR5ID0gTW9kZWwuRFlbZGlyZWN0aW9uXTtcbiAgICAgICAgICAgICAgICBsZXQgc3ggPSB4ICsgZHgsIHN5ID0geSArIGR5O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLm9uQm91bmRhcnkoc3gsIHN5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN4IDwgMClcbiAgICAgICAgICAgICAgICAgICAgc3ggKz0gRk1YO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN4ID49IEZNWClcbiAgICAgICAgICAgICAgICAgICAgc3ggLT0gRk1YO1xuICAgICAgICAgICAgICAgIGlmIChzeSA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN5ICs9IEZNWTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzeSA+PSBGTVkpXG4gICAgICAgICAgICAgICAgICAgIHN5IC09IEZNWTtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IHN4ICsgc3kgKiBGTVg7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnJlc2hbc10pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoW3NdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoUXVldWUucHVzaChzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaEFsbCgpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICBjb25zdCBUID0gbW9kZWwuVDtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVmcmVzaFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLnJlZnJlc2hRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHBhdGhDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgdG90YWxDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IFQ7IHQrKykge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbC53YXZlW2ldW3RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQYXRoQ2VsbFt0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvdWxkQmVQYXRoW2ldID0gcGF0aENvdW50ID4gMDtcbiAgICAgICAgICAgIHRoaXMubXVzdEJlUGF0aFtpXSA9IHBhdGhDb3VudCA+IDAgJiYgdG90YWxDb3VudCA9PT0gcGF0aENvdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrKCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQWxsKCk7XG4gICAgICAgICAgICBsZXQgaXNBcnRpY3VsYXRpb24gPSB0aGlzLmdldEFydGljdWxhdGlvblBvaW50cygpO1xuICAgICAgICAgICAgaWYgKGlzQXJ0aWN1bGF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5kZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIm5vIGFydGljdWxhdGlvblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsLnN0YXR1cyA9IFJlc29sdXRpb24uQ29udHJhZGljdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBseUFydGljdWxhdGlvblBvaW50cyhpc0FydGljdWxhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFydGljdWxhdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmt1cCA9IGlzQXJ0aWN1bGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKCh2LCBpKSA9PiBbdiwgaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGEgPT4gYVswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYSA9PiBhWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5ncmFwaGljcyhtYXJrdXApO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRpbnVlIGFydGljdWxhdGlvbiBsb29wXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5QXJ0aWN1bGF0aW9uUG9pbnRzKGlzQXJ0aWN1bGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgY29uc3QgRk1YID0gbW9kZWwuRk1YO1xuICAgICAgICBjb25zdCBGTVkgPSBtb2RlbC5GTVk7XG4gICAgICAgIGxldCBpbmRpY2VzID0gRk1YICogRk1ZO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzQXJ0aWN1bGF0aW9uW2ldICYmICF0aGlzLm11c3RCZVBhdGhbaV0pIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYXJ0aWN1bGF0aW9uXCIsIGkpO1xuICAgICAgICAgICAgICAgIGxldCB4ID0gaSAlIG1vZGVsLkZNWCwgeSA9IE1hdGguZmxvb3IoaSAvIG1vZGVsLkZNWCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIngsIHksIGlcIiwgeCwgeSwgaSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBtb2RlbC5UOyB0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLndhdmVbaV1bdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUGF0aENlbGxbdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwuZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYmFuIG5vdCBwYXRoXCIsIGksIHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmJhbihpLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgZ2V0QXJ0aWN1bGF0aW9uUG9pbnRzKCkge1xuICAgICAgICBjb25zdCB3YWxrYWJsZSA9IHRoaXMuY291bGRCZVBhdGg7XG4gICAgICAgIGNvbnN0IHJlbGV2YW50ID0gdGhpcy5tdXN0QmVQYXRoO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IHdhbGthYmxlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbG93ID0gYnVmZmVyKGluZGljZXMsIDApO1xuICAgICAgICBsZXQgbnVtID0gMTtcbiAgICAgICAgY29uc3QgZGZzTnVtID0gYnVmZmVyKGluZGljZXMsIDApO1xuICAgICAgICBjb25zdCBtYXJrdXAgPSBbXTtcbiAgICAgICAgY29uc3QgaXNBcnRpY3VsYXRpb24gPSBidWZmZXIoaW5kaWNlcywgZmFsc2UpO1xuICAgICAgICBmdW5jdGlvbiBjdXRWZXJ0ZXgoaW5pdGlhbFUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5ldyBDdXRWZXJ0ZXhGcmFtZShpbml0aWFsVSkpO1xuICAgICAgICAgICAgbGV0IGNoaWxkUmVsZXZhbnRTdWJ0cmVlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgY2hpbGRDb3VudCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lSW5kZXggPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gc3RhY2tbZnJhbWVJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgdSA9IGZyYW1lLnU7XG4gICAgICAgICAgICAgICAgbGV0IHN3aXRjaFN0YXRlID0gZnJhbWUuc3RhdGU7XG4gICAgICAgICAgICAgICAgbGV0IGxvb3A7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3dpdGNoU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1JlbGV2YW50ID0gcmVsZXZhbnQgIT0gbnVsbCAmJiByZWxldmFudFt1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWxldmFudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FydGljdWxhdGlvblt1XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLmlzUmVsZXZhbnRTdWJ0cmVlID0gaXNSZWxldmFudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dbdV0gPSBkZnNOdW1bdV0gPSBudW0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrdXAucHVzaCh1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2hTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmVpZ2hib3VycyA9IGdyYXBoLm5laWdoYm91cnNbdV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5laWdoYm91ckluZGV4ID0gZnJhbWUubmVpZ2hib3VySW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5laWdoYm91ckluZGV4ID49IG5laWdoYm91cnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaFN0YXRlID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdiA9IG5laWdoYm91cnNbbmVpZ2hib3VySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2Fsa2FibGVbdl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUubmVpZ2hib3VySW5kZXggPSBuZWlnaGJvdXJJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaFN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdW52aXNpdGVkID0gZGZzTnVtW3ZdID09PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnZpc2l0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXcgQ3V0VmVydGV4RnJhbWUodikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5zdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaFN0YXRlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tbZnJhbWVJbmRleF0gPSBmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dbdV0gPSBNYXRoLm1pbihsb3dbdV0sIGRmc051bVt2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLm5laWdoYm91ckluZGV4ID0gbmVpZ2hib3VySW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaFN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZWlnaGJvdXJzID0gZ3JhcGgubmVpZ2hib3Vyc1t1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmVpZ2hib3VySW5kZXggPSBmcmFtZS5uZWlnaGJvdXJJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdiA9IG5laWdoYm91cnNbbmVpZ2hib3VySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUluZGV4ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRSZWxldmFudFN1YnRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuaXNSZWxldmFudFN1YnRyZWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG93W3ZdID49IGRmc051bVt1XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsZXZhbnQgPT0gbnVsbCB8fCBjaGlsZFJlbGV2YW50U3VidHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBcnRpY3VsYXRpb25bdV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd1t1XSA9IE1hdGgubWluKGxvd1t1XSwgbG93W3ZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZS5uZWlnaGJvdXJJbmRleCA9IG5laWdoYm91ckluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2hTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJbmRleCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZENvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRSZWxldmFudFN1YnRyZWUgPSBmcmFtZS5pc1JlbGV2YW50U3VidHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKGZyYW1lSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlIChsb29wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXM7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF3YWxrYWJsZVtpXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghcmVsZXZhbnRbaV0pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoZGZzTnVtW2ldICE9IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjdXRWZXJ0ZXgoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlbGV2YW50W2ldICYmIGRmc051bVtpXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIndhbGthYmxlOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmt1cFcgPSB3YWxrYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgodiwgaSkgPT4gW3YsIGldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihhID0+IGFbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGEgPT4gYVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmdyYXBoaWNzKG1hcmt1cFcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ2aXNpdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5ncmFwaGljcyhtYXJrdXApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gbW9kZWwuRk1YO1xuICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IGkgJSB3LCB5ID0gTWF0aC5mbG9vcihpIC8gdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYG5vdCB2aXNpdGVkIHJlbGV2YW50IHBvaW50IGk9JHtpfSB4PSR7eH0geT0ke3l9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZ3JhcGggbmVpZ2hib3VycycsIGdyYXBoLm5laWdoYm91cnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5ncmFwaGljcyhbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXM7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF3YWxrYWJsZVtpXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZWxldmFudFtpXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChkZnNOdW1baV0gIT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChpc0FydGljdWxhdGlvbltpXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBjaGlsZENvdW50ID0gY3V0VmVydGV4KGkpO1xuICAgICAgICAgICAgaXNBcnRpY3VsYXRpb25baV0gPSBjaGlsZENvdW50ID4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnRpY3VsYXRpb247XG4gICAgfVxuICAgIGNyZWF0ZUdyYXBoKCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIGxldCBub2RlQ291bnQgPSBtb2RlbC5GTVggKiBtb2RlbC5GTVk7XG4gICAgICAgIGxldCBuZWlnaGJvdXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG5laWdoYm91cnNbaV0gPSBbXTtcbiAgICAgICAgICAgIGxldCB4ID0gaSAlIG1vZGVsLkZNWCwgeSA9IE1hdGguZmxvb3IoaSAvIG1vZGVsLkZNWCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkaXJlY3Rpb24gPSAwOyBkaXJlY3Rpb24gPCA0OyBkaXJlY3Rpb24rKykge1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IE1vZGVsLkRYW2RpcmVjdGlvbl0sIGR5ID0gTW9kZWwuRFlbZGlyZWN0aW9uXTtcbiAgICAgICAgICAgICAgICBsZXQgc3ggPSB4ICsgZHgsIHN5ID0geSArIGR5O1xuICAgICAgICAgICAgICAgIGlmICghbW9kZWwucGVyaW9kaWMgJiYgKHN4ID49IG1vZGVsLkZNWCB8fCBzeSA+PSBtb2RlbC5GTVkgfHwgc3ggPCAwIHx8IHN5IDwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzeCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN4ICs9IG1vZGVsLkZNWDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzeCA+PSBtb2RlbC5GTVgpXG4gICAgICAgICAgICAgICAgICAgIHN4IC09IG1vZGVsLkZNWDtcbiAgICAgICAgICAgICAgICBpZiAoc3kgPCAwKVxuICAgICAgICAgICAgICAgICAgICBzeSArPSBtb2RlbC5GTVk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3kgPj0gbW9kZWwuRk1ZKVxuICAgICAgICAgICAgICAgICAgICBzeSAtPSBtb2RlbC5GTVk7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBzeCArIHN5ICogbW9kZWwuRk1YO1xuICAgICAgICAgICAgICAgIG5laWdoYm91cnNbaV0ucHVzaChzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZUNvdW50OiBub2RlQ291bnQsXG4gICAgICAgICAgICBuZWlnaGJvdXJzOiBuZWlnaGJvdXJzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIEN1dFZlcnRleEZyYW1lIHtcbiAgICBjb25zdHJ1Y3Rvcih1KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAwO1xuICAgICAgICB0aGlzLm5laWdoYm91ckluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5pc1JlbGV2YW50U3VidHJlZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnUgPSB1O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSb29tQ29uc3RyYWludCB7XG4gICAgY29uc3RydWN0b3IoaXNSb29tQ2VsbCwgZGVueU90aGVyLCB0dW5uZWxpbmcpIHtcbiAgICAgICAgdGhpcy5pc1Jvb21DZWxsID0gW107XG4gICAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmlzUm9vbUNlbGwgPSBpc1Jvb21DZWxsO1xuICAgICAgICB0aGlzLmRlbnlPdGhlciA9IGRlbnlPdGhlcjtcbiAgICAgICAgdGhpcy50dW5uZWxpbmdPcHRpb25zID0gdHVubmVsaW5nO1xuICAgIH1cbiAgICBpbml0KG1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgb25DbGVhcigpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICBjb25zdCB0dW5uZWxpbmcgPSBuZXcgVHVubmVsaW5nQWxnb3JpdGhtKG1vZGVsLnJuZywgbW9kZWwuRk1YLCBtb2RlbC5GTVksIHRoaXMudHVubmVsaW5nT3B0aW9ucyk7XG4gICAgICAgIHR1bm5lbGluZy5nZW5lcmF0ZSgpO1xuICAgICAgICBjb25zdCBpc1Jvb20gPSBidWZmZXIobW9kZWwuRk1YICogbW9kZWwuRk1ZLCBmYWxzZSk7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiB0dW5uZWxpbmcucm9vbXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSByb29tLnk7IHkgPCByb29tLnkgKyByb29tLmg7IHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSByb29tLng7IHggPCByb29tLnggKyByb29tLnc7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpc1Jvb21beCArIHkgKiBtb2RlbC5GTVhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpc1Jvb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbW9kZWwuVDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUm9vbVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNSb29tQ2VsbFt0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuYmFuKGksIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGVueU90aGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUm9vbUNlbGxbdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmJhbihpLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjaygpIHtcbiAgICB9XG4gICAgb25CYWNrdHJhY2soX2luZGV4LCBfcGF0dGVybikge1xuICAgIH1cbiAgICBvbkJhbihfaW5kZXgsIF9wYXR0ZXJuKSB7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIER1bmdlb25DcmF3bGVyQ29uc3RyYWludCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgaW5pdChtb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIG9uQ2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgY29uc29sZS50aW1lKFwiY3Jhd2xlclwiKTtcbiAgICAgICAgY29uc3QgY3Jhd2xlciA9IG5ldyBEdW5nZW9uQ3Jhd2xlcih0aGlzLmNvbmZpZywgbW9kZWwucm5nKTtcbiAgICAgICAgY3Jhd2xlci5nZW5lcmF0ZSgpO1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoXCJjcmF3bGVyXCIpO1xuICAgICAgICBjb25zb2xlLnRpbWUoXCJjcmF3bGVyIGNvbnN0cmFpbnRcIik7XG4gICAgICAgIGNvbnN0IGlzT3BlbiA9IGJ1ZmZlcihtb2RlbC5GTVggKiBtb2RlbC5GTVksIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjcmF3bGVyLmNvbmZpZy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjcmF3bGVyLmNvbmZpZy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHggKyB5ICogbW9kZWwuRk1YO1xuICAgICAgICAgICAgICAgIGlzT3BlbltpXSA9IGNyYXdsZXIuaXNNYXBPcGVuKHsgeDogeCwgeTogeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmx5Rmxvb3JBcm91bmQoaSkge1xuICAgICAgICAgICAgbGV0IHggPSBpICUgbW9kZWwuRk1YLCB5ID0gTWF0aC5mbG9vcihpIC8gbW9kZWwuRk1YKTtcbiAgICAgICAgICAgIGZvciAobGV0IGR5ID0gMDsgZHkgPD0gMTsgZHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGR4ID0gLTE7IGR4IDw9IDE7IGR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ggPSB4ICsgZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3kgPSB5ICsgZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZWwub25Cb3VuZGFyeShzeCwgc3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09wZW5bc3ggKyBzeSAqIG1vZGVsLkZNWF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNGbG9vckFyb3VuZChpLCBoID0gMikge1xuICAgICAgICAgICAgbGV0IHggPSBpICUgbW9kZWwuRk1YLCB5ID0gTWF0aC5mbG9vcihpIC8gbW9kZWwuRk1YKTtcbiAgICAgICAgICAgIGZvciAobGV0IGR5ID0gLTE7IGR5IDw9IGg7IGR5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkeCA9IC0xOyBkeCA8PSAxOyBkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN4ID0geCArIGR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN5ID0geSArIGR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLm9uQm91bmRhcnkoc3gsIHN5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09wZW5bc3ggKyBzeSAqIG1vZGVsLkZNWF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja09wZW4oaSwgZHgsIGR5KSB7XG4gICAgICAgICAgICBsZXQgeCA9IGkgJSBtb2RlbC5GTVgsIHkgPSBNYXRoLmZsb29yKGkgLyBtb2RlbC5GTVgpO1xuICAgICAgICAgICAgbGV0IHN4ID0geCArIGR4O1xuICAgICAgICAgICAgbGV0IHN5ID0geSArIGR5O1xuICAgICAgICAgICAgaWYgKG1vZGVsLm9uQm91bmRhcnkoc3gsIHN5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBpc09wZW5bc3ggKyBzeSAqIG1vZGVsLkZNWF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpc09wZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlVHlwZXMgPSBidWZmZXIoNiwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gY2hlY2tPcGVuKGksIDAsIDEpO1xuICAgICAgICAgICAgaWYgKGlzT3BlbltpXSkge1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlVHlwZXNbQ2VsbFR5cGUuRU1QVFldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcG9zc2libGVUeXBlc1tDZWxsVHlwZS5GTE9PUl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghb25seUZsb29yQXJvdW5kKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVHlwZXNbQ2VsbFR5cGUuRkxPT1JfV0FMTF9UT1BdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRmxvb3JBcm91bmQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9wID0gY2hlY2tPcGVuKGksIDAsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUeXBlc1tDZWxsVHlwZS5FTVBUWV0gPSAhKHRvcCA9PT0gdHJ1ZSB8fCBib3R0b20gPT09IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVR5cGVzW0NlbGxUeXBlLldBTExfTUlEXSA9IHRvcCA9PT0gdHJ1ZSB8fCBib3R0b20gPT09IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVHlwZXNbQ2VsbFR5cGUuV0FMTF9UT1BdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVUeXBlc1tDZWxsVHlwZS5XQUxMX1NJREVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVHlwZXNbQ2VsbFR5cGUuRU1QVFldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG1vZGVsLlQ7IHQrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtb2RlbC50aWxlc2V0LmNlbGxzW3RdWzJdO1xuICAgICAgICAgICAgICAgIGlmICghcG9zc2libGVUeXBlc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5iYW4oaSwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUudGltZUVuZChcImNyYXdsZXIgY29uc3RyYWludFwiKTtcbiAgICB9XG4gICAgY2hlY2soKSB7XG4gICAgfVxuICAgIG9uQmFja3RyYWNrKF9pbmRleCwgX3BhdHRlcm4pIHtcbiAgICB9XG4gICAgb25CYW4oX2luZGV4LCBfcGF0dGVybikge1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFdmVuU2ltcGxlVGlsZWRNb2RlbFRlc3Qge1xuICAgIHN0YXRpYyB0ZXN0KHJlc291cmNlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IFBJWEkuTG9hZGVyKCk7XG4gICAgICAgICAgICBsb2FkZXIuYWRkKFwidmlsbGFnZS5ydWxlcy5qc29uXCIpO1xuICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGxvYWRlci5sb2FkKCgpID0+IHJlc29sdmUoKSkpO1xuICAgICAgICAgICAgY29uc3QgdGlsZXNldCA9IGxvYWRlci5yZXNvdXJjZXNbXCJ2aWxsYWdlLnJ1bGVzLmpzb25cIl0uZGF0YTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGlsZXNldFwiLCB0aWxlc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IChyZWdleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVzID0gdGlsZXNldC50aWxlcy5tYXAodCA9PiAhIXQubWF0Y2gocmVnZXgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGlsZXNldC5jZWxscy5tYXAoY2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtmLCB3XSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmID49IDAgJiYgdGlsZXNbZl0gJiYgdyA9PT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYm9yZGVyQ2VsbHMgPSBmaWx0ZXIoL15ncmFzc19cXGQrXFwucG5nJC8pO1xuICAgICAgICAgICAgY29uc3QgcGF0aENlbGxzID0gZmlsdGVyKC9ecm9hZF9cXGQrXFwucG5nJC8pO1xuICAgICAgICAgICAgY29uc3Qgcm9vbUNlbGxzID0gZmlsdGVyKC9ed29vZF9mbG9vcl9cXGQrXFwucG5nJC8pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJib3JkZXJDZWxsc1wiLCBib3JkZXJDZWxscyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBhdGhDZWxsc1wiLCBwYXRoQ2VsbHMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJyb29tQ2VsbHNcIiwgcm9vbUNlbGxzKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gbmV3IEV2ZW5TaW1wbGVUaWxlZE1vZGVsKHJlc291cmNlcywgdGlsZXNldCwgbmV3IFJORygpLCA1MCwgNTAsIFtcbiAgICAgICAgICAgICAgICBuZXcgQm9yZGVyQ29uc3RyYWludChib3JkZXJDZWxscyksXG4gICAgICAgICAgICAgICAgbmV3IFJvb21Db25zdHJhaW50KHJvb21DZWxscywgdHJ1ZSwge1xuICAgICAgICAgICAgICAgICAgICByb29tX21heF93OiA3LFxuICAgICAgICAgICAgICAgICAgICByb29tX21heF9oOiA1LFxuICAgICAgICAgICAgICAgICAgICBtYXhfY29ycl9kaXN0OiAyMCxcbiAgICAgICAgICAgICAgICAgICAgbWluX2NvcnJfZGlzdF94OiA1LFxuICAgICAgICAgICAgICAgICAgICBtaW5fY29ycl9kaXN0X3k6IDEwLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBQYXRoQ29uc3RyYWludChwYXRoQ2VsbHMpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zb2xlLnRpbWUoXCJtb2RlbCBsb29wIHJ1blwiKTtcbiAgICAgICAgICAgIGxldCBzdGF0ZTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS50aW1lKFwibW9kZWwgcnVuXCIpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0geWllbGQgbW9kZWwucnVuKDEwMDAwKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoXCJtb2RlbCBydW5cIik7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBSZXNvbHV0aW9uLkRlY2lkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImZhaWxlZCBydW4gbW9kZWxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInN1Y2Nlc3MgcnVuIG1vZGVsXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoXCJtb2RlbCBsb29wIHJ1blwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibW9kZWxcIiwgbW9kZWwpO1xuICAgICAgICAgICAgbW9kZWwuZ3JhcGhpY3MoW10pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7XG4gICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBCYXNlRHVuZ2VvbkdlbmVyYXRvciB9IGZyb20gJy4uL2R1bmdlb24uZ2VuZXJhdG9yJztcbmltcG9ydCB7IER1bmdlb25DcmF3bGVyQ29uc3RyYWludCwgRXZlblNpbXBsZVRpbGVkTW9kZWwgfSBmcm9tIFwiLi9ldmVuLnNpbXBsZS50aWxlZFwiO1xuaW1wb3J0IHsgUmVzb2x1dGlvbiB9IGZyb20gXCIuL21vZGVsXCI7XG5pbXBvcnQgeyB5aWVsZHMgfSBmcm9tIFwiLi4vY29uY3VyZW5jeVwiO1xuaW1wb3J0IHsgUk5HIH0gZnJvbSBcIi4uL3JuZ1wiO1xuZXhwb3J0IGNsYXNzIEh5YnJpZER1bmdlb25HZW5lcmF0b3IgZXh0ZW5kcyBCYXNlRHVuZ2VvbkdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoY29udHJvbGxlcikge1xuICAgICAgICBzdXBlcihjb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gICAgfVxuICAgIGdldCBwZXJjZW50KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5tb2RlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlcmNlbnQpIHx8IDA7XG4gICAgfVxuICAgIGdlbmVyYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbGVzZXQgPSB0aGlzLmNvbnRyb2xsZXIuYXBwLmxvYWRlci5yZXNvdXJjZXNbJ2R1bmdlb24ucnVsZXMuNC5qc29uJ10uZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29udHJvbGxlci5hcHAubG9hZGVyLnJlc291cmNlc1snZHVuZ2Vvbi5kZXNpZ24uanNvbiddLmRhdGE7XG4gICAgICAgICAgICBjb25zdCBoZXJvID0gb3B0aW9ucy5oZXJvO1xuICAgICAgICAgICAgbGV0IHNlZWQ7XG4gICAgICAgICAgICBpZiAoaGVyby5kdW5nZW9uU2VlZHMuaGFzKG9wdGlvbnMubGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgc2VlZCA9IGhlcm8uZHVuZ2VvblNlZWRzLmdldChvcHRpb25zLmxldmVsKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgZHVuZ2VvbiBsZXZlbCAke29wdGlvbnMubGV2ZWx9IGV4aXN0cyBzZWVkOiAke3NlZWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWVkID0gdGhpcy5jb250cm9sbGVyLnJuZy5uZXh0SW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGR1bmdlb24gbGV2ZWwgJHtvcHRpb25zLmxldmVsfSBuZXcgc2VlZDogJHtzZWVkfWApO1xuICAgICAgICAgICAgICAgIGhlcm8uZHVuZ2VvblNlZWRzLnNldChvcHRpb25zLmxldmVsLCBzZWVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJuZyA9IG5ldyBSTkcoc2VlZCk7XG4gICAgICAgICAgICB5aWVsZCB5aWVsZHMoMTApO1xuICAgICAgICAgICAgY29uc3QgY3Jhd2xlciA9IG5ldyBEdW5nZW9uQ3Jhd2xlckNvbnN0cmFpbnQoY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBuZXcgRXZlblNpbXBsZVRpbGVkTW9kZWwodGhpcy5yZXNvdXJjZXMsIHRpbGVzZXQsIHJuZywgY29uZmlnLndpZHRoLCBjb25maWcuaGVpZ2h0LCBbY3Jhd2xlcl0pO1xuICAgICAgICAgICAgY29uc29sZS50aW1lKFwibW9kZWwgbG9vcCBydW5cIik7XG4gICAgICAgICAgICBsZXQgc3RhdGU7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUudGltZShcIm1vZGVsIHJ1blwiKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHlpZWxkIHRoaXMubW9kZWwucnVuKDEwMDAwKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoXCJtb2RlbCBydW5cIik7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBSZXNvbHV0aW9uLkRlY2lkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImZhaWxlZCBydW4gbW9kZWxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInN1Y2Nlc3MgcnVuIG1vZGVsXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgeWllbGRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLnRpbWVFbmQoXCJtb2RlbCBsb29wIHJ1blwiKTtcbiAgICAgICAgICAgIGNvbnN0IGR1bmdlb24gPSB0aGlzLmNyZWF0ZUR1bmdlb24ocm5nLCBzZWVkLCBvcHRpb25zLmxldmVsLCB0aGlzLm1vZGVsLkZNWCwgdGhpcy5tb2RlbC5GTVkpO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzLm1vZGVsLm9ic2VydmVkO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLm1vZGVsLkZNWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm1vZGVsLkZNWDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB4ICsgeSAqIHRoaXMubW9kZWwuRk1YO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZmxvb3IsIHdhbGxdID0gdGlsZXNldC5jZWxsc1tvYnNlcnZlZFtpXV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbG9vciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdW5nZW9uLmNlbGwoeCwgeSkuZmxvb3JOYW1lID0gdGlsZXNldC50aWxlc1tmbG9vcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGwgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVuZ2Vvbi5jZWxsKHgsIHkpLndhbGxOYW1lID0gdGlsZXNldC50aWxlc1t3YWxsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHlpZWxkcygpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlRmxvb3JSYW5kb21seShybmcsIGR1bmdlb24pO1xuICAgICAgICAgICAgeWllbGQgeWllbGRzKCk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VXYWxsUmFuZG9tbHkocm5nLCBkdW5nZW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGhlcm9BSSA9IHRoaXMucGxhY2VIZXJvKHJuZywgZHVuZ2Vvbiwgb3B0aW9ucy5oZXJvKTtcbiAgICAgICAgICAgIHlpZWxkIHlpZWxkcygpO1xuICAgICAgICAgICAgdGhpcy5wbGFjZUxhZGRlcihybmcsIGR1bmdlb24sIGhlcm9BSSk7XG4gICAgICAgICAgICB5aWVsZCB5aWVsZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzX2JvbmZpcmUgPSBvcHRpb25zLmxldmVsICUgNSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChpc19ib25maXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZUJvbmZpcmUocm5nLCBkdW5nZW9uLCBoZXJvQUkpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wbGFjZU5wYyhybmcsIGR1bmdlb24sIGhlcm9BSSk7XG4gICAgICAgICAgICB5aWVsZCB5aWVsZHMoKTtcbiAgICAgICAgICAgIHRoaXMucGxhY2VNb25zdGVycyhybmcsIGR1bmdlb24sIGhlcm9BSSk7XG4gICAgICAgICAgICB5aWVsZCB5aWVsZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzX2Jvc3MgPSBvcHRpb25zLmxldmVsICUgNSA9PT0gMDtcbiAgICAgICAgICAgIGlmIChpc19ib3NzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZUJvc3Mocm5nLCBkdW5nZW9uLCBoZXJvQUkpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wbGFjZURyb3Aocm5nLCBkdW5nZW9uKTtcbiAgICAgICAgICAgIHlpZWxkIHlpZWxkcygpO1xuICAgICAgICAgICAgZHVuZ2Vvbi5saWdodC5sb2FkTWFwKCk7XG4gICAgICAgICAgICB5aWVsZCB5aWVsZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBkdW5nZW9uO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBIeWJyaWREdW5nZW9uR2VuZXJhdG9yIH0gZnJvbSBcIi4vd2ZjL2R1bmdlb24uZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyBDb2xvcnMgfSBmcm9tIFwiLi91aVwiO1xuaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiO1xuZXhwb3J0IGNsYXNzIEdlbmVyYXRlRHVuZ2VvblNjZW5lIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICB0aGlzLmdlbmVyYXRvciA9IG5ldyBIeWJyaWREdW5nZW9uR2VuZXJhdG9yKHRoaXMuY29udHJvbGxlcik7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMuZ2VuZXJhdG9yLmdlbmVyYXRlKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByb21pc2UudGhlbigoZHVuZ2VvbikgPT4gdGhpcy5jb250cm9sbGVyLmR1bmdlb24ob3B0aW9ucy5oZXJvLCBkdW5nZW9uKSk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NCYXIgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnJlbmRlclRpdGxlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUHJvZ3Jlc3NCYXIoKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFwcC50aWNrZXIuYWRkKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgKF9hID0gdGhpcy50aXRsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgKF9iID0gdGhpcy5wcm9ncmVzc0JhcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICB9XG4gICAgcmVuZGVyVGl0bGUoKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBuZXcgUElYSS5CaXRtYXBUZXh0KFwiUk9HVUVMSUtFIERVTkdFT05cIiwgeyBmb250OiB7IG5hbWU6ICdhbGFnYXJkJywgc2l6ZTogNjQgfSB9KTtcbiAgICAgICAgdGhpcy50aXRsZS5hbmNob3IgPSBuZXcgUElYSS5Qb2ludCgwLjUsIDApO1xuICAgICAgICB0aGlzLnRpdGxlLnBvc2l0aW9uLnNldCh0aGlzLmNvbnRyb2xsZXIuYXBwLnNjcmVlbi53aWR0aCA+PiAxLCA2NCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZCh0aGlzLnRpdGxlKTtcbiAgICB9XG4gICAgcmVuZGVyUHJvZ3Jlc3NCYXIoKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NCYXIgPSBuZXcgUElYSS5HcmFwaGljcygpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGhpcy5wcm9ncmVzc0Jhcik7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgY193ID0gdGhpcy5jb250cm9sbGVyLmFwcC5zY3JlZW4ud2lkdGg7XG4gICAgICAgIGNvbnN0IGNfaCA9IHRoaXMuY29udHJvbGxlci5hcHAuc2NyZWVuLmhlaWdodDtcbiAgICAgICAgY29uc3QgbWFyZ2luID0gNDA7XG4gICAgICAgIGNvbnN0IGggPSA2MDtcbiAgICAgICAgY29uc3QgYm9yZGVyID0gNDtcbiAgICAgICAgY29uc3QgdyA9IGNfdyAtIG1hcmdpbiAtIG1hcmdpbjtcbiAgICAgICAgY29uc3Qgd19wID0gTWF0aC5mbG9vcigodyAtIGJvcmRlciAtIGJvcmRlcikgKiB0aGlzLmdlbmVyYXRvci5wZXJjZW50IC8gMTAwKTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci5jbGVhcigpO1xuICAgICAgICB0aGlzLnByb2dyZXNzQmFyLmJlZ2luRmlsbChDb2xvcnMudWlCYWNrZ3JvdW5kLCAwLjMpO1xuICAgICAgICB0aGlzLnByb2dyZXNzQmFyLmRyYXdSZWN0KG1hcmdpbiwgY19oIC0gbWFyZ2luIC0gaCAtIGJvcmRlciAtIGJvcmRlciwgdywgaCk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NCYXIuZW5kRmlsbCgpO1xuICAgICAgICB0aGlzLnByb2dyZXNzQmFyLmJlZ2luRmlsbChDb2xvcnMudWlTZWxlY3RlZCwgMC4zKTtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci5kcmF3UmVjdChtYXJnaW4gKyBib3JkZXIsIGNfaCAtIG1hcmdpbiAtIGggLSBib3JkZXIsIHdfcCwgaCAtIGJvcmRlciAtIGJvcmRlcik7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NCYXIuZW5kRmlsbCgpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEhlcm9TdGF0ZVZpZXcgfSBmcm9tIFwiLi9oZXJvXCI7XG5pbXBvcnQgeyBEdW5nZW9uVGl0bGUgfSBmcm9tIFwiLi9kdW5nZW9uLm1hcFwiO1xuaW1wb3J0IHsgQmVsdEludmVudG9yeVZpZXcgfSBmcm9tIFwiLi9pbnZlbnRvcnlcIjtcbmV4cG9ydCBjbGFzcyBEdW5nZW9uU2NlbmUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIsIGhlcm8sIGR1bmdlb24pIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5kdW5nZW9uID0gZHVuZ2VvbjtcbiAgICAgICAgdGhpcy50aXRsZVZpZXcgPSBuZXcgRHVuZ2VvblRpdGxlKCk7XG4gICAgICAgIHRoaXMuaW52ZW50b3J5VmlldyA9IG5ldyBCZWx0SW52ZW50b3J5VmlldyhoZXJvLmludmVudG9yeS5iZWx0KTtcbiAgICAgICAgdGhpcy5oZWFsdGhWaWV3ID0gbmV3IEhlcm9TdGF0ZVZpZXcoaGVybywgeyBmaXhlZEhQU2l6ZTogZmFsc2UgfSk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IGNfdyA9IHRoaXMuY29udHJvbGxlci5hcHAuc2NyZWVuLndpZHRoO1xuICAgICAgICBjb25zdCBjX2ggPSB0aGlzLmNvbnRyb2xsZXIuYXBwLnNjcmVlbi5oZWlnaHQ7XG4gICAgICAgIHRoaXMudGl0bGVWaWV3LnBvc2l0aW9uLnNldChjX3cgPj4gMSwgMTYpO1xuICAgICAgICB0aGlzLnRpdGxlVmlldy56SW5kZXggPSAxMDtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnN0YWdlLmFkZENoaWxkKHRoaXMudGl0bGVWaWV3KTtcbiAgICAgICAgY29uc3QgaV93ID0gdGhpcy5pbnZlbnRvcnlWaWV3LndpZHRoO1xuICAgICAgICB0aGlzLmludmVudG9yeVZpZXcucG9zaXRpb24uc2V0KChjX3cgPj4gMSkgLSAoaV93ID4+IDEpLCBjX2ggLSAoMzIgKyA0ICsgMTYpKTtcbiAgICAgICAgdGhpcy5pbnZlbnRvcnlWaWV3LnpJbmRleCA9IDExO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGhpcy5pbnZlbnRvcnlWaWV3KTtcbiAgICAgICAgdGhpcy5oZWFsdGhWaWV3LnBvc2l0aW9uLnNldCgxNiwgMTYpO1xuICAgICAgICB0aGlzLmhlYWx0aFZpZXcuekluZGV4ID0gMTI7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZCh0aGlzLmhlYWx0aFZpZXcpO1xuICAgICAgICB0aGlzLnRpdGxlVmlldy5sZXZlbCA9IHRoaXMuZHVuZ2Vvbi5sZXZlbDtcbiAgICAgICAgdGhpcy5kdW5nZW9uLmNvbnRhaW5lci56SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGhpcy5kdW5nZW9uLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZHVuZ2Vvbi5saWdodC5sYXllci56SW5kZXggPSAxO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGhpcy5kdW5nZW9uLmxpZ2h0LmxheWVyKTtcbiAgICAgICAgdGhpcy5kdW5nZW9uLmxpZ2h0aW5nLnpJbmRleCA9IDI7XG4gICAgICAgIHRoaXMuZHVuZ2Vvbi5saWdodGluZy5hbHBoYSA9IDAuODtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnN0YWdlLmFkZENoaWxkKHRoaXMuZHVuZ2Vvbi5saWdodGluZyk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5zb3J0Q2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy5kdW5nZW9uLnRpY2tlci5zdGFydCgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRpdGxlVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaGVhbHRoVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW52ZW50b3J5Vmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZHVuZ2Vvbi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5yZW1vdmVDaGlsZHJlbigpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5kdW5nZW9uLnRpY2tlci5zdG9wKCk7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5kdW5nZW9uLnRpY2tlci5zdGFydCgpO1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIFBJWEkgZnJvbSAncGl4aS5qcyc7XG5leHBvcnQgY2xhc3MgS2V5QmluZFNjZW5lIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGl0bGUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJIZWxwKCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hcHAudGlja2VyLmFkZCh0aGlzLmhhbmRsZUlucHV0LCB0aGlzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMuaGFuZGxlSW5wdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UucmVtb3ZlQ2hpbGRyZW4oKTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICB9XG4gICAgcmVuZGVyVGl0bGUoKSB7XG4gICAgICAgIGxldCB0aXRsZSA9IG5ldyBQSVhJLkJpdG1hcFRleHQoXCJST0dVRUxJS0UgRFVOR0VPTlwiLCB7IGZvbnQ6IHsgbmFtZTogJ2FsYWdhcmQnLCBzaXplOiA2NCB9IH0pO1xuICAgICAgICB0aXRsZS5hbmNob3IgPSBuZXcgUElYSS5Qb2ludCgwLjUsIDApO1xuICAgICAgICB0aXRsZS5wb3NpdGlvbi5zZXQodGhpcy5jb250cm9sbGVyLmFwcC5zY3JlZW4ud2lkdGggPj4gMSwgNjQpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGl0bGUpO1xuICAgIH1cbiAgICByZW5kZXJIZWxwKCkge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IFtcbiAgICAgICAgICAgIFwiV0FTRCAtIHRvcCwgbGVmdCwgYm90dG9tLCByaWdodFwiLFxuICAgICAgICAgICAgXCJGIC0gYWN0aW9uXCIsXG4gICAgICAgICAgICBcIlEgLSBkcm9wIHdlYXBvblwiLFxuICAgICAgICAgICAgXCJJIC0gaW52ZW50b3J5XCIsXG4gICAgICAgICAgICBcIjEgLi4uIDAgLSBiZWx0XCIsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXCJQUkVTUyBGIFRPIENPTlRJTlVFXCIsXG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gbmV3IFBJWEkuQml0bWFwVGV4dCh0ZXh0LCB7IGZvbnQ6IHsgbmFtZTogJ2FsYWdhcmQnLCBzaXplOiAzMiB9IH0pO1xuICAgICAgICAgICAgICAgIGxpbmUucG9zaXRpb24uc2V0KDQwLCAyMDAgKyBpICogMzApO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZChsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVJbnB1dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlci5qb3lzdGljay5oaXQub25jZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc2VsZWN0SGVybygpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaGVyb0NoYXJhY3Rlck5hbWVzLCBIZXJvIH0gZnJvbSBcIi4vaGVyb1wiO1xuaW1wb3J0IHsgV2VhcG9uLCB3ZWFwb25zIH0gZnJvbSBcIi4vZHJvcFwiO1xuaW1wb3J0IHsgQ29sb3JzLCBTZWxlY3RhYmxlR3JpZCB9IGZyb20gXCIuL3VpXCI7XG5pbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCI7XG5jb25zdCBtYXJnaW4gPSA0MDtcbmNvbnN0IHRpdGxlX2ggPSAzMjtcbmNvbnN0IHRpbGVfdyA9IDE2O1xuY29uc3QgdGlsZV9oID0gMjg7XG5leHBvcnQgY2xhc3MgU2VsZWN0SGVyb1NjZW5lIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuaGVyb2VzID0gW107XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IG5ldyBTZWxlY3RhYmxlR3JpZChjb250cm9sbGVyLmpveXN0aWNrKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUaXRsZSgpO1xuICAgICAgICB0aGlzLnJlbmRlckhlcm9lcygpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYXBwLnRpY2tlci5hZGQodGhpcy5zZWxlY3RhYmxlLmhhbmRsZUlucHV0LCB0aGlzLnNlbGVjdGFibGUpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5zZWxlY3RhYmxlLmhhbmRsZUlucHV0LCB0aGlzLnNlbGVjdGFibGUpO1xuICAgICAgICB0aGlzLmhlcm9lcy5mb3JFYWNoKGggPT4gaC5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UucmVtb3ZlQ2hpbGRyZW4oKTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICB9XG4gICAgcmVuZGVyVGl0bGUoKSB7XG4gICAgICAgIGxldCB0aXRsZSA9IG5ldyBQSVhJLkJpdG1hcFRleHQoXCJST0dVRUxJS0UgRFVOR0VPTlwiLCB7IGZvbnQ6IHsgbmFtZTogJ2FsYWdhcmQnLCBzaXplOiA2NCB9IH0pO1xuICAgICAgICB0aXRsZS5hbmNob3IgPSBuZXcgUElYSS5Qb2ludCgwLjUsIDApO1xuICAgICAgICB0aXRsZS5wb3NpdGlvbi5zZXQodGhpcy5jb250cm9sbGVyLmFwcC5zY3JlZW4ud2lkdGggPj4gMSwgNjQpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGl0bGUpO1xuICAgIH1cbiAgICByZW5kZXJIZXJvZXMoKSB7XG4gICAgICAgIGNvbnN0IGNfdyA9IHRoaXMuY29udHJvbGxlci5hcHAuc2NyZWVuLndpZHRoO1xuICAgICAgICBjb25zdCBjX2ggPSB0aGlzLmNvbnRyb2xsZXIuYXBwLnNjcmVlbi5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gaGVyb0NoYXJhY3Rlck5hbWVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVjdF93ID0gTWF0aC5mbG9vcigoY193IC0gbWFyZ2luICogKHRvdGFsICsgMSkpIC8gdG90YWwpO1xuICAgICAgICBjb25zdCBzcHJpdGVfdyA9IHJlY3RfdyAtIChtYXJnaW4gPDwgMSk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gc3ByaXRlX3cgLyB0aWxlX3c7XG4gICAgICAgIGNvbnN0IHNwcml0ZV9oID0gTWF0aC5mbG9vcih0aWxlX2ggKiBzY2FsZSk7XG4gICAgICAgIGNvbnN0IHJlY3RfaCA9IHNwcml0ZV9oICsgdGl0bGVfaCArIG1hcmdpbiAqIDM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaGVyb05hbWUgPSBoZXJvQ2hhcmFjdGVyTmFtZXNbaV07XG4gICAgICAgICAgICBjb25zdCBkX3ggPSBtYXJnaW4gKiAoaSArIDEpICsgcmVjdF93ICogaTtcbiAgICAgICAgICAgIGNvbnN0IGRfeSA9IChjX2ggPj4gMSkgLSAocmVjdF9oID4+IDEpO1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBTZWxlY3RIZXJvVmlldyhyZWN0X3csIHJlY3RfaCwgaGVyb05hbWUsIHRoaXMuY29udHJvbGxlci5yZXNvdXJjZXMpO1xuICAgICAgICAgICAgdmlldy5wb3NpdGlvbi5zZXQoZF94LCBkX3kpO1xuICAgICAgICAgICAgdGhpcy5oZXJvZXMucHVzaCh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZCh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0YWJsZS5zZXQoaSwgMCwgdmlldywgKCkgPT4gdGhpcy5zZWxlY3QoaGVyb05hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGFibGUucmVzZXQoKTtcbiAgICB9XG4gICAgc2VsZWN0KG5hbWUpIHtcbiAgICAgICAgY29uc3QgaGVybyA9IEhlcm8ubG9hZChuYW1lLCB0aGlzLmNvbnRyb2xsZXIucGVyc2lzdGVudCk7XG4gICAgICAgIGNvbnN0IHdlYXBvbiA9IG5ldyBXZWFwb24odGhpcy5jb250cm9sbGVyLnJlc291cmNlcywgd2VhcG9ucy5rbmlmZSk7XG4gICAgICAgIGhlcm8uaW52ZW50b3J5LmVxdWlwbWVudC53ZWFwb24uc2V0KHdlYXBvbik7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5nZW5lcmF0ZUR1bmdlb24oe1xuICAgICAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgICAgICBoZXJvOiBoZXJvXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFNlbGVjdEhlcm9WaWV3IGV4dGVuZHMgUElYSS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIGhlcm9OYW1lLCByZXNvdXJjZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRCZyA9IG5ldyBQSVhJLkdyYXBoaWNzKClcbiAgICAgICAgICAgIC5iZWdpbkZpbGwoQ29sb3JzLnVpU2VsZWN0ZWQpXG4gICAgICAgICAgICAuZHJhd1JlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgICAgIC5lbmRGaWxsKCk7XG4gICAgICAgIHRoaXMubm90U2VsZWN0ZWRCZyA9IG5ldyBQSVhJLkdyYXBoaWNzKClcbiAgICAgICAgICAgIC5iZWdpbkZpbGwoQ29sb3JzLnVpTm90U2VsZWN0ZWQpXG4gICAgICAgICAgICAuZHJhd1JlY3QoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgICAgIC5lbmRGaWxsKCk7XG4gICAgICAgIHRoaXMudGl0bGUgPSBuZXcgUElYSS5CaXRtYXBUZXh0KGhlcm9OYW1lLCB7IGZvbnQ6IHsgbmFtZTogJ2FsYWdhcmQnLCBzaXplOiB0aXRsZV9oIH0gfSk7XG4gICAgICAgIHRoaXMudGl0bGUuYW5jaG9yID0gMC41O1xuICAgICAgICB0aGlzLnRpdGxlLnBvc2l0aW9uLnNldCh3aWR0aCA+PiAxLCBtYXJnaW4pO1xuICAgICAgICBjb25zdCBzcHJpdGVfdyA9IHdpZHRoIC0gKG1hcmdpbiA8PCAxKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBzcHJpdGVfdyAvIHRpbGVfdztcbiAgICAgICAgY29uc3Qgc3ByaXRlX2ggPSBNYXRoLmZsb29yKHRpbGVfaCAqIHNjYWxlKTtcbiAgICAgICAgdGhpcy5zcHJpdGUgPSByZXNvdXJjZXMuYW5pbWF0ZWQoaGVyb05hbWUgKyBcIl9pZGxlXCIpO1xuICAgICAgICB0aGlzLnNwcml0ZS5hbmltYXRpb25TcGVlZCA9IDAuMjtcbiAgICAgICAgdGhpcy5zcHJpdGUud2lkdGggPSBzcHJpdGVfdztcbiAgICAgICAgdGhpcy5zcHJpdGUuaGVpZ2h0ID0gc3ByaXRlX2g7XG4gICAgICAgIHRoaXMuc3ByaXRlLnBvc2l0aW9uLnNldChtYXJnaW4sIG1hcmdpbiArIG1hcmdpbiArIHRpdGxlX2gpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuc2VsZWN0ZWRCZywgdGhpcy5ub3RTZWxlY3RlZEJnLCB0aGlzLnRpdGxlLCB0aGlzLnNwcml0ZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGVkO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEJnLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ub3RTZWxlY3RlZEJnLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudGl0bGUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5nb3RvQW5kUGxheSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRCZy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5vdFNlbGVjdGVkQmcudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRpdGxlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmdvdG9BbmRTdG9wKDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEJnLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RlZEJnLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50aXRsZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3ByaXRlLmRlc3Ryb3koKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBIZXJvU3RhdGVWaWV3IH0gZnJvbSBcIi4vaGVyb1wiO1xuaW1wb3J0IHsgRGVmYXVsdEludmVudG9yeUFjdGlvbnNDb250cm9sbGVyLCBJbnZlbnRvcnlWaWV3IH0gZnJvbSBcIi4vaW52ZW50b3J5XCI7XG5pbXBvcnQgeyBCdXR0b24sIExheW91dCwgU2VsZWN0YWJsZUdyaWQsIENvbG9ycywgU2l6ZXMgfSBmcm9tIFwiLi91aVwiO1xuaW1wb3J0ICogYXMgUElYSSBmcm9tIFwicGl4aS5qc1wiO1xuZXhwb3J0IGNsYXNzIFVwZGF0ZUhlcm9TY2VuZSB7XG4gICAgY29uc3RydWN0b3IoY29udHJvbGxlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnRpdGxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zcHJpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnNwcml0ZUJnID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW52ZW50b3J5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5idXR0b25zID0gW107XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuaGVybyA9IG9wdGlvbnMuaGVybztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gbmV3IFNlbGVjdGFibGVHcmlkKGNvbnRyb2xsZXIuam95c3RpY2spO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBsYXlvdXQgPSBuZXcgTGF5b3V0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyVGl0bGUobGF5b3V0KTtcbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZShsYXlvdXQpO1xuICAgICAgICB0aGlzLnJlbmRlckljb24obGF5b3V0KTtcbiAgICAgICAgdGhpcy5yZW5kZXJDb250aW51ZShsYXlvdXQpO1xuICAgICAgICBsYXlvdXQucmVzZXQoKTtcbiAgICAgICAgbGF5b3V0Lm9mZnNldCgyNTYgKyBTaXplcy51aU1hcmdpbiwgMCk7XG4gICAgICAgIGxheW91dC5jb21taXQoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJJbmNyZWFzZUhlYWx0aChsYXlvdXQpO1xuICAgICAgICBsYXlvdXQucmVzZXQoKTtcbiAgICAgICAgbGF5b3V0Lm9mZnNldCgyNCArIFNpemVzLnVpTWFyZ2luICogMiwgMCk7XG4gICAgICAgIGxheW91dC5jb21taXQoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJJbnZlbnRvcnkobGF5b3V0KTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hcHAudGlja2VyLmFkZCh0aGlzLmhhbmRsZUlucHV0LCB0aGlzKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMuaGFuZGxlSW5wdXQsIHRoaXMpO1xuICAgICAgICAoX2EgPSB0aGlzLnRpdGxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICAoX2IgPSB0aGlzLnNwcml0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICAgICAgKF9jID0gdGhpcy5zcHJpdGVCZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRlc3Ryb3koKTtcbiAgICAgICAgKF9kID0gdGhpcy5zdGF0ZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmRlc3Ryb3koKTtcbiAgICAgICAgKF9lID0gdGhpcy5pbnZlbnRvcnkpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5kZXN0cm95KCk7XG4gICAgICAgIGZvciAobGV0IGJ1dHRvbiBvZiB0aGlzLmJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGJ1dHRvbi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcHJpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnNwcml0ZUJnID0gbnVsbDtcbiAgICAgICAgdGhpcy50aXRsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmludmVudG9yeSA9IG51bGw7XG4gICAgICAgIHRoaXMuYnV0dG9ucy5zcGxpY2UoMCwgMTAwMCk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgfVxuICAgIHJlbmRlclRpdGxlKGxheW91dCkge1xuICAgICAgICB0aGlzLnRpdGxlID0gbmV3IFBJWEkuQml0bWFwVGV4dChcIlJPR1VFTElLRSBEVU5HRU9OXCIsIHsgZm9udDogeyBuYW1lOiAnYWxhZ2FyZCcsIHNpemU6IDY0IH0gfSk7XG4gICAgICAgIHRoaXMudGl0bGUuYW5jaG9yID0gbmV3IFBJWEkuUG9pbnQoMC41LCAwKTtcbiAgICAgICAgdGhpcy50aXRsZS5wb3NpdGlvbi5zZXQodGhpcy5jb250cm9sbGVyLmFwcC5zY3JlZW4ud2lkdGggPj4gMSwgNjQpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGhpcy50aXRsZSk7XG4gICAgICAgIGxheW91dC5vZmZzZXQoMCwgMTI4ICsgU2l6ZXMudWlNYXJnaW4pO1xuICAgICAgICBsYXlvdXQuY29tbWl0KCk7XG4gICAgfVxuICAgIHJlbmRlclN0YXRlKGxheW91dCkge1xuICAgICAgICBsYXlvdXQub2Zmc2V0KFNpemVzLnVpTWFyZ2luLCAwKTtcbiAgICAgICAgbGF5b3V0LmNvbW1pdCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IEhlcm9TdGF0ZVZpZXcodGhpcy5oZXJvLCB7IGZpeGVkSFBTaXplOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnN0YXRlLnBvc2l0aW9uLnNldChsYXlvdXQueCwgbGF5b3V0LnkpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGhpcy5zdGF0ZSk7XG4gICAgICAgIGxheW91dC5vZmZzZXQoMCwgdGhpcy5zdGF0ZS5nZXRCb3VuZHMoKS5oZWlnaHQpO1xuICAgIH1cbiAgICByZW5kZXJJY29uKGxheW91dCkge1xuICAgICAgICB0aGlzLnNwcml0ZSA9IHRoaXMuY29udHJvbGxlci5yZXNvdXJjZXMuYW5pbWF0ZWQodGhpcy5oZXJvLm5hbWUgKyBcIl9pZGxlXCIpO1xuICAgICAgICB0aGlzLnNwcml0ZS5wbGF5KCk7XG4gICAgICAgIHRoaXMuc3ByaXRlLmFuaW1hdGlvblNwZWVkID0gMC4yO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy5zcHJpdGUud2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLnNwcml0ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuc3ByaXRlLndpZHRoID0gMjU2IC0gKFNpemVzLnVpTWFyZ2luIDw8IDEpO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc3ByaXRlLndpZHRoIC8gdztcbiAgICAgICAgdGhpcy5zcHJpdGUuaGVpZ2h0ID0gTWF0aC5mbG9vcihzY2FsZSAqIGgpO1xuICAgICAgICBjb25zdCB0cmltbWVkX2ggPSBNYXRoLmZsb29yKHNjYWxlICogdGhpcy5zcHJpdGUudGV4dHVyZS50cmltLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IG9mZnNldF95ID0gdGhpcy5zcHJpdGUuaGVpZ2h0IC0gdHJpbW1lZF9oO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KDAsIFNpemVzLnVpTWFyZ2luKTtcbiAgICAgICAgdGhpcy5zcHJpdGUucG9zaXRpb24uc2V0KGxheW91dC54ICsgU2l6ZXMudWlNYXJnaW4sIGxheW91dC55ICsgU2l6ZXMudWlNYXJnaW4gLSBvZmZzZXRfeSk7XG4gICAgICAgIHRoaXMuc3ByaXRlQmcgPSBuZXcgUElYSS5HcmFwaGljcygpXG4gICAgICAgICAgICAuYmVnaW5GaWxsKENvbG9ycy51aUJhY2tncm91bmQpXG4gICAgICAgICAgICAuZHJhd1JlY3QoMCwgMCwgMjU2LCB0cmltbWVkX2ggKyAoU2l6ZXMudWlNYXJnaW4gPDwgMSkpXG4gICAgICAgICAgICAuZW5kRmlsbCgpO1xuICAgICAgICB0aGlzLnNwcml0ZUJnLnBvc2l0aW9uLnNldChsYXlvdXQueCwgbGF5b3V0LnkpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGhpcy5zcHJpdGVCZywgdGhpcy5zcHJpdGUpO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KDAsIHRyaW1tZWRfaCArIChTaXplcy51aU1hcmdpbiA8PCAxKSk7XG4gICAgfVxuICAgIHJlbmRlckluY3JlYXNlSGVhbHRoKGxheW91dCkge1xuICAgICAgICBjb25zdCBidXR0b24gPSBuZXcgQnV0dG9uKHtcbiAgICAgICAgICAgIGxhYmVsOiBcIitcIixcbiAgICAgICAgICAgIHdpZHRoOiAyNCxcbiAgICAgICAgICAgIGhlaWdodDogMjRcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1dHRvbi5wb3NpdGlvbi5zZXQobGF5b3V0LngsIGxheW91dC55KTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlLnNldCgxLCAwLCBidXR0b24sICgpID0+IHRoaXMuaGVyby5pbmNyZWFzZUhlYWx0aCgpKTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlLm1lcmdlKDEsIDAsIDEsIDEyKTtcbiAgICAgICAgdGhpcy5idXR0b25zLnB1c2goYnV0dG9uKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnN0YWdlLmFkZENoaWxkKGJ1dHRvbik7XG4gICAgICAgIGxheW91dC5vZmZzZXQoMCwgMjQpO1xuICAgIH1cbiAgICByZW5kZXJDb250aW51ZShsYXlvdXQpIHtcbiAgICAgICAgbGF5b3V0Lm9mZnNldCgwLCBTaXplcy51aU1hcmdpbik7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IG5ldyBCdXR0b24oe1xuICAgICAgICAgICAgbGFiZWw6IFwiQ29udGludWUgLi4uXCIsXG4gICAgICAgICAgICB3aWR0aDogMjU2LFxuICAgICAgICAgICAgaGVpZ2h0OiAzMixcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1dHRvbi5wb3NpdGlvbi5zZXQobGF5b3V0LngsIGxheW91dC55KTtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlLnNldCgwLCAwLCBidXR0b24sICgpID0+IHRoaXMuY29udHJvbGxlci5nZW5lcmF0ZUR1bmdlb24odGhpcy5vcHRpb25zKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZS5tZXJnZSgwLCAwLCAxLCAxMik7XG4gICAgICAgIHRoaXMuYnV0dG9ucy5wdXNoKGJ1dHRvbik7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5zdGFnZS5hZGRDaGlsZChidXR0b24pO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KDAsIDMyKTtcbiAgICB9XG4gICAgcmVuZGVySW52ZW50b3J5KGxheW91dCkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IERlZmF1bHRJbnZlbnRvcnlBY3Rpb25zQ29udHJvbGxlcih0aGlzLmhlcm8uaW52ZW50b3J5KTtcbiAgICAgICAgdGhpcy5pbnZlbnRvcnkgPSBuZXcgSW52ZW50b3J5Vmlldyh0aGlzLmhlcm8uaW52ZW50b3J5LCBjb250cm9sbGVyLCB0aGlzLnNlbGVjdGFibGUsIDIpO1xuICAgICAgICB0aGlzLmludmVudG9yeS5wb3NpdGlvbi5zZXQobGF5b3V0LngsIGxheW91dC55KTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnN0YWdlLmFkZENoaWxkKHRoaXMuaW52ZW50b3J5KTtcbiAgICB9XG4gICAgaGFuZGxlSW5wdXQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZS5oYW5kbGVJbnB1dCgpO1xuICAgIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBTdG9yYWdlUGVyc2lzdGVudFN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBwcmVmaXgpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5zdG9yYWdlKSkge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKHRoaXMucHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5jbGVhcigpO1xuICAgIH1cbiAgICBsb2FkKGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMua2V5KGtleSkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNhdmUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5rZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy50cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5rZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLmNsZWFyKCk7XG4gICAgfVxuICAgIGtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnByZWZpeCwga2V5XS5qb2luKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNMb2NhbGhvc3QoKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiIHx8XG4gICAgICAgIGxvY2F0aW9uLmhvc3RuYW1lID09PSBcIjAuMC4wLjBcIiB8fFxuICAgICAgICBsb2NhdGlvbi5ob3N0bmFtZSA9PT0gXCIxMjcuMC4wLjFcIjtcbn1cbmV4cG9ydCBjbGFzcyBTZXNzaW9uUGVyc2lzdGVudFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZSA9IGlzTG9jYWxob3N0KCkgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZTtcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBuZXcgU3RvcmFnZVBlcnNpc3RlbnRTdG9yZShzdG9yYWdlLCBcImdsb2JhbC5cIik7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG5ldyBTdG9yYWdlUGVyc2lzdGVudFN0b3JlKHN0b3JhZ2UsIFwic2Vzc2lvbi5cIik7XG4gICAgfVxufVxuIiwidmFyIFRva2VuaXplclN0YXRlcztcbihmdW5jdGlvbiAoVG9rZW5pemVyU3RhdGVzKSB7XG4gICAgVG9rZW5pemVyU3RhdGVzW1Rva2VuaXplclN0YXRlc1tcIlN0YXJ0ZWRcIl0gPSAxXSA9IFwiU3RhcnRlZFwiO1xuICAgIFRva2VuaXplclN0YXRlc1tUb2tlbml6ZXJTdGF0ZXNbXCJQYXJzaW5nTnVtYmVyXCJdID0gMl0gPSBcIlBhcnNpbmdOdW1iZXJcIjtcbiAgICBUb2tlbml6ZXJTdGF0ZXNbVG9rZW5pemVyU3RhdGVzW1wiUGFyc2luZ1N0cmluZ1N0YXJ0ZWRcIl0gPSAzXSA9IFwiUGFyc2luZ1N0cmluZ1N0YXJ0ZWRcIjtcbiAgICBUb2tlbml6ZXJTdGF0ZXNbVG9rZW5pemVyU3RhdGVzW1wiUGFyc2luZ1N0cmluZ1wiXSA9IDRdID0gXCJQYXJzaW5nU3RyaW5nXCI7XG4gICAgVG9rZW5pemVyU3RhdGVzW1Rva2VuaXplclN0YXRlc1tcIlBhcnNpbmdTdHJpbmdGaW5pc2hlZFwiXSA9IDVdID0gXCJQYXJzaW5nU3RyaW5nRmluaXNoZWRcIjtcbiAgICBUb2tlbml6ZXJTdGF0ZXNbVG9rZW5pemVyU3RhdGVzW1wiUGFyc2luZ0Z1bmN0aW9uXCJdID0gNl0gPSBcIlBhcnNpbmdGdW5jdGlvblwiO1xuICAgIFRva2VuaXplclN0YXRlc1tUb2tlbml6ZXJTdGF0ZXNbXCJGaW5pc2hlZFwiXSA9IDddID0gXCJGaW5pc2hlZFwiO1xuICAgIFRva2VuaXplclN0YXRlc1tUb2tlbml6ZXJTdGF0ZXNbXCJQYXJzaW5nQ29udGV4dFwiXSA9IDhdID0gXCJQYXJzaW5nQ29udGV4dFwiO1xuICAgIFRva2VuaXplclN0YXRlc1tUb2tlbml6ZXJTdGF0ZXNbXCJQYXJzaW5nQnJhY2tldFwiXSA9IDldID0gXCJQYXJzaW5nQnJhY2tldFwiO1xuICAgIFRva2VuaXplclN0YXRlc1tUb2tlbml6ZXJTdGF0ZXNbXCJFcnJvclwiXSA9IDEwXSA9IFwiRXJyb3JcIjtcbn0pKFRva2VuaXplclN0YXRlcyB8fCAoVG9rZW5pemVyU3RhdGVzID0ge30pKTtcbnZhciBLbm93blN0cmluZ0NvbXBvbmVudHM7XG4oZnVuY3Rpb24gKEtub3duU3RyaW5nQ29tcG9uZW50cykge1xuICAgIEtub3duU3RyaW5nQ29tcG9uZW50c1tLbm93blN0cmluZ0NvbXBvbmVudHNbXCJEZWxpbWl0ZXJcIl0gPSAxXSA9IFwiRGVsaW1pdGVyXCI7XG4gICAgS25vd25TdHJpbmdDb21wb25lbnRzW0tub3duU3RyaW5nQ29tcG9uZW50c1tcIkRpZ2l0XCJdID0gMl0gPSBcIkRpZ2l0XCI7XG4gICAgS25vd25TdHJpbmdDb21wb25lbnRzW0tub3duU3RyaW5nQ29tcG9uZW50c1tcIkJyYWNrZXRcIl0gPSAzXSA9IFwiQnJhY2tldFwiO1xuICAgIEtub3duU3RyaW5nQ29tcG9uZW50c1tLbm93blN0cmluZ0NvbXBvbmVudHNbXCJPdGhlclwiXSA9IDRdID0gXCJPdGhlclwiO1xuICAgIEtub3duU3RyaW5nQ29tcG9uZW50c1tLbm93blN0cmluZ0NvbXBvbmVudHNbXCJDb250ZXh0QnJhY2tldFwiXSA9IDVdID0gXCJDb250ZXh0QnJhY2tldFwiO1xuICAgIEtub3duU3RyaW5nQ29tcG9uZW50c1tLbm93blN0cmluZ0NvbXBvbmVudHNbXCJRdW90ZVwiXSA9IDZdID0gXCJRdW90ZVwiO1xufSkoS25vd25TdHJpbmdDb21wb25lbnRzIHx8IChLbm93blN0cmluZ0NvbXBvbmVudHMgPSB7fSkpO1xuY29uc3QgdG9rZW5TdGF0ZU1hY2hpbmUgPSB7XG4gICAgW1Rva2VuaXplclN0YXRlcy5TdGFydGVkXToge1xuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkRlbGltaXRlcl06IFRva2VuaXplclN0YXRlcy5TdGFydGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkRpZ2l0XTogVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdOdW1iZXIsXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuQnJhY2tldF06IFRva2VuaXplclN0YXRlcy5QYXJzaW5nQnJhY2tldCxcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5PdGhlcl06IFRva2VuaXplclN0YXRlcy5QYXJzaW5nRnVuY3Rpb24sXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuQ29udGV4dEJyYWNrZXRdOiBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ0NvbnRleHQsXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuUXVvdGVdOiBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ1N0cmluZ1N0YXJ0ZWRcbiAgICB9LFxuICAgIFtUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ051bWJlcl06IHtcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5EZWxpbWl0ZXJdOiBUb2tlbml6ZXJTdGF0ZXMuRmluaXNoZWQsXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuRGlnaXRdOiBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ051bWJlcixcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5CcmFja2V0XTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLk90aGVyXTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkNvbnRleHRCcmFja2V0XTogVG9rZW5pemVyU3RhdGVzLkVycm9yLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLlF1b3RlXTogVG9rZW5pemVyU3RhdGVzLkVycm9yXG4gICAgfSxcbiAgICBbVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdGdW5jdGlvbl06IHtcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5EZWxpbWl0ZXJdOiBUb2tlbml6ZXJTdGF0ZXMuRmluaXNoZWQsXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuRGlnaXRdOiBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ0Z1bmN0aW9uLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkJyYWNrZXRdOiBUb2tlbml6ZXJTdGF0ZXMuRmluaXNoZWQsXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuT3RoZXJdOiBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ0Z1bmN0aW9uLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkNvbnRleHRCcmFja2V0XTogVG9rZW5pemVyU3RhdGVzLkVycm9yLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLlF1b3RlXTogVG9rZW5pemVyU3RhdGVzLkVycm9yXG4gICAgfSxcbiAgICBbVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdDb250ZXh0XToge1xuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkRlbGltaXRlcl06IFRva2VuaXplclN0YXRlcy5GaW5pc2hlZCxcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5EaWdpdF06IFRva2VuaXplclN0YXRlcy5QYXJzaW5nQ29udGV4dCxcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5CcmFja2V0XTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLk90aGVyXTogVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdDb250ZXh0LFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkNvbnRleHRCcmFja2V0XTogVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdDb250ZXh0LFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLlF1b3RlXTogVG9rZW5pemVyU3RhdGVzLkVycm9yXG4gICAgfSxcbiAgICBbVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdCcmFja2V0XToge1xuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkRlbGltaXRlcl06IFRva2VuaXplclN0YXRlcy5GaW5pc2hlZCxcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5EaWdpdF06IFRva2VuaXplclN0YXRlcy5GaW5pc2hlZCxcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5CcmFja2V0XTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLk90aGVyXTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkNvbnRleHRCcmFja2V0XTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLlF1b3RlXTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkXG4gICAgfSxcbiAgICBbVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdTdHJpbmdTdGFydGVkXToge1xuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkRlbGltaXRlcl06IFRva2VuaXplclN0YXRlcy5QYXJzaW5nU3RyaW5nLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkRpZ2l0XTogVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdTdHJpbmcsXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuQnJhY2tldF06IFRva2VuaXplclN0YXRlcy5QYXJzaW5nU3RyaW5nLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLk90aGVyXTogVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdTdHJpbmcsXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuQ29udGV4dEJyYWNrZXRdOiBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ1N0cmluZyxcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5RdW90ZV06IFRva2VuaXplclN0YXRlcy5GaW5pc2hlZFxuICAgIH0sXG4gICAgW1Rva2VuaXplclN0YXRlcy5QYXJzaW5nU3RyaW5nXToge1xuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkRlbGltaXRlcl06IFRva2VuaXplclN0YXRlcy5QYXJzaW5nU3RyaW5nLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkRpZ2l0XTogVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdTdHJpbmcsXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuQnJhY2tldF06IFRva2VuaXplclN0YXRlcy5QYXJzaW5nU3RyaW5nLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLk90aGVyXTogVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdTdHJpbmcsXG4gICAgICAgIFtLbm93blN0cmluZ0NvbXBvbmVudHMuQ29udGV4dEJyYWNrZXRdOiBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ1N0cmluZyxcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5RdW90ZV06IFRva2VuaXplclN0YXRlcy5QYXJzaW5nU3RyaW5nRmluaXNoZWRcbiAgICB9LFxuICAgIFtUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ1N0cmluZ0ZpbmlzaGVkXToge1xuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkRlbGltaXRlcl06IFRva2VuaXplclN0YXRlcy5GaW5pc2hlZCxcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5EaWdpdF06IFRva2VuaXplclN0YXRlcy5GaW5pc2hlZCxcbiAgICAgICAgW0tub3duU3RyaW5nQ29tcG9uZW50cy5CcmFja2V0XTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLk90aGVyXTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLkNvbnRleHRCcmFja2V0XTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkLFxuICAgICAgICBbS25vd25TdHJpbmdDb21wb25lbnRzLlF1b3RlXTogVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkXG4gICAgfVxufTtcbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0ge1xuICAgICAgICAgICAgXCIrXCI6IHtcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXBwbHk6IChhLCBiKSA9PiBhICsgYlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiLVwiOiB7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFwcGx5OiAoYSwgYikgPT4gYSAtIGJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIipcIjoge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhcHBseTogKGEsIGIpID0+IGEgKiBiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCIvXCI6IHtcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogMSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXBwbHk6IChhLCBiKSA9PiBhIC8gYlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJVwiOiB7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IDEsXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFwcGx5OiAoYSwgYikgPT4gYSAlIGJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcjoge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhcHBseTogKGEsIGIpID0+IGEgfHwgYlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFuZDoge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhcHBseTogKGEsIGIpID0+IGEgJiYgYlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiIVwiOiB7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IDIsXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFwcGx5OiAoYSkgPT4gIWFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlOiB7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IDEwMCxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXBwbHk6ICgpID0+IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZToge1xuICAgICAgICAgICAgICAgIHByaW9yaXR5OiAxMDAsXG4gICAgICAgICAgICAgICAgdmFyaWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFwcGx5OiAoKSA9PiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICQkZ2V0Q29udGV4dFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IDEwMCxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXBwbHk6IChjb250ZXh0UHJvcGVydHlOYW1lLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0eU5hbWUgPSBjb250ZXh0UHJvcGVydHlOYW1lLnN1YnN0cmluZygxLCBjb250ZXh0UHJvcGVydHlOYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge307XG4gICAgfVxuICAgIHN0YXRpYyBjbGFzc2lmeVN5bWJvbChzeW1ib2wpIHtcbiAgICAgICAgaWYgKEV4cHJlc3Npb24uZGVsaW1pdGVycy5pbmRleE9mKHN5bWJvbCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gS25vd25TdHJpbmdDb21wb25lbnRzLkRlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChFeHByZXNzaW9uLmJyYWNrZXRzLmluZGV4T2Yoc3ltYm9sKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBLbm93blN0cmluZ0NvbXBvbmVudHMuQnJhY2tldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChFeHByZXNzaW9uLmRpZ2l0cy5pbmRleE9mKHN5bWJvbCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gS25vd25TdHJpbmdDb21wb25lbnRzLkRpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEV4cHJlc3Npb24uY29udGV4dEJyYWNrZXRzLmluZGV4T2Yoc3ltYm9sKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBLbm93blN0cmluZ0NvbXBvbmVudHMuQ29udGV4dEJyYWNrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoRXhwcmVzc2lvbi5xdW90ZXMuaW5kZXhPZihzeW1ib2wpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIEtub3duU3RyaW5nQ29tcG9uZW50cy5RdW90ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBLbm93blN0cmluZ0NvbXBvbmVudHMuT3RoZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNPZk1vcmVPckVxdWFsUHJpb3JpdHkoY3VycmVudE9wLCBvdGhlck9wKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5vcGVyYXRpb25zW2N1cnJlbnRPcF0ucHJpb3JpdHkgPD0gdGhpcy5vcGVyYXRpb25zW290aGVyT3BdLnByaW9yaXR5KTtcbiAgICB9XG4gICAgc2NhblRva2VuKHN0ciwgc3RhcnQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gVG9rZW5pemVyU3RhdGVzLlN0YXJ0ZWQ7XG4gICAgICAgIGxldCB3b3JraW5nU3RhdGUgPSBUb2tlbml6ZXJTdGF0ZXMuRXJyb3I7XG4gICAgICAgIGxldCB0b2tlblN0cmluZyA9IFwiXCI7XG4gICAgICAgIGxldCBpID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCAmJlxuICAgICAgICAgICAgKHN0YXRlICE9PSBUb2tlbml6ZXJTdGF0ZXMuRmluaXNoZWQgJiYgc3RhdGUgIT09IFRva2VuaXplclN0YXRlcy5FcnJvcikpIHtcbiAgICAgICAgICAgIGxldCBzeW1ib2xDbGFzcyA9IEV4cHJlc3Npb24uY2xhc3NpZnlTeW1ib2woc3RyW2ldKTtcbiAgICAgICAgICAgIHN0YXRlID0gdG9rZW5TdGF0ZU1hY2hpbmVbc3RhdGVdW3N5bWJvbENsYXNzXTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdGdW5jdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uc1t0b2tlblN0cmluZ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gVG9rZW5pemVyU3RhdGVzLkZpbmlzaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ0Z1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgc3RhdGUgPT09IFRva2VuaXplclN0YXRlcy5QYXJzaW5nTnVtYmVyIHx8XG4gICAgICAgICAgICAgICAgc3RhdGUgPT09IFRva2VuaXplclN0YXRlcy5QYXJzaW5nQnJhY2tldCB8fFxuICAgICAgICAgICAgICAgIHN0YXRlID09PSBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ0NvbnRleHQgfHxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9PT0gVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB3b3JraW5nU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0b2tlblN0cmluZyArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSBUb2tlbml6ZXJTdGF0ZXMuU3RhcnRlZCB8fFxuICAgICAgICAgICAgICAgIHN0YXRlID09PSBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ1N0cmluZ1N0YXJ0ZWQgfHxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9PT0gVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdTdHJpbmdGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5TdHJpbmcgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdvcmtpbmdTdGF0ZSA9IFRva2VuaXplclN0YXRlcy5FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd29ya2luZ1N0YXRlLFxuICAgICAgICAgICAgdG9rZW5TdHJpbmcsXG4gICAgICAgICAgICBwb3M6IGlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29udmVydFRvUlBOKHRva2Vucykge1xuICAgICAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICAgICAgbGV0IHJwbiA9IFtdO1xuICAgICAgICBsZXQgY3VyclRva2VuO1xuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5zW2ldLnR5cGUgPT09IFwiblwiKSB7XG4gICAgICAgICAgICAgICAgcnBuW2orK10gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW5zW2ldLnR5cGUgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbnNbaV0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyclRva2VuID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHJwbltqKytdID0gY3VyclRva2VuO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHJwbltqIC0gMV0udHlwZSAhPT0gXCIoXCIpO1xuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLm9wZXJhdGlvbnMpLmluZGV4T2YodG9rZW5zW2ldLnR5cGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJUb2tlbiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnBuW2orK10gPSBjdXJyVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEV4cHJlc3Npb24uYnJhY2tldHMuaW5kZXhPZihycG5baiAtIDFdLnR5cGUpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc09mTW9yZU9yRXF1YWxQcmlvcml0eSh0b2tlbnNbaV0udHlwZSwgcnBuW2ogLSAxXS50eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChFeHByZXNzaW9uLmJyYWNrZXRzLmluZGV4T2YocnBuW2ogLSAxXS50eXBlKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLmlzT2ZNb3JlT3JFcXVhbFByaW9yaXR5KHRva2Vuc1tpXS50eXBlLCBycG5baiAtIDFdLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGN1cnJUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdXJyVG9rZW4gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJwbltqKytdID0gY3VyclRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBycG47XG4gICAgfVxuICAgIGNhbGN1bGF0ZVJQTihycG4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgb3BlcmFuZHMgPSBbXTtcbiAgICAgICAgaWYgKHJwbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnBuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocnBuW2ldLnR5cGUgPT09IFwiblwiKSB7XG4gICAgICAgICAgICAgICAgb3BlcmFuZHMucHVzaChycG5baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG9wID0gdGhpcy5vcGVyYXRpb25zW3JwbltpXS50eXBlXTtcbiAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IG9wLmFwcGx5O1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcC52YXJpYWJsZSA/IG9wZXJhbmRzLmxlbmd0aCA6IGZ1bmMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBhcmdzID0gb3BlcmFuZHMuc3BsaWNlKG9wZXJhbmRzLmxlbmd0aCAtIGxlbikubWFwKG9wID0+IG9wLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBvcGVyYW5kcy5wdXNoKHsgdHlwZTogXCJuXCIsIHZhbHVlOiByZXN1bHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcGVyYW5kcy5zaGlmdCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpIHx8IG51bGw7XG4gICAgfVxuICAgIHRva2VuaXplKGV4cHJlc3Npb24pIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgdG9rZW5DYW5kaWRhdGUgPSB0aGlzLnNjYW5Ub2tlbihleHByZXNzaW9uLCBpKTtcbiAgICAgICAgICAgIGlmICh0b2tlbkNhbmRpZGF0ZS53b3JraW5nU3RhdGUgIT09IFRva2VuaXplclN0YXRlcy5FcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkNhbmRpZGF0ZS53b3JraW5nU3RhdGUgPT09IFRva2VuaXplclN0YXRlcy5QYXJzaW5nTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuQ2FuZGlkYXRlLnRva2VuU3RyaW5nLmluZGV4T2YoXCIuXCIpICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VGbG9hdCh0b2tlbkNhbmRpZGF0ZS50b2tlblN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlSW50KHRva2VuQ2FuZGlkYXRlLnRva2VuU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5DYW5kaWRhdGUud29ya2luZ1N0YXRlID09PSBUb2tlbml6ZXJTdGF0ZXMuUGFyc2luZ0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCIkJGdldENvbnRleHRWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuQ2FuZGlkYXRlLnRva2VuU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuQ2FuZGlkYXRlLndvcmtpbmdTdGF0ZSA9PT0gVG9rZW5pemVyU3RhdGVzLlBhcnNpbmdTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW5DYW5kaWRhdGUudG9rZW5TdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2tlbkNhbmRpZGF0ZS50b2tlblN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSB0b2tlbkNhbmRpZGF0ZS5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgcmVnaXN0ZXIobmFtZSwgcHJpb3JpdHksIHZhcmlhYmxlLCBhcHBseSkge1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnNbbmFtZV0gPSB7IHByaW9yaXR5OiBwcmlvcml0eSwgdmFyaWFibGU6IHZhcmlhYmxlLCBhcHBseTogYXBwbHkgfTtcbiAgICB9XG4gICAgZXZhbHVhdGUoZXhwcmVzc2lvbiwgY29udGV4dCA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMudG9rZW5pemUoZXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IHJwbiA9IHRoaXMuY29udmVydFRvUlBOKHRva2Vucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVJQTihycG4pO1xuICAgIH1cbn1cbkV4cHJlc3Npb24uZGlnaXRzID0gXCIwMTIzNDU2Nzg5LlwiO1xuRXhwcmVzc2lvbi5icmFja2V0cyA9IFwiKClcIjtcbkV4cHJlc3Npb24uY29udGV4dEJyYWNrZXRzID0gXCJ7fVwiO1xuRXhwcmVzc2lvbi5kZWxpbWl0ZXJzID0gXCIgLFxcclxcclxcblwiO1xuRXhwcmVzc2lvbi5xdW90ZXMgPSBcIlxcJ1xcXCJcIjtcbiIsImV4cG9ydCBjbGFzcyBUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHt9O1xuICAgIH1cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbnRleHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZW5kZXIodGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL3t7KFtefV0rKX19L2csIChfbWF0Y2gsIHRva2VuKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3ViID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmIChzdWIubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN1Yi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtuZXh0XSA9IHN1Yi5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbbmV4dF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb2xvcnMsIExheW91dCwgU2VsZWN0YWJsZUdyaWQsIFNpemVzIH0gZnJvbSBcIi4vdWlcIjtcbmltcG9ydCB7IEV2ZW50UHVibGlzaGVyIH0gZnJvbSBcIi4vb2JzZXJ2YWJsZVwiO1xuaW1wb3J0IHsgRXhwcmVzc2lvbiB9IGZyb20gXCIuL2V4cHJlc3Npb25cIjtcbmltcG9ydCB7IFRlbXBsYXRlIH0gZnJvbSBcIi4vdGVtcGxhdGVcIjtcbmltcG9ydCAqIGFzIFBJWEkgZnJvbSBcInBpeGkuanNcIjtcbmV4cG9ydCBjbGFzcyBEaWFsb2dNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29udHJvbGxlci5hcHAubG9hZGVyLnJlc291cmNlc1snZGlhbG9ncy5qc29uJ10uZGF0YTtcbiAgICB9XG4gICAgZGlhbG9nKGhlcm8sIG5wYykge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZ1tucGMubmFtZV0gfHwgdGhpcy5jb25maWdbXCJkZWZhdWx0XCJdO1xuICAgICAgICByZXR1cm4gbmV3IERpYWxvZyh0aGlzLmNvbnRyb2xsZXIsIGhlcm8sIG5wYywgY29uZmlnKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGlhbG9nIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyLCBoZXJvLCBucGMsIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9xdWVzdGlvbiA9IG5ldyBFdmVudFB1Ymxpc2hlcigpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICB0aGlzLmhlcm8gPSBoZXJvO1xuICAgICAgICB0aGlzLm5wYyA9IG5wYztcbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLl9leHByZXNzaW9uID0gbmV3IEV4cHJlc3Npb24oKTtcbiAgICAgICAgdGhpcy5fZXhwcmVzc2lvbi5yZWdpc3RlcihcImdvdG9cIiwgMTAwLCB0cnVlLCB0aGlzLmdvdG8uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2V4cHJlc3Npb24ucmVnaXN0ZXIoXCJleGl0XCIsIDEwMCwgZmFsc2UsIHRoaXMuZXhpdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fZXhwcmVzc2lvbi5yZWdpc3RlcihcImNvbnRleHRcIiwgMTAwLCBmYWxzZSwgdGhpcy5jb250ZXh0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9leHByZXNzaW9uLnJlZ2lzdGVyKFwiaGFzU2tpbGxcIiwgMTAwLCBmYWxzZSwgdGhpcy5oYXNTa2lsbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fZXhwcmVzc2lvbi5yZWdpc3RlcihcInNraWxsXCIsIDEwMCwgZmFsc2UsIHRoaXMuc2tpbGwuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gbmV3IFRlbXBsYXRlKCk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlLmFkZChcImhlcm9cIiwgdGhpcy5oZXJvKTtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuYWRkKFwibnBjXCIsIHRoaXMubnBjKTtcbiAgICB9XG4gICAgZ2V0IHF1ZXN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVlc3Rpb247XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmdvdG8oLi4udGhpcy5fY29uZmlnLnN0YXJ0KTtcbiAgICB9XG4gICAgaGFzU2tpbGwoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnBjLmhhc1NraWxsKGlkKTtcbiAgICB9XG4gICAgc2tpbGwoaWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLm5wYy5nZXRTa2lsbChpZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2UodGhpcy5oZXJvKTtcbiAgICB9XG4gICAgZXhpdCgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmNsb3NlTW9kYWwoKTtcbiAgICB9XG4gICAgY29udGV4dChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ucGMuZ2V0Q29udGV4dChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ucGMuc2V0Q29udGV4dChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdvdG8oLi4uaWRzKSB7XG4gICAgICAgIGZvciAobGV0IGlkIG9mIGlkcykge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5fY29uZmlnLnF1ZXN0aW9uc1tpZF07XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVjayhjb25maWcuY29uZGl0aW9ucyB8fCBbXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5fdGVtcGxhdGUucmVuZGVyKGNvbmZpZy50ZXh0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWVzdGlvbiA9IG5ldyBEaWFsb2dRdWVzdGlvbih0aGlzLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhbnN3ZXIgb2YgY29uZmlnLmFuc3dlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2soYW5zd2VyLmNvbmRpdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5fdGVtcGxhdGUucmVuZGVyKGFuc3dlci50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXN0aW9uLmFkZCh0ZXh0LCBhbnN3ZXIuY29tbWFuZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXN0aW9uLnNlbmQocXVlc3Rpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjayhjb25kaXRpb25zKSB7XG4gICAgICAgIGlmIChjb25kaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBydWxlIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZXZhbHVhdGUocnVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZXZhbHVhdGUoY29tbWFuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwcmVzc2lvbi5ldmFsdWF0ZShjb21tYW5kKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGlhbG9nUXVlc3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGRpYWxvZywgdGV4dCkge1xuICAgICAgICB0aGlzLmFuc3dlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGFkZCh0ZXh0LCBjb21tYW5kcykge1xuICAgICAgICB0aGlzLmFuc3dlcnMucHVzaChuZXcgRGlhbG9nQW5zd2VyKHRoaXMuZGlhbG9nLCB0ZXh0LCBjb21tYW5kcykpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEaWFsb2dBbnN3ZXIge1xuICAgIGNvbnN0cnVjdG9yKGRpYWxvZywgdGV4dCwgY29tbWFuZHMpIHtcbiAgICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBjb21tYW5kcztcbiAgICB9XG4gICAgYWN0aW9uKCkge1xuICAgICAgICBmb3IgKGxldCBjb21tYW5kIG9mIHRoaXMuY29tbWFuZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLmV2YWx1YXRlKGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERpYWxvZ01vZGFsU2NlbmUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIsIGRpYWxvZykge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IExheW91dCgpO1xuICAgICAgICB0aGlzLl9xdWVzdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Fuc3dlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IG5ldyBTZWxlY3RhYmxlR3JpZCh0aGlzLmNvbnRyb2xsZXIuam95c3RpY2spO1xuICAgICAgICBjb25zdCB3aWR0aCA9IDYwMDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gNDAwO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQuYmVnaW5GaWxsKDB4MDAwMDAwKS5kcmF3UmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5lbmRGaWxsKCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC56SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmJhY2tncm91bmQpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zb3J0Q2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIucG9zaXRpb24uc2V0KCh0aGlzLmNvbnRyb2xsZXIuYXBwLnNjcmVlbi53aWR0aCA+PiAxKSAtICh3aWR0aCA+PiAxKSwgKHRoaXMuY29udHJvbGxlci5hcHAuc2NyZWVuLmhlaWdodCA+PiAxKSAtIChoZWlnaHQgPj4gMSkpO1xuICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9sYXlvdXQ7XG4gICAgICAgIGxheW91dC5vZmZzZXQoU2l6ZXMudWlNYXJnaW4sIFNpemVzLnVpTWFyZ2luKTtcbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuY29udHJvbGxlci5yZXNvdXJjZXMuYW5pbWF0ZWQodGhpcy5kaWFsb2cubnBjLm5hbWUgKyBcIl9pZGxlXCIpO1xuICAgICAgICBpY29uLmFuaW1hdGlvblNwZWVkID0gMC4yO1xuICAgICAgICBpY29uLnBsYXkoKTtcbiAgICAgICAgaWNvbi53aWR0aCA9IGljb24ud2lkdGggKiA0O1xuICAgICAgICBpY29uLmhlaWdodCA9IGljb24uaGVpZ2h0ICogNDtcbiAgICAgICAgaWNvbi5wb3NpdGlvbi5zZXQobGF5b3V0LnggKyBTaXplcy51aUJvcmRlciwgbGF5b3V0LnkgKyBTaXplcy51aUJvcmRlcik7XG4gICAgICAgIGNvbnN0IGljb25CZyA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4gICAgICAgIGljb25CZy5iZWdpbkZpbGwoQ29sb3JzLnVpQmFja2dyb3VuZClcbiAgICAgICAgICAgIC5kcmF3UmVjdChsYXlvdXQueCwgbGF5b3V0LnksIGljb24ud2lkdGggKyBTaXplcy51aUJvcmRlciAqIDIsIGljb24uaGVpZ2h0ICsgU2l6ZXMudWlCb3JkZXIgKiAyKVxuICAgICAgICAgICAgLmVuZEZpbGwoKTtcbiAgICAgICAgbGF5b3V0LnJlc2V0KCk7XG4gICAgICAgIGxheW91dC5vZmZzZXQoaWNvbi53aWR0aCwgMCk7XG4gICAgICAgIGxheW91dC5vZmZzZXQoU2l6ZXMudWlNYXJnaW4sIDApO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KFNpemVzLnVpQm9yZGVyICogMiwgMCk7XG4gICAgICAgIGxheW91dC5jb21taXQoKTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aCAtIGxheW91dC54O1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZChpY29uQmcsIGljb24pO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuc3RhZ2UuYWRkQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYXBwLnRpY2tlci5hZGQodGhpcy5oYW5kbGVJbnB1dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGlhbG9nLnF1ZXN0aW9uLnN1YnNjcmliZSh0aGlzLm9uUXVlc3Rpb24sIHRoaXMpO1xuICAgICAgICB0aGlzLmRpYWxvZy5zdGFydCgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmRpYWxvZy5xdWVzdGlvbi51bnN1YnNjcmliZSh0aGlzLm9uUXVlc3Rpb24sIHRoaXMpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5oYW5kbGVJbnB1dCwgdGhpcyk7XG4gICAgICAgIChfYSA9IHRoaXMuY29udGFpbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIChfYiA9IHRoaXMuYmFja2dyb3VuZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlID0gbnVsbDtcbiAgICB9XG4gICAgb25RdWVzdGlvbihxdWVzdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuX3F1ZXN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2Fuc3dlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhbnN3ZXIgPSB0aGlzLl9hbnN3ZXJzW2ldO1xuICAgICAgICAgICAgYW5zd2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0YWJsZS5yZW1vdmUoMCwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RhYmxlLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2Fuc3dlcnMgPSBbXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl93aWR0aCAtIFNpemVzLnVpTWFyZ2luICogMjtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fbGF5b3V0O1xuICAgICAgICBsYXlvdXQucmVzZXQoKTtcbiAgICAgICAgbGF5b3V0Lm9mZnNldChTaXplcy51aU1hcmdpbiwgU2l6ZXMudWlNYXJnaW4pO1xuICAgICAgICB0aGlzLl9xdWVzdGlvbiA9IG5ldyBEaWFsb2dRdWVzdGlvblZpZXcocXVlc3Rpb24sIHdpZHRoKTtcbiAgICAgICAgdGhpcy5fcXVlc3Rpb24ucG9zaXRpb24uc2V0KGxheW91dC54LCBsYXlvdXQueSk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKHRoaXMuX3F1ZXN0aW9uKTtcbiAgICAgICAgbGF5b3V0Lm9mZnNldCgwLCB0aGlzLl9xdWVzdGlvbi5oZWlnaHQpO1xuICAgICAgICBsYXlvdXQub2Zmc2V0KDAsIFNpemVzLnVpTWFyZ2luKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWVzdGlvbi5hbnN3ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYW5zd2VyID0gcXVlc3Rpb24uYW5zd2Vyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGlhbG9nQW5zd2VyVmlldyhhbnN3ZXIsIHdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0YWJsZS5zZXQoMCwgaSwgdmlldywgYW5zd2VyLmFjdGlvbi5iaW5kKGFuc3dlcikpO1xuICAgICAgICAgICAgdmlldy5wb3NpdGlvbi5zZXQobGF5b3V0LngsIGxheW91dC55KTtcbiAgICAgICAgICAgIGxheW91dC5vZmZzZXQoMCwgdmlldy5oZWlnaHQpO1xuICAgICAgICAgICAgbGF5b3V0Lm9mZnNldCgwLCBTaXplcy51aU1hcmdpbik7XG4gICAgICAgICAgICB0aGlzLl9hbnN3ZXJzLnB1c2godmlldyk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGFibGUucmVzZXQoKTtcbiAgICB9XG4gICAgaGFuZGxlSW5wdXQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5zZWxlY3RhYmxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlSW5wdXQoKTtcbiAgICB9XG59XG5jbGFzcyBEaWFsb2dRdWVzdGlvblZpZXcgZXh0ZW5kcyBQSVhJLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IocXVlc3Rpb24sIHdpZHRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RleHQgPSBuZXcgUElYSS5CaXRtYXBUZXh0KHF1ZXN0aW9uLnRleHQsIHsgZm9udDogeyBuYW1lOiBcImFsYWdhcmRcIiwgc2l6ZTogMTYgfSB9KTtcbiAgICAgICAgdGhpcy5fdGV4dC5tYXhXaWR0aCA9IHdpZHRoIC0gU2l6ZXMudWlCb3JkZXIgKiAyO1xuICAgICAgICB0aGlzLl90ZXh0LmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLl90ZXh0LnBvc2l0aW9uLnNldChTaXplcy51aUJvcmRlciwgU2l6ZXMudWlCb3JkZXIpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl90ZXh0LmhlaWdodCArIFNpemVzLnVpQm9yZGVyICogMjtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRcbiAgICAgICAgICAgIC5jbGVhcigpXG4gICAgICAgICAgICAuYmVnaW5GaWxsKENvbG9ycy51aUJhY2tncm91bmQsIDAuMylcbiAgICAgICAgICAgIC5kcmF3UmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICAgICAgLmVuZEZpbGwoKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLl9iYWNrZ3JvdW5kLCB0aGlzLl90ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBEaWFsb2dBbnN3ZXJWaWV3IGV4dGVuZHMgUElYSS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGFuc3dlciwgd2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuX3RleHQgPSBuZXcgUElYSS5CaXRtYXBUZXh0KGFuc3dlci50ZXh0LCB7IGZvbnQ6IHsgbmFtZTogXCJhbGFnYXJkXCIsIHNpemU6IDE2IH0gfSk7XG4gICAgICAgIHRoaXMuX3RleHQubWF4V2lkdGggPSB3aWR0aCAtIFNpemVzLnVpQm9yZGVyICogMjtcbiAgICAgICAgdGhpcy5fdGV4dC5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5fdGV4dC5wb3NpdGlvbi5zZXQoU2l6ZXMudWlCb3JkZXIsIFNpemVzLnVpQm9yZGVyKTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fdGV4dC5oZWlnaHQgKyBTaXplcy51aUJvcmRlciAqIDI7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLl9iYWNrZ3JvdW5kLCB0aGlzLl90ZXh0KTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZChzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kXG4gICAgICAgICAgICAuY2xlYXIoKVxuICAgICAgICAgICAgLmJlZ2luRmlsbChzZWxlY3RlZCA/IENvbG9ycy51aVNlbGVjdGVkIDogQ29sb3JzLnVpTm90U2VsZWN0ZWQpXG4gICAgICAgICAgICAuZHJhd1JlY3QoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodClcbiAgICAgICAgICAgIC5lbmRGaWxsKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgUk5HIH0gZnJvbSBcIi4vcm5nXCI7XG5pbXBvcnQgeyBKb3lzdGljayB9IGZyb20gXCIuL2lucHV0XCI7XG5pbXBvcnQgeyBZb3VEZWFkU2NlbmUgfSBmcm9tIFwiLi9kZWFkLnNjZW5lXCI7XG5pbXBvcnQgeyBHZW5lcmF0ZUR1bmdlb25TY2VuZSB9IGZyb20gXCIuL2dlbmVyYXRlLnNjZW5lXCI7XG5pbXBvcnQgeyBEdW5nZW9uU2NlbmUgfSBmcm9tIFwiLi9kdW5nZW9uLnNjZW5lXCI7XG5pbXBvcnQgeyBLZXlCaW5kU2NlbmUgfSBmcm9tIFwiLi9rZXliaW5kLnNjZW5lXCI7XG5pbXBvcnQgeyBTZWxlY3RIZXJvU2NlbmUgfSBmcm9tIFwiLi9zZWxlY3QuaGVyby5zY2VuZVwiO1xuaW1wb3J0IHsgVXBkYXRlSGVyb1NjZW5lIH0gZnJvbSBcIi4vdXBkYXRlLmhlcm8uc2NlbmVcIjtcbmltcG9ydCB7IEludmVudG9yeU1vZGFsU2NlbmUgfSBmcm9tIFwiLi9pbnZlbnRvcnkubW9kYWxcIjtcbmltcG9ydCB7IFNlc3Npb25QZXJzaXN0ZW50U3RhdGUgfSBmcm9tIFwiLi9wZXJzaXN0ZW50LnN0YXRlXCI7XG5pbXBvcnQgeyBEaWFsb2dNYW5hZ2VyLCBEaWFsb2dNb2RhbFNjZW5lIH0gZnJvbSBcIi4vZGlhbG9nXCI7XG5pbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCI7XG5pbXBvcnQgeyBEdW5nZW9uQm9uZmlyZURpYWxvZ01vZGFsIH0gZnJvbSBcIi4vZHVuZ2Vvbi5ib25maXJlXCI7XG5leHBvcnQgY2xhc3MgU2NlbmVDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvdXJjZXMsIGFwcCwgc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5tYWluU2NlbmUgPSBudWxsO1xuICAgICAgICB0aGlzLm1vZGFsU2NlbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbnQgPSBuZXcgU2Vzc2lvblBlcnNpc3RlbnRTdGF0ZSgpO1xuICAgICAgICB0aGlzLnJuZyA9IG5ldyBSTkcoKTtcbiAgICAgICAgdGhpcy5qb3lzdGljayA9IG5ldyBKb3lzdGljaygpO1xuICAgICAgICB0aGlzLnJlc291cmNlcyA9IHJlc291cmNlcztcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICAgICAgdGhpcy5kaWFsb2dzID0gbmV3IERpYWxvZ01hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5wZXJzaXN0ZW50Lmdsb2JhbC5jb21taXQsIHRoaXMucGVyc2lzdGVudC5nbG9iYWwsIFBJWEkuVVBEQVRFX1BSSU9SSVRZLkxPVyk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5wZXJzaXN0ZW50LnNlc3Npb24uY29tbWl0LCB0aGlzLnBlcnNpc3RlbnQuc2Vzc2lvbiwgUElYSS5VUERBVEVfUFJJT1JJVFkuTE9XKTtcbiAgICB9XG4gICAgc2V0IHNjZW5lKHNjZW5lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5tYWluU2NlbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuam95c3RpY2sucmVzZXQoKTtcbiAgICAgICAgdGhpcy5tYWluU2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5tYWluU2NlbmUuaW5pdCgpO1xuICAgIH1cbiAgICBrZXlCaW5kKCkge1xuICAgICAgICB0aGlzLnNjZW5lID0gbmV3IEtleUJpbmRTY2VuZSh0aGlzKTtcbiAgICB9XG4gICAgc2VsZWN0SGVybygpIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBTZWxlY3RIZXJvU2NlbmUodGhpcyk7XG4gICAgfVxuICAgIHVwZGF0ZUhlcm8oaGVybywgbGV2ZWwpIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBVcGRhdGVIZXJvU2NlbmUodGhpcywge1xuICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgaGVybzogaGVyb1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVhZCgpIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IG5ldyBZb3VEZWFkU2NlbmUodGhpcyk7XG4gICAgfVxuICAgIGdlbmVyYXRlRHVuZ2VvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBuZXcgR2VuZXJhdGVEdW5nZW9uU2NlbmUodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGR1bmdlb24oaGVybywgZHVuZ2Vvbikge1xuICAgICAgICB0aGlzLnNjZW5lID0gbmV3IER1bmdlb25TY2VuZSh0aGlzLCBoZXJvLCBkdW5nZW9uKTtcbiAgICB9XG4gICAgbW9kYWwoc2NlbmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBQSVhJLnNvdW5kLnBsYXkoJ3RleHQnKTtcbiAgICAgICAgKF9hID0gdGhpcy5tYWluU2NlbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgpO1xuICAgICAgICB0aGlzLmpveXN0aWNrLnJlc2V0KCk7XG4gICAgICAgIHRoaXMubW9kYWxTY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLm1vZGFsU2NlbmUuaW5pdCgpO1xuICAgIH1cbiAgICBjbG9zZU1vZGFsKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2EgPSB0aGlzLm1vZGFsU2NlbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuam95c3RpY2sucmVzZXQoKTtcbiAgICAgICAgKF9iID0gdGhpcy5tYWluU2NlbmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXN1bWUoKTtcbiAgICB9XG4gICAgc2hvd0ludmVudG9yeShoZXJvLCBucGMpIHtcbiAgICAgICAgdGhpcy5tb2RhbChuZXcgSW52ZW50b3J5TW9kYWxTY2VuZSh0aGlzLCBoZXJvLCBucGMgfHwgbnVsbCkpO1xuICAgIH1cbiAgICBzaG93RGlhbG9nKGhlcm8sIG5wYykge1xuICAgICAgICBjb25zdCBkaWFsb2cgPSB0aGlzLmRpYWxvZ3MuZGlhbG9nKGhlcm8sIG5wYyk7XG4gICAgICAgIHRoaXMubW9kYWwobmV3IERpYWxvZ01vZGFsU2NlbmUodGhpcywgZGlhbG9nKSk7XG4gICAgfVxuICAgIHNob3dCb25maXJlKGhlcm8pIHtcbiAgICAgICAgdGhpcy5tb2RhbChuZXcgRHVuZ2VvbkJvbmZpcmVEaWFsb2dNb2RhbCh0aGlzLCBoZXJvKSk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcnhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scene.ts\n");

/***/ }),

/***/ "./src/ui.ts":
/*!*******************!*\
  !*** ./src/ui.ts ***!
  \*******************/
/*! exports provided: Colors, Sizes, Button, Layout, SelectableGrid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Colors\", function() { return Colors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Sizes\", function() { return Sizes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Button\", function() { return Button; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layout\", function() { return Layout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectableGrid\", function() { return SelectableGrid; });\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"pixi.js\");\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixi_js__WEBPACK_IMPORTED_MODULE_0__);\n\nconst Colors = {\n    background: 0x202020,\n    uiBackground: 0x505050,\n    uiSelected: 0x909090,\n    uiNotSelected: 0x505050,\n    uiRed: 0xFF0000,\n    uiYellow: 0xFFD300,\n};\nconst Sizes = {\n    uiBorder: 4,\n    uiMargin: 16,\n};\nclass Button extends pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"] {\n    constructor(options) {\n        super();\n        this._selected = false;\n        this._width = options.width || 200;\n        this._height = options.height || 24;\n        this._textSize = options.textSize || 16;\n        this._bg = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Graphics\"]();\n        this._text = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"BitmapText\"](options.label, { font: { name: \"alagard\", size: this._textSize } });\n        this._text.anchor = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](0.5, 0.5);\n        this._text.position.set(this._width >> 1, this._height >> 1);\n        this.selected = options.selected || false;\n        super.addChild(this._bg, this._text);\n    }\n    get selected() {\n        return this._selected;\n    }\n    set selected(selected) {\n        this._selected = selected;\n        this._bg\n            .clear()\n            .beginFill(selected ? Colors.uiSelected : Colors.uiNotSelected)\n            .drawRect(0, 0, this._width, this._height)\n            .endFill();\n    }\n}\nclass Layout {\n    constructor() {\n        this.commitX = 0;\n        this.commitY = 0;\n        this.offsetX = 0;\n        this.offsetY = 0;\n    }\n    commit() {\n        this.commitX = this.offsetX;\n        this.commitY = this.offsetY;\n    }\n    reset() {\n        this.offsetX = this.commitX;\n        this.offsetY = this.commitY;\n    }\n    offset(x, y) {\n        this.offsetX += x;\n        this.offsetY += y;\n    }\n    get x() {\n        return this.offsetX;\n    }\n    get y() {\n        return this.offsetY;\n    }\n}\nfunction nextNonEmptyCount(counts, from) {\n    for (let i = from + 1; i < counts.length; i++) {\n        if (counts[i] > 0) {\n            return i;\n        }\n    }\n    return null;\n}\nfunction prevNonEmptyCount(counts, from) {\n    for (let i = from - 1; i >= 0; i--) {\n        if (counts[i] > 0) {\n            return i;\n        }\n    }\n    return null;\n}\nfunction nonEmptyCount(counts, curr) {\n    const i = curr || 0;\n    if (counts[i] > 0)\n        return i;\n    const p = prevNonEmptyCount(counts, i);\n    if (p !== null)\n        return p;\n    const n = nextNonEmptyCount(counts, i);\n    if (n !== null)\n        return n;\n    return null;\n}\nclass SelectableGrid {\n    constructor(joystick) {\n        this.cells = [];\n        this.counts_x = [];\n        this.counts_y = [];\n        this.limit_x = -1;\n        this.limit_y = -1;\n        this.selected_x = null;\n        this.selected_y = null;\n        this.joystick = joystick;\n    }\n    reset() {\n        this.unmark();\n        this.selected_x = nonEmptyCount(this.counts_x, this.selected_x);\n        this.selected_y = nonEmptyCount(this.counts_y, this.selected_y);\n        if (this.selected_x === null || this.selected_y === null) {\n            this.selected_x = null;\n            this.selected_y = null;\n        }\n        else {\n            if (!this.cell(this.selected_x, this.selected_y).isSelectable) {\n                const y = this.selected_y;\n                const prev = (from) => {\n                    for (let x = from - 1; x >= 0; x--) {\n                        if (this.cell(x, y).isSelectable) {\n                            return x;\n                        }\n                    }\n                    return null;\n                };\n                const p = prev(this.selected_x);\n                if (p !== null) {\n                    this.selected_x = p;\n                }\n                else {\n                    const next = (from) => {\n                        for (let x = from + 1; x <= this.limit_x; x++) {\n                            if (this.cell(x, y).isSelectable) {\n                                return x;\n                            }\n                        }\n                        return null;\n                    };\n                    const n = next(this.selected_x);\n                    if (n !== null) {\n                        this.selected_x = n;\n                    }\n                    else {\n                        throw \"illegal state\";\n                    }\n                }\n            }\n        }\n        this.mark();\n    }\n    moveLeft() {\n        var _a;\n        this.unmark();\n        if (this.selected_x !== null && this.selected_y !== null) {\n            const y = this.selected_y;\n            if (this.counts_y[y] === 0)\n                throw `illegal state: empty column ${y}`;\n            const merged = (_a = this.selectedCell) === null || _a === void 0 ? void 0 : _a.merged;\n            const start_x = this.selected_x;\n            const prev = (x) => x > 0 ? x - 1 : this.limit_x;\n            for (let x = prev(start_x); x != start_x; x = prev(x)) {\n                if (merged === null || merged === void 0 ? void 0 : merged.contains(x, y))\n                    continue;\n                if (this.cell(x, y).isSelectable) {\n                    this.selected_x = x;\n                    break;\n                }\n            }\n        }\n        this.mark();\n    }\n    moveRight() {\n        var _a;\n        this.unmark();\n        if (this.selected_x !== null && this.selected_y !== null) {\n            const y = this.selected_y;\n            if (this.counts_y[y] === 0)\n                throw `illegal state: empty column ${y}`;\n            const merged = (_a = this.selectedCell) === null || _a === void 0 ? void 0 : _a.merged;\n            const start_x = this.selected_x;\n            const next = (x) => (x + 1) % (this.limit_x + 1);\n            for (let x = next(start_x); x != start_x; x = next(x)) {\n                if (merged === null || merged === void 0 ? void 0 : merged.contains(x, y))\n                    continue;\n                if (this.cell(x, y).isSelectable) {\n                    this.selected_x = x;\n                    break;\n                }\n            }\n        }\n        this.mark();\n    }\n    moveUp() {\n        var _a;\n        this.unmark();\n        if (this.selected_x !== null && this.selected_y !== null) {\n            const x = this.selected_x;\n            if (this.counts_x[x] === 0)\n                throw `illegal state: empty row ${x}`;\n            const merged = (_a = this.selectedCell) === null || _a === void 0 ? void 0 : _a.merged;\n            const start_y = this.selected_y;\n            const prev = (y) => y > 0 ? y - 1 : this.limit_y;\n            for (let y = prev(start_y); y != start_y; y = prev(y)) {\n                if (merged === null || merged === void 0 ? void 0 : merged.contains(x, y))\n                    continue;\n                if (this.cell(x, y).isSelectable) {\n                    this.selected_y = y;\n                    break;\n                }\n            }\n        }\n        this.mark();\n    }\n    moveDown() {\n        var _a;\n        this.unmark();\n        if (this.selected_x !== null && this.selected_y !== null) {\n            const x = this.selected_x;\n            if (this.counts_x[x] === 0)\n                throw `illegal state: empty row ${x}`;\n            const merged = (_a = this.selectedCell) === null || _a === void 0 ? void 0 : _a.merged;\n            const start_y = this.selected_y;\n            const next = (y) => (y + 1) % (this.limit_y + 1);\n            for (let y = next(start_y); y != start_y; y = next(y)) {\n                if (merged === null || merged === void 0 ? void 0 : merged.contains(x, y))\n                    continue;\n                if (this.cell(x, y).isSelectable) {\n                    this.selected_y = y;\n                    break;\n                }\n            }\n        }\n        this.mark();\n    }\n    unmark() {\n        var _a;\n        (_a = this.selectedCell) === null || _a === void 0 ? void 0 : _a.unmark();\n    }\n    mark() {\n        var _a;\n        (_a = this.selectedCell) === null || _a === void 0 ? void 0 : _a.mark();\n    }\n    get selected() {\n        var _a;\n        return ((_a = this.selectedCell) === null || _a === void 0 ? void 0 : _a.value) || null;\n    }\n    get selectedCell() {\n        if (this.selected_x !== null && this.selected_y !== null) {\n            const cell = this.cell(this.selected_x, this.selected_y);\n            if (cell.merged && cell.isRef) {\n                return this.cell(cell.merged.from_x, cell.merged.from_y);\n            }\n            else {\n                return cell;\n            }\n        }\n        return null;\n    }\n    set(x, y, selectable, action) {\n        if (x < 0 || y < 0)\n            throw `illegal coordinate: ${x}:${y}`;\n        const cell = this.cell(x, y);\n        if (cell.isRef)\n            throw `cell is ref: ${x}:${y}`;\n        const has_prev = cell.value !== null;\n        cell.value = [selectable, action];\n        if (!has_prev) {\n            if (cell.merged) {\n                const merged = cell.merged;\n                for (let sx = merged.from_x; sx <= merged.to_x; sx++) {\n                    for (let sy = merged.from_y; sy <= merged.to_y; sy++) {\n                        this.counts_x[sx]++;\n                        this.counts_y[sy]++;\n                    }\n                }\n            }\n            else {\n                this.counts_x[x]++;\n                this.counts_y[y]++;\n            }\n        }\n        this.reset();\n    }\n    merge(x, y, width, height) {\n        if (x < 0 || y < 0)\n            throw `illegal coordinate: ${x}:${y}`;\n        if (width < 1 || height < 1)\n            throw `illegal size: ${width}:${height}`;\n        const merged = new MergedRegion(x, y, x + width - 1, y + height - 1);\n        const origin = this.cell(x, y);\n        if (origin.isRef)\n            throw `cell is ref: ${x}:${y}`;\n        if (origin.merged)\n            throw `cell is merged: ${JSON.stringify(origin.merged)}`;\n        origin.merged = merged;\n        const has_value = origin.value !== null;\n        for (let sx = merged.from_x; sx <= merged.to_x; sx++) {\n            for (let sy = merged.from_y; sy <= merged.to_y; sy++) {\n                if (!(sx === x && sy === y)) {\n                    const cell = this.cell(sx, sy);\n                    if (cell.value)\n                        throw `merging cell already has value: ${sx}:${sy}`;\n                    if (cell.isRef)\n                        throw `merging cell is ref: ${sx}:${sy}`;\n                    cell.merged = merged;\n                    if (has_value) {\n                        this.counts_x[sx]++;\n                        this.counts_y[sy]++;\n                    }\n                }\n            }\n        }\n    }\n    remove(x, y) {\n        if (x < 0 || y < 0)\n            throw `illegal coordinate: ${x}:${y}`;\n        const cell = this.cell(x, y);\n        if (cell.isRef)\n            throw `cell is ref: ${x}:${y}`;\n        if (cell.value) {\n            cell.value = null;\n            if (cell.merged) {\n                const merged = cell.merged;\n                for (let sx = merged.from_x; sx <= merged.to_x; sx++) {\n                    for (let sy = merged.from_y; sy <= merged.to_y; sy++) {\n                        this.counts_x[sx]--;\n                        this.counts_y[sy]--;\n                    }\n                }\n            }\n            else {\n                this.counts_x[x]--;\n                this.counts_y[y]--;\n            }\n        }\n    }\n    unmerge(x, y) {\n        if (x < 0 || y < 0)\n            throw `illegal coordinate: ${x}:${y}`;\n        const origin = this.cell(x, y);\n        if (origin.isRef)\n            throw `cell is ref: ${x}:${y}`;\n        if (origin.merged) {\n            const has_value = origin.value !== null;\n            const merged = origin.merged;\n            origin.merged = null;\n            for (let sx = merged.from_x; sx <= merged.to_x; sx++) {\n                for (let sy = merged.from_y; sy <= merged.to_y; sy++) {\n                    if (!(sx === x && sy === y)) {\n                        this.cell(sx, sy).merged = null;\n                        if (has_value) {\n                            this.counts_x[sx]--;\n                            this.counts_y[sy]--;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cell(x, y) {\n        if (x < 0 || y < 0)\n            throw \"illegal coordinate\";\n        this.expand(x, y);\n        return this.cells[y][x];\n    }\n    expand(to_x, to_y) {\n        while (this.limit_y < to_y) {\n            this.limit_y++;\n            this.counts_y[this.limit_y] = 0;\n            this.cells[this.limit_y] = [];\n            for (let x = 0; x <= this.limit_x; x++) {\n                this.cells[this.limit_y][x] = new SelectableCell(x, this.limit_y);\n            }\n        }\n        while (this.limit_x < to_x) {\n            this.limit_x++;\n            this.counts_x[this.limit_x] = 0;\n            for (let y = 0; y <= this.limit_y; y++) {\n                this.cells[y][this.limit_x] = new SelectableCell(this.limit_x, y);\n            }\n        }\n    }\n    handleInput() {\n        const joystick = this.joystick;\n        if (joystick.moveUp.once()) {\n            this.moveUp();\n        }\n        if (joystick.moveDown.once()) {\n            this.moveDown();\n        }\n        if (joystick.moveLeft.once()) {\n            this.moveLeft();\n        }\n        if (joystick.moveRight.once()) {\n            this.moveRight();\n        }\n        if (joystick.hit.once()) {\n            const selected = this.selected;\n            if (selected) {\n                let [, callback] = selected;\n                pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"sound\"].play('confirm');\n                callback();\n            }\n            else {\n                pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"sound\"].play('cancel');\n                console.warn(\"selected not found\");\n            }\n        }\n    }\n}\nclass SelectableCell {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.merged = null;\n        this.value = null;\n    }\n    unmark() {\n        if (this.value) {\n            this.value[0].selected = false;\n        }\n    }\n    mark() {\n        if (this.value) {\n            this.value[0].selected = true;\n        }\n    }\n    get isRef() {\n        return this.merged !== null && !(this.merged.from_x === this.x && this.merged.from_y === this.y);\n    }\n    get isSelectable() {\n        return this.value !== null || this.isRef;\n    }\n}\nclass MergedRegion {\n    constructor(from_x, from_y, to_x, to_y) {\n        this.from_x = from_x;\n        this.from_y = from_y;\n        this.to_x = to_x;\n        this.to_y = to_y;\n    }\n    contains(x, y) {\n        return x >= this.from_x && x <= this.to_x && y >= this.from_y && y <= this.to_y;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdWkudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdWkudHM/N2NjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBQSVhJIGZyb20gXCJwaXhpLmpzXCI7XG5leHBvcnQgY29uc3QgQ29sb3JzID0ge1xuICAgIGJhY2tncm91bmQ6IDB4MjAyMDIwLFxuICAgIHVpQmFja2dyb3VuZDogMHg1MDUwNTAsXG4gICAgdWlTZWxlY3RlZDogMHg5MDkwOTAsXG4gICAgdWlOb3RTZWxlY3RlZDogMHg1MDUwNTAsXG4gICAgdWlSZWQ6IDB4RkYwMDAwLFxuICAgIHVpWWVsbG93OiAweEZGRDMwMCxcbn07XG5leHBvcnQgY29uc3QgU2l6ZXMgPSB7XG4gICAgdWlCb3JkZXI6IDQsXG4gICAgdWlNYXJnaW46IDE2LFxufTtcbmV4cG9ydCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBQSVhJLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl93aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgMjAwO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCAyNDtcbiAgICAgICAgdGhpcy5fdGV4dFNpemUgPSBvcHRpb25zLnRleHRTaXplIHx8IDE2O1xuICAgICAgICB0aGlzLl9iZyA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuX3RleHQgPSBuZXcgUElYSS5CaXRtYXBUZXh0KG9wdGlvbnMubGFiZWwsIHsgZm9udDogeyBuYW1lOiBcImFsYWdhcmRcIiwgc2l6ZTogdGhpcy5fdGV4dFNpemUgfSB9KTtcbiAgICAgICAgdGhpcy5fdGV4dC5hbmNob3IgPSBuZXcgUElYSS5Qb2ludCgwLjUsIDAuNSk7XG4gICAgICAgIHRoaXMuX3RleHQucG9zaXRpb24uc2V0KHRoaXMuX3dpZHRoID4+IDEsIHRoaXMuX2hlaWdodCA+PiAxKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG9wdGlvbnMuc2VsZWN0ZWQgfHwgZmFsc2U7XG4gICAgICAgIHN1cGVyLmFkZENoaWxkKHRoaXMuX2JnLCB0aGlzLl90ZXh0KTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZChzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICB0aGlzLl9iZ1xuICAgICAgICAgICAgLmNsZWFyKClcbiAgICAgICAgICAgIC5iZWdpbkZpbGwoc2VsZWN0ZWQgPyBDb2xvcnMudWlTZWxlY3RlZCA6IENvbG9ycy51aU5vdFNlbGVjdGVkKVxuICAgICAgICAgICAgLmRyYXdSZWN0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpXG4gICAgICAgICAgICAuZW5kRmlsbCgpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbW1pdFggPSAwO1xuICAgICAgICB0aGlzLmNvbW1pdFkgPSAwO1xuICAgICAgICB0aGlzLm9mZnNldFggPSAwO1xuICAgICAgICB0aGlzLm9mZnNldFkgPSAwO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIHRoaXMuY29tbWl0WCA9IHRoaXMub2Zmc2V0WDtcbiAgICAgICAgdGhpcy5jb21taXRZID0gdGhpcy5vZmZzZXRZO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5vZmZzZXRYID0gdGhpcy5jb21taXRYO1xuICAgICAgICB0aGlzLm9mZnNldFkgPSB0aGlzLmNvbW1pdFk7XG4gICAgfVxuICAgIG9mZnNldCh4LCB5KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0WCArPSB4O1xuICAgICAgICB0aGlzLm9mZnNldFkgKz0geTtcbiAgICB9XG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldFg7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXRZO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5leHROb25FbXB0eUNvdW50KGNvdW50cywgZnJvbSkge1xuICAgIGZvciAobGV0IGkgPSBmcm9tICsgMTsgaSA8IGNvdW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY291bnRzW2ldID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwcmV2Tm9uRW1wdHlDb3VudChjb3VudHMsIGZyb20pIHtcbiAgICBmb3IgKGxldCBpID0gZnJvbSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChjb3VudHNbaV0gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG5vbkVtcHR5Q291bnQoY291bnRzLCBjdXJyKSB7XG4gICAgY29uc3QgaSA9IGN1cnIgfHwgMDtcbiAgICBpZiAoY291bnRzW2ldID4gMClcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgY29uc3QgcCA9IHByZXZOb25FbXB0eUNvdW50KGNvdW50cywgaSk7XG4gICAgaWYgKHAgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBwO1xuICAgIGNvbnN0IG4gPSBuZXh0Tm9uRW1wdHlDb3VudChjb3VudHMsIGkpO1xuICAgIGlmIChuICE9PSBudWxsKVxuICAgICAgICByZXR1cm4gbjtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBjbGFzcyBTZWxlY3RhYmxlR3JpZCB7XG4gICAgY29uc3RydWN0b3Ioam95c3RpY2spIHtcbiAgICAgICAgdGhpcy5jZWxscyA9IFtdO1xuICAgICAgICB0aGlzLmNvdW50c194ID0gW107XG4gICAgICAgIHRoaXMuY291bnRzX3kgPSBbXTtcbiAgICAgICAgdGhpcy5saW1pdF94ID0gLTE7XG4gICAgICAgIHRoaXMubGltaXRfeSA9IC0xO1xuICAgICAgICB0aGlzLnNlbGVjdGVkX3ggPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGVkX3kgPSBudWxsO1xuICAgICAgICB0aGlzLmpveXN0aWNrID0gam95c3RpY2s7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnVubWFyaygpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkX3ggPSBub25FbXB0eUNvdW50KHRoaXMuY291bnRzX3gsIHRoaXMuc2VsZWN0ZWRfeCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfeSA9IG5vbkVtcHR5Q291bnQodGhpcy5jb3VudHNfeSwgdGhpcy5zZWxlY3RlZF95KTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfeCA9PT0gbnVsbCB8fCB0aGlzLnNlbGVjdGVkX3kgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfeCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkX3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNlbGwodGhpcy5zZWxlY3RlZF94LCB0aGlzLnNlbGVjdGVkX3kpLmlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLnNlbGVjdGVkX3k7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IChmcm9tKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBmcm9tIC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNlbGwoeCwgeSkuaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcHJldih0aGlzLnNlbGVjdGVkX3gpO1xuICAgICAgICAgICAgICAgIGlmIChwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfeCA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gKGZyb20pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBmcm9tICsgMTsgeCA8PSB0aGlzLmxpbWl0X3g7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNlbGwoeCwgeSkuaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gbmV4dCh0aGlzLnNlbGVjdGVkX3gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF94ID0gbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiaWxsZWdhbCBzdGF0ZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFyaygpO1xuICAgIH1cbiAgICBtb3ZlTGVmdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnVubWFyaygpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZF94ICE9PSBudWxsICYmIHRoaXMuc2VsZWN0ZWRfeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuc2VsZWN0ZWRfeTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50c195W3ldID09PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IGBpbGxlZ2FsIHN0YXRlOiBlbXB0eSBjb2x1bW4gJHt5fWA7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSAoX2EgPSB0aGlzLnNlbGVjdGVkQ2VsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lcmdlZDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0X3ggPSB0aGlzLnNlbGVjdGVkX3g7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gKHgpID0+IHggPiAwID8geCAtIDEgOiB0aGlzLmxpbWl0X3g7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gcHJldihzdGFydF94KTsgeCAhPSBzdGFydF94OyB4ID0gcHJldih4KSkge1xuICAgICAgICAgICAgICAgIGlmIChtZXJnZWQgPT09IG51bGwgfHwgbWVyZ2VkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXJnZWQuY29udGFpbnMoeCwgeSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNlbGwoeCwgeSkuaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmsoKTtcbiAgICB9XG4gICAgbW92ZVJpZ2h0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudW5tYXJrKCk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX3ggIT09IG51bGwgJiYgdGhpcy5zZWxlY3RlZF95ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5zZWxlY3RlZF95O1xuICAgICAgICAgICAgaWYgKHRoaXMuY291bnRzX3lbeV0gPT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgYGlsbGVnYWwgc3RhdGU6IGVtcHR5IGNvbHVtbiAke3l9YDtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IChfYSA9IHRoaXMuc2VsZWN0ZWRDZWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVyZ2VkO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRfeCA9IHRoaXMuc2VsZWN0ZWRfeDtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSAoeCkgPT4gKHggKyAxKSAlICh0aGlzLmxpbWl0X3ggKyAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBuZXh0KHN0YXJ0X3gpOyB4ICE9IHN0YXJ0X3g7IHggPSBuZXh0KHgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlZCA9PT0gbnVsbCB8fCBtZXJnZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZC5jb250YWlucyh4LCB5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2VsbCh4LCB5KS5pc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF94ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFyaygpO1xuICAgIH1cbiAgICBtb3ZlVXAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy51bm1hcmsoKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfeCAhPT0gbnVsbCAmJiB0aGlzLnNlbGVjdGVkX3kgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLnNlbGVjdGVkX3g7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudHNfeFt4XSA9PT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBgaWxsZWdhbCBzdGF0ZTogZW1wdHkgcm93ICR7eH1gO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gKF9hID0gdGhpcy5zZWxlY3RlZENlbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXJnZWQ7XG4gICAgICAgICAgICBjb25zdCBzdGFydF95ID0gdGhpcy5zZWxlY3RlZF95O1xuICAgICAgICAgICAgY29uc3QgcHJldiA9ICh5KSA9PiB5ID4gMCA/IHkgLSAxIDogdGhpcy5saW1pdF95O1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHByZXYoc3RhcnRfeSk7IHkgIT0gc3RhcnRfeTsgeSA9IHByZXYoeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VkID09PSBudWxsIHx8IG1lcmdlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVyZ2VkLmNvbnRhaW5zKHgsIHkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jZWxsKHgsIHkpLmlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkX3kgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrKCk7XG4gICAgfVxuICAgIG1vdmVEb3duKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudW5tYXJrKCk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkX3ggIT09IG51bGwgJiYgdGhpcy5zZWxlY3RlZF95ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5zZWxlY3RlZF94O1xuICAgICAgICAgICAgaWYgKHRoaXMuY291bnRzX3hbeF0gPT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgYGlsbGVnYWwgc3RhdGU6IGVtcHR5IHJvdyAke3h9YDtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IChfYSA9IHRoaXMuc2VsZWN0ZWRDZWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVyZ2VkO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRfeSA9IHRoaXMuc2VsZWN0ZWRfeTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSAoeSkgPT4gKHkgKyAxKSAlICh0aGlzLmxpbWl0X3kgKyAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSBuZXh0KHN0YXJ0X3kpOyB5ICE9IHN0YXJ0X3k7IHkgPSBuZXh0KHkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlZCA9PT0gbnVsbCB8fCBtZXJnZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZC5jb250YWlucyh4LCB5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2VsbCh4LCB5KS5pc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZF95ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFyaygpO1xuICAgIH1cbiAgICB1bm1hcmsoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5zZWxlY3RlZENlbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm1hcmsoKTtcbiAgICB9XG4gICAgbWFyaygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnNlbGVjdGVkQ2VsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmsoKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5zZWxlY3RlZENlbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSkgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkQ2VsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRfeCAhPT0gbnVsbCAmJiB0aGlzLnNlbGVjdGVkX3kgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmNlbGwodGhpcy5zZWxlY3RlZF94LCB0aGlzLnNlbGVjdGVkX3kpO1xuICAgICAgICAgICAgaWYgKGNlbGwubWVyZ2VkICYmIGNlbGwuaXNSZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsKGNlbGwubWVyZ2VkLmZyb21feCwgY2VsbC5tZXJnZWQuZnJvbV95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXQoeCwgeSwgc2VsZWN0YWJsZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMClcbiAgICAgICAgICAgIHRocm93IGBpbGxlZ2FsIGNvb3JkaW5hdGU6ICR7eH06JHt5fWA7XG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmNlbGwoeCwgeSk7XG4gICAgICAgIGlmIChjZWxsLmlzUmVmKVxuICAgICAgICAgICAgdGhyb3cgYGNlbGwgaXMgcmVmOiAke3h9OiR7eX1gO1xuICAgICAgICBjb25zdCBoYXNfcHJldiA9IGNlbGwudmFsdWUgIT09IG51bGw7XG4gICAgICAgIGNlbGwudmFsdWUgPSBbc2VsZWN0YWJsZSwgYWN0aW9uXTtcbiAgICAgICAgaWYgKCFoYXNfcHJldikge1xuICAgICAgICAgICAgaWYgKGNlbGwubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gY2VsbC5tZXJnZWQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ggPSBtZXJnZWQuZnJvbV94OyBzeCA8PSBtZXJnZWQudG9feDsgc3grKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzeSA9IG1lcmdlZC5mcm9tX3k7IHN5IDw9IG1lcmdlZC50b195OyBzeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50c194W3N4XSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHNfeVtzeV0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnRzX3hbeF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50c195W3ldKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICBtZXJnZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMClcbiAgICAgICAgICAgIHRocm93IGBpbGxlZ2FsIGNvb3JkaW5hdGU6ICR7eH06JHt5fWA7XG4gICAgICAgIGlmICh3aWR0aCA8IDEgfHwgaGVpZ2h0IDwgMSlcbiAgICAgICAgICAgIHRocm93IGBpbGxlZ2FsIHNpemU6ICR7d2lkdGh9OiR7aGVpZ2h0fWA7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBNZXJnZWRSZWdpb24oeCwgeSwgeCArIHdpZHRoIC0gMSwgeSArIGhlaWdodCAtIDEpO1xuICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmNlbGwoeCwgeSk7XG4gICAgICAgIGlmIChvcmlnaW4uaXNSZWYpXG4gICAgICAgICAgICB0aHJvdyBgY2VsbCBpcyByZWY6ICR7eH06JHt5fWA7XG4gICAgICAgIGlmIChvcmlnaW4ubWVyZ2VkKVxuICAgICAgICAgICAgdGhyb3cgYGNlbGwgaXMgbWVyZ2VkOiAke0pTT04uc3RyaW5naWZ5KG9yaWdpbi5tZXJnZWQpfWA7XG4gICAgICAgIG9yaWdpbi5tZXJnZWQgPSBtZXJnZWQ7XG4gICAgICAgIGNvbnN0IGhhc192YWx1ZSA9IG9yaWdpbi52YWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgc3ggPSBtZXJnZWQuZnJvbV94OyBzeCA8PSBtZXJnZWQudG9feDsgc3grKykge1xuICAgICAgICAgICAgZm9yIChsZXQgc3kgPSBtZXJnZWQuZnJvbV95OyBzeSA8PSBtZXJnZWQudG9feTsgc3krKykge1xuICAgICAgICAgICAgICAgIGlmICghKHN4ID09PSB4ICYmIHN5ID09PSB5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5jZWxsKHN4LCBzeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgYG1lcmdpbmcgY2VsbCBhbHJlYWR5IGhhcyB2YWx1ZTogJHtzeH06JHtzeX1gO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbC5pc1JlZilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGBtZXJnaW5nIGNlbGwgaXMgcmVmOiAke3N4fToke3N5fWA7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwubWVyZ2VkID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50c194W3N4XSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHNfeVtzeV0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUoeCwgeSkge1xuICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDApXG4gICAgICAgICAgICB0aHJvdyBgaWxsZWdhbCBjb29yZGluYXRlOiAke3h9OiR7eX1gO1xuICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5jZWxsKHgsIHkpO1xuICAgICAgICBpZiAoY2VsbC5pc1JlZilcbiAgICAgICAgICAgIHRocm93IGBjZWxsIGlzIHJlZjogJHt4fToke3l9YDtcbiAgICAgICAgaWYgKGNlbGwudmFsdWUpIHtcbiAgICAgICAgICAgIGNlbGwudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNlbGwubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gY2VsbC5tZXJnZWQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ggPSBtZXJnZWQuZnJvbV94OyBzeCA8PSBtZXJnZWQudG9feDsgc3grKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzeSA9IG1lcmdlZC5mcm9tX3k7IHN5IDw9IG1lcmdlZC50b195OyBzeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50c194W3N4XS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHNfeVtzeV0tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnRzX3hbeF0tLTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50c195W3ldLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5tZXJnZSh4LCB5KSB7XG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMClcbiAgICAgICAgICAgIHRocm93IGBpbGxlZ2FsIGNvb3JkaW5hdGU6ICR7eH06JHt5fWA7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuY2VsbCh4LCB5KTtcbiAgICAgICAgaWYgKG9yaWdpbi5pc1JlZilcbiAgICAgICAgICAgIHRocm93IGBjZWxsIGlzIHJlZjogJHt4fToke3l9YDtcbiAgICAgICAgaWYgKG9yaWdpbi5tZXJnZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc192YWx1ZSA9IG9yaWdpbi52YWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG9yaWdpbi5tZXJnZWQ7XG4gICAgICAgICAgICBvcmlnaW4ubWVyZ2VkID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHN4ID0gbWVyZ2VkLmZyb21feDsgc3ggPD0gbWVyZ2VkLnRvX3g7IHN4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzeSA9IG1lcmdlZC5mcm9tX3k7IHN5IDw9IG1lcmdlZC50b195OyBzeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHN4ID09PSB4ICYmIHN5ID09PSB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxsKHN4LCBzeSkubWVyZ2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50c194W3N4XS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnRzX3lbc3ldLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2VsbCh4LCB5KSB7XG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMClcbiAgICAgICAgICAgIHRocm93IFwiaWxsZWdhbCBjb29yZGluYXRlXCI7XG4gICAgICAgIHRoaXMuZXhwYW5kKHgsIHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsc1t5XVt4XTtcbiAgICB9XG4gICAgZXhwYW5kKHRvX3gsIHRvX3kpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGltaXRfeSA8IHRvX3kpIHtcbiAgICAgICAgICAgIHRoaXMubGltaXRfeSsrO1xuICAgICAgICAgICAgdGhpcy5jb3VudHNfeVt0aGlzLmxpbWl0X3ldID0gMDtcbiAgICAgICAgICAgIHRoaXMuY2VsbHNbdGhpcy5saW1pdF95XSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPD0gdGhpcy5saW1pdF94OyB4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzW3RoaXMubGltaXRfeV1beF0gPSBuZXcgU2VsZWN0YWJsZUNlbGwoeCwgdGhpcy5saW1pdF95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5saW1pdF94IDwgdG9feCkge1xuICAgICAgICAgICAgdGhpcy5saW1pdF94Kys7XG4gICAgICAgICAgICB0aGlzLmNvdW50c194W3RoaXMubGltaXRfeF0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPD0gdGhpcy5saW1pdF95OyB5KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzW3ldW3RoaXMubGltaXRfeF0gPSBuZXcgU2VsZWN0YWJsZUNlbGwodGhpcy5saW1pdF94LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVJbnB1dCgpIHtcbiAgICAgICAgY29uc3Qgam95c3RpY2sgPSB0aGlzLmpveXN0aWNrO1xuICAgICAgICBpZiAoam95c3RpY2subW92ZVVwLm9uY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoam95c3RpY2subW92ZURvd24ub25jZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVEb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpveXN0aWNrLm1vdmVMZWZ0Lm9uY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb3lzdGljay5tb3ZlUmlnaHQub25jZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVSaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb3lzdGljay5oaXQub25jZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgWywgY2FsbGJhY2tdID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgUElYSS5zb3VuZC5wbGF5KCdjb25maXJtJyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFBJWEkuc291bmQucGxheSgnY2FuY2VsJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2VsZWN0ZWQgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2VsZWN0YWJsZUNlbGwge1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5tZXJnZWQgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgdW5tYXJrKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVswXS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hcmsoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlZCAhPT0gbnVsbCAmJiAhKHRoaXMubWVyZ2VkLmZyb21feCA9PT0gdGhpcy54ICYmIHRoaXMubWVyZ2VkLmZyb21feSA9PT0gdGhpcy55KTtcbiAgICB9XG4gICAgZ2V0IGlzU2VsZWN0YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgIT09IG51bGwgfHwgdGhpcy5pc1JlZjtcbiAgICB9XG59XG5jbGFzcyBNZXJnZWRSZWdpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZyb21feCwgZnJvbV95LCB0b194LCB0b195KSB7XG4gICAgICAgIHRoaXMuZnJvbV94ID0gZnJvbV94O1xuICAgICAgICB0aGlzLmZyb21feSA9IGZyb21feTtcbiAgICAgICAgdGhpcy50b194ID0gdG9feDtcbiAgICAgICAgdGhpcy50b195ID0gdG9feTtcbiAgICB9XG4gICAgY29udGFpbnMoeCwgeSkge1xuICAgICAgICByZXR1cm4geCA+PSB0aGlzLmZyb21feCAmJiB4IDw9IHRoaXMudG9feCAmJiB5ID49IHRoaXMuZnJvbV95ICYmIHkgPD0gdGhpcy50b195O1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/ui.ts\n");

/***/ }),

/***/ "pixi-layers":
/*!******************************!*\
  !*** external "PIXI.layers" ***!
  \******************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = PIXI.layers;

/***/ }),

/***/ "pixi-sound":
/*!*****************************!*\
  !*** external "PIXI.sound" ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = PIXI.sound;

/***/ }),

/***/ "pixi.js":
/*!***********************!*\
  !*** external "PIXI" ***!
  \***********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = PIXI;

/***/ })

/******/ });